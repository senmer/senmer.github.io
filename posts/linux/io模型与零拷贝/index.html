<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>IO模型与零拷贝 - Daben's Blog</title><meta name=Description content="This is my cool site"><meta property="og:title" content="IO模型与零拷贝"><meta property="og:description" content="本节内容主要用于理解Linux的I/O模型，以便更好地理解Nginx架构。"><meta property="og:type" content="article"><meta property="og:url" content="https://senmer.github.io/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-18T09:32:22+00:00"><meta property="article:modified_time" content="2022-07-18T09:32:22+00:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary"><meta name=twitter:title content="IO模型与零拷贝"><meta name=twitter:description content="本节内容主要用于理解Linux的I/O模型，以便更好地理解Nginx架构。"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://senmer.github.io/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/><link rel=prev href=https://senmer.github.io/posts/data_sync/windows%E5%90%91linux%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE/><link rel=next href=https://senmer.github.io/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"IO模型与零拷贝","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/senmer.github.io\/posts\/linux\/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D\/"},"genre":"posts","keywords":"I\/O","wordcount":9368,"url":"https:\/\/senmer.github.io\/posts\/linux\/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D\/","datePublished":"2022-07-18T09:32:22+00:00","dateModified":"2022-07-18T09:32:22+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"作者"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Daben's Blog">Daben's Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Daben's Blog">Daben's Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">IO模型与零拷贝</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>作者</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/linux/><i class="far fa-folder fa-fw" aria-hidden=true></i>Linux</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-07-18>2022-07-18</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 9368 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 19 分钟&nbsp;<span id=/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/ class=leancloud_visitors data-flag-title=IO模型与零拷贝>
<i class="far fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#磁盘-io>磁盘 I/O</a></li><li><a href=#网络-io>网络 I/O</a></li></ul><ul><li><a href=#io模型相关概念>I/O模型相关概念</a></li><li><a href=#网络-io-模型>网络 I/O 模型</a><ul><li><a href=#阻塞型--io-模型blocking-io><strong>阻塞型</strong> I/O 模型（blocking IO）</a></li><li><a href=#非阻塞-io-模型nonblocking-io>非阻塞 I/O 模型（nonblocking IO）</a></li><li><a href=#多路复用-io-模-型-io-multiplexing->多路复用 I/O 模 型（ I/O multiplexing ）</a></li><li><a href=#信号驱动式-io-模型signal-driven-io>信号驱动式 I/O 模型（signal-driven IO）</a></li><li><a href=#异步-io-模型-asynchronous-io->异步 I/O 模型（ asynchronous IO ）</a></li><li><a href=#五种-io-对比>五种 IO 对比</a></li><li><a href=#io-的具体实现方式>I/O 的具体实现方式</a></li></ul></li></ul><ul><li><a href=#零拷贝介绍>零拷贝介绍</a><ul><li><a href=#传统-linux-的io-问题>传统 Linux 的I/O 问题</a></li><li><a href=#什么是零拷贝>什么是零拷贝</a></li></ul></li><li><a href=#零拷贝相关技术>零拷贝相关技术</a><ul><li><a href=#mmap--memory-mapping-><strong>MMAP ( Memory Mapping )</strong></a></li><li><a href=#sendfirl>SENDFIRL</a></li><li><a href=#dma-辅助的-sendfile>DMA 辅助的 SENDFILE</a></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=本节内容主要用于理解linux的io模型以便更好地理解nginx架构>本节内容主要用于理解Linux的I/O模型，以便更好地理解Nginx架构。</h1><h1 id=io的定义>I/O的定义</h1><p>I/O在计算机中指Input/Output， IOPS (Input/Output Per Second)即每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一。IOPS是指单位时间内系统能处理的I/O请求数量，一般以每秒处理的I/O请求数量为单位，I/O请求通常为读或写数据操作请求。</p><p>一次完整的I/O是用户空间的进程数据与内核空间的内核数据的报文的完整交换，但是由于内核空间与用户空间是严格隔离的，所以其数据交换过程中不能由用户空间的进程直接调用内核空间的内存数据，而是需要经历一次从内核空间中的内存数据copy到用户空间的进程内存当中，所以简单说I/O就是把数据从内核空间中的内存数据复制到用户空间中进程的内存当中。</p><h1 id=linux-的-io>Linux 的 I/O</h1><ul><li>磁盘I/O</li><li>网络I/O : 一切皆文件,本质为对socket文件的读写</li></ul><h2 id=磁盘-io>磁盘 I/O</h2><p>磁盘I/O是进程向内核发起系统调用，请求磁盘上的某个资源比如是html 文件或者图片，然后内核通过相应的驱动程序将目标文件加载到内核的内存空间，加载完成之后把数据从内核内存（内核空间）再复制给进程内存（用户空间），如果是比较大的数据也需要等待一定时间。</p><pre tabindex=0><code>机械磁盘的寻道时间、旋转延迟和数据传输时间：
寻道时间：是指磁头移动到正确的磁道上所花费的时间，寻道时间越短则I/O处理就越快，目前磁盘的寻道时间一般在3-15毫秒左
右。
旋转延迟：是指将磁盘片旋转到数据所在的扇区到磁头下面所花费的时间，旋转延迟取决于磁盘的转速，通常使用磁盘旋转一周所
需要时间的1/2之一表示，比如7200转的磁盘平均训传延迟大约为60*1000/7200/2=4.17毫秒，公式的意思为 （每分钟60秒*1000毫秒每秒/7200转每分/2），如果是15000转的则为60*1000/15000/2=2毫秒。
数据传输时间：指的是读取到数据后传输数据的时间，主要取决于传输速率，这个值等于数据大小除以传输速率，目前的磁盘接口
每秒的传输速度可以达到600MB，因此可以忽略不计。
常见的机械磁盘平均寻道时间值：
7200转/分的磁盘平均物理寻道时间：9毫秒
10000转/分的磁盘平均物理寻道时间：6毫秒
15000转/分的磁盘平均物理寻道时间：4毫秒
常见磁盘的平均延迟时间：
7200转的机械盘平均延迟：60*1000/7200/2 = 4.17ms
10000转的机械盘平均延迟：60*1000/10000/2 = 3ms
15000转的机械盘平均延迟：60*1000/15000/2 = 2ms

每秒最大IOPS的计算方法：
7200转的磁盘IOPS计算方式：1000毫秒/(9毫秒的寻道时间+4.17毫秒的平均旋转延迟时间)=1000/13.13=75.9 IOPS
10000转的磁盘的IOPS计算方式：1000毫秒/(6毫秒的寻道时间+3毫秒的平均旋转延迟时间)=1000/9=111IOPS
15000转的磁盘的IOPS计算方式：15000毫秒/(4毫秒的寻道时间+2毫秒的平均旋转延迟时间)=1000/6=166.6 IOPS
</code></pre><h2 id=网络-io>网络 I/O</h2><p>网络协议栈到用户空间进程的IO就是网络IO</p><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/8.png data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/8.png, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/8.png 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/8.png 2x" data-sizes=auto alt=IO模型与零拷贝/8.png title=image-20220718113856909></p><p><strong>网络I/O处理过程</strong></p><pre tabindex=0><code>获取请求数据，客户端与服务器建立连接发出请求，服务器接受请求（1-3）
构建响应，当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）
返回数据，服务器将已构建好的响应再通过内核空间的网络 I/O 返回给客户端（5-7）
</code></pre><p><strong>每次I/O都要经历的两个阶段</strong></p><pre tabindex=0><code>第一步：将数据从文件先加载至内核内存空间（缓冲区），等待数据准备完成，时间较长（网络数据拷贝）
第二步：将数据从内核缓冲区复制到用户空间的进程的内存中，时间较短（内存数据拷贝）
</code></pre><h1 id=io-模型>I/O 模型</h1><h2 id=io模型相关概念>I/O模型相关概念</h2><p>同步/异步：关注的是消息通信机制，即调用者在等待一件事情的处理结果时，被调用者是否提供完成状态的通知。</p><ul><li>同步：synchronous，被调用者并不提供事件的处理结果相关的通知消息，需要调用者主动询问事情是否处理完成</li><li>异步：asynchronous，被调用者通过状态、通知或回调机制主动通知调用者被调用者的运行状态</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/9.png data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/9.png, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/9.png 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/9.png 2x" data-sizes=auto alt=IO模型与零拷贝/9.png title=image-20220718113656437></p><p>阻塞/非阻塞：关注调用者在等待结果返回之前所处的状态</p><ul><li>阻塞：blocking，指IO操作需要彻底完成后才返回到用户空间，调用结果返回之前，调用者被挂起，干不了别的事情。</li><li>非阻塞：nonblocking，指IO操作被调用后立即返回给用户一个状态值，而无需等到IO操作彻底完成，在最终的调用结果返回之前，调用者不会被挂起，可以去做别的事情。</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/10.png data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/10.png, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/10.png 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/10.png 2x" data-sizes=auto alt=IO模型与零拷贝/10.png title=image-20220718113856911></p><h2 id=网络-io-模型>网络 I/O 模型</h2><p>阻塞型、非阻塞型、复用型、信号驱动型、异步</p><h3 id=阻塞型--io-模型blocking-io><strong>阻塞型</strong> I/O 模型（blocking IO）</h3><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/11-16581165732495.png data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/11-16581165732495.png, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/11-16581165732495.png 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/11-16581165732495.png 2x" data-sizes=auto alt=IO模型与零拷贝/11-16581165732495.png title=image-20220718113856912></p><p>阻塞IO模型是最简单的I/O模型，用户线程在内核进行IO操作时被阻塞。</p><p>用户线程通过系统调用read发起I/O读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。</p><p>用户需要等待read将数据读取到buffer后，才继续处理接收的数据。整个I/O请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</p><p>优点：程序简单，在阻塞等待数据期间进程/线程挂起，基本不会占用 CPU 资源。</p><p>缺点：每个连接需要独立的进程/线程单独处理，当并发请求量大时为了维护程序，内存、线程切换开销较大。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>同步阻塞：程序向内核发送I/O请求后一直等待内核响应，如果内核处理请求的IO操作不能立即返回, 则进程将一直等待并不再接受新的请求，并由进程轮询查看I/O是否完成，完成后进程将I/O结果返回给Client，在IO没有返回期间进程不能接受其他客户的请求，而且是由进程自己去查看I/O是否完成，这种方式简单，但是比较慢，用的比较少。
</span></span></code></pre></div><h3 id=非阻塞-io-模型nonblocking-io>非阻塞 I/O 模型（nonblocking IO）</h3><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/12-165811710367510.png data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/12-165811710367510.png, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/12-165811710367510.png 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/12-165811710367510.png 2x" data-sizes=auto alt=IO模型与零拷贝/12-165811710367510.png title=非阻塞IO模型></p><p>用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。即 “轮询”机制存在两个问题：如果有大量文件描述符都要等，那么就得一个一个read。这会带来大量的Context Switch（read是系统调用，每调用一次就得在用户态和核心态切换一次）。轮询的时间不好把握。这里需要估计数据需要多久之后才能准备好。等待时间设的太长，程序响应延迟就过大; 设的太短，就会造成过于频繁的重试，干耗CPU而已，是比较浪费CPU的方式，一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>非阻塞：程序向内核发送请I/O求后一直等待内核响应，如果内核处理请求的IO操作不能立即返回IO结果，进程将不再等待，而是继续处理其他请求，但是仍然需要进程隔一段时间就要查看内核I/O是否完成。
</span></span></code></pre></div><p>由上图可知，在设置连接为非阻塞时，当应用进程系统调用 recvfrom 没有数据返回时，内核会立即返回一个 EWOULDBLOCK 错误，而不会一直阻塞到数据准备好。如上图在第四次调用时有一个数据报准备好了，所以这时数据会被复制到应用进程缓冲区 ，于是 recvfrom 成功返回数据。</p><p>当一个应用进程这样循环调用 recvfrom 时，称之为轮询 polling 。这么做往往会耗费大量CPU时间，这种模型实际很少被使用。</p><h3 id=多路复用-io-模-型-io-multiplexing->多路复用 I/O 模 型（ I/O multiplexing ）</h3><p>上面的模型中, 每一个文件描述符对应的IO均由一个线程监控和处理（有多少文件描述符就要生成多少个线程）</p><p>多路复用IO指一个线程可以同时（实际是交替实现，即并发完成）监控和处理多个文件描述符对应各自的IO，即复用同一个线程</p><p>一个线程之所以能实现同时处理多个IO, 是因为这个线程调用了内核中的SELECT, POLL或EPOLL等系统调用，从而实现多路复用IO</p><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/13.png data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/13.png, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/13.png 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/13.png 2x" data-sizes=auto alt=IO模型与零拷贝/13.png title=多路复用></p><p>I/O multiplexing 主要包括:select，poll，epoll三种系统调用，select/poll/epoll的好处就在于单个process（进程）就可以同时处理多个网络连接的IO。</p><p>它的基本原理就是select/poll/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><pre tabindex=0><code>IO多路复用（IO Multiplexing) ：是一种机制，程序注册一组socket文件描述符给操作系统，表示“我要监视这些fd是否有IO事件发生，有了就告诉程序处理”；
IO多路复用一般和NIO（nonblocking IO）一起使用的。NIO和IO多路复用是相对独立的。NIO仅仅是指IO API总是能立刻返回，不会被Blocking; 而IO多路复用仅仅是操作系统提供的一种便利的通知机制。操作系统并不会强制这俩必须得一起用，可以只用IO多路复用 + BIO（blocking IO），这时还是当前线程被卡住。IO多路复用和NIO是要配合一起使用才有实际意义；
IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备就绪，就通知该进程；
多个连接共用一个等待机制，本模型会阻塞进程，但是进程是阻塞在select或者poll这两个系统调用上，而不是阻塞在真正的IO操作上；
用户首先将需要进行IO操作添加到select中，同时等待select系统调用返回。当数据到达时，IO被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行；
从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视IO，以及调用select函数的额外操作，效率更差。并且阻塞了两次，但是第一次阻塞在select上时，select可以监控多个IO上是否已有IO操作准备就绪，即可达到在同一个线程内同时处理多个IO请求的目的。而不像阻塞IO那种，一次只能监控一个IO；
虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只是注册自己需要的IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率；
IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO模型，而非真正的异步IO；
</code></pre><p><strong>优缺点</strong></p><ul><li>优点：可以基于一个阻塞对象，同时在多个描述符上等待就绪，而不是使用多个线程(每个文件描述符一个线程)，这样可以大大节省系统资源</li><li>缺点：当连接数较少时效率相比多线程+阻塞 I/O 模型效率较低，可能延迟更大，因为单个连接处理需要 2 次系统调用（select和recvfrom），占用时间会有增加</li></ul><p><strong>IO多路复用适用如下场合：</strong></p><ul><li>当客户端处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用</li><li>当一个客户端同时处理多个套接字时，此情况可能的但很少出现</li><li>当一个服务器既要处理监听套接字，又要处理已连接套接字，一般也要用到I/O复用</li><li>当一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用</li><li>当一个服务器要处理多个服务或多个协议，一般要使用I/O复用</li></ul><h3 id=信号驱动式-io-模型signal-driven-io>信号驱动式 I/O 模型（signal-driven IO）</h3><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/14.png data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/14.png, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/14.png 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/14.png 2x" data-sizes=auto alt=IO模型与零拷贝/14.png title=信号驱动IO></p><p>信号驱动I/O的意思就是进程现在不用傻等着，也不用去轮询。而是让内核在数据就绪时，发送信号通知进程。</p><p>调用的步骤是，通过系统调用 sigaction ，并注册一个信号处理的回调函数，该调用会立即返回，然后主程序可以继续向下执行，当有I/O操作准备就绪,即内核数据就绪时，内核会为该进程产生一个 SIGIO信号，并回调注册的信号回调函数，这样就可以在信号回调函数中系统调用 recvfrom 获取数据,将用户进程所需要的数据从内核空间拷贝到用户空间。此模型的优势在于等待数据报到达期间进程不被阻塞。用户主程序可以继续执行，只要等待来自信号处理函数的通知。</p><p>在信号驱动式 I/O 模型中，应用程序使用套接口进行信号驱动 I/O，并注册一个信号处理函数，进程继续运行并不阻塞，当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。</p><p>优点：线程并没有在等待数据时被阻塞，内核直接返回调用接收信号，不影响进程继续处理其他请求因此可以提高资源的利用率。</p><p>缺点：信号 I/O 在大量 IO 操作时可能会因为信号队列溢出导致没法通知。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>异步阻塞：程序进程向内核发送IO调用后，不用等待内核响应，可以继续接受其他请求，内核收到进程请求后进行的IO如果不能立即返回，就由内核等待结果，直到IO完成后内核再通知进程。
</span></span></code></pre></div><h3 id=异步-io-模型-asynchronous-io->异步 I/O 模型（ asynchronous IO ）</h3><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/15.png data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/15.png, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/15.png 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/15.png 2x" data-sizes=auto alt=IO模型与零拷贝/15.png title=异步IO模型></p><p>异步I/O 与 信号驱动I/O最大区别在于，信号驱动是内核通知用户进程何时开始一个I/O操作，而异步I/O是由内核通知用户进程I/O操作何时完成，两者有本质区别在于异步IO相当于不用去饭店场吃饭，直接点个外卖，把等待上菜的时间也给省了。</p><p>相对于同步I/O，异步I/O不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。</p><p>信号驱动IO当内核通知触发信号处理程序时，信号处理程序还需要阻塞在从内核空间缓冲区拷贝数据到用户空间缓冲区这个阶段，而异步IO直接是在第二个阶段完成后，内核直接通知用户线程可以进行后续操作了</p><p>优点：异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠</p><p>缺点：要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O，在 Linux 系统下，Linux 2.6才引入，目前 AIO 并不完善，因此在 Linux 下实现高并发网络编程时以 IO 复用模型模式+多线程任务的架构基本可以满足需求</p><p>Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>异步非阻塞：程序进程向内核发送IO调用后，不用等待内核响应，可以继续接受其他请求，内核调用的IO如果不能立即返回，内核会继续处理其他事物，直到IO完成后将结果通知给内核，内核在将IO完成的结果返回给进程，期间进程可以接受新的请求，内核也可以处理新的事物，因此相互不影响，可以实现较大的同时并实现较高的IO复用，因此异步非阻塞是使用最多的一种通信方式。
</span></span></code></pre></div><h3 id=五种-io-对比>五种 IO 对比</h3><p>这五种 I/O 模型中，越往后，阻塞越少，理论上效率也是最优前四种属于同步 I/O，因为其中真正的 I/O 操作(recvfrom)将阻塞进程/线程，只有异步 I/O 模型才与 POSIX 定义的异步 I/O 相匹配。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/16.png data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/16.png, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/16.png 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/16.png 2x" data-sizes=auto alt=IO模型与零拷贝/16.png title=IO对比></p><h3 id=io-的具体实现方式>I/O 的具体实现方式</h3><h4 id=io-常见实现>I/O 常见实现</h4><p>Nginx支持在多种不同的操作系统实现不同的事件驱动模型，但是其在不同的操作系统甚至是不同的系统版本上面的实现方式不尽相同，主要有以下实现方式：</p><pre tabindex=0><code>1、select：
select库是在linux和windows平台都基本支持的 事件驱动模型库，并且在接口的定义也基本相同，只是部分参数的含义略有差异，最大并发限制1024，是最早期的事件驱动模型。
2、poll： 在Linux 的基本驱动模型，windows不支持此驱动模型，是select的升级版，取消了最大的并发限制，在编译nginx的时候可以使用--with-poll_module和--without-poll_module这两个指定是否编译select库。
3、epoll：
epoll是库是Nginx服务器支持的最高性能的事件驱动库之一，是公认的非常优秀的事件驱动模型，它和select和poll有很大的区别，epoll是poll的升级版，但是与poll有很大的区别.
epoll的处理方式是创建一个待处理的事件列表，然后把这个列表发给内核，返回的时候在去轮训检查这个表，以判断事件是否发生，epoll支持一个进程打开的最大事件描述符的上限是系统可以打开的文件的最大数，同时epoll库的I/O效率不随描述符数目增加而线性下降，因为它只会对内核上报的“活跃”的描述符进行操作。
4、kqueue：
用于支持BSD系列平台的高校事件驱动模型，主要用在FreeBSD 4.1及以上版本、OpenBSD 2.0级以上版本，NetBSD级以上版本及Mac OS X 平台上，该模型也是poll库的变种，因此和epoll没有本质上的区别，都是通过避免轮训操作提供效率。
5、Iocp：
 Windows系统上的实现方式，对应第5种（异步I/O）模型。
6、rtsig：
不是一个常用事件驱动，最大队列1024，不是很常用
7、/dev/poll:
用于支持unix衍生平台的高效事件驱动模型，主要在Solaris 平台、HP/UX，该模型是sun公司在开发Solaris系列平台的时候提出的用于完成事件驱动机制的方案，它使用了虚拟的/dev/poll设备，开发人员将要见识的文件描述符加入这个设备，然后通过ioctl()调用来获取事件通知，因此运行在以上系列平台的时候请使用/dev/poll事件驱动机制。
8、eventport：
该方案也是sun公司在开发Solaris的时候提出的事件驱动库，只是Solaris 10以上的版本，该驱动库看防止内核崩溃等情况的发生。
</code></pre><h4 id=常用-io-模型比较>常用 I/O 模型比较</h4><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/17.png data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/17.png, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/17.png 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/17.png 2x" data-sizes=auto alt=IO模型与零拷贝/17.png title=IO模型比较></p><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/18.png data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/18.png, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/18.png 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/18.png 2x" data-sizes=auto alt=IO模型与零拷贝/18.png title=image-10></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Select：
</span></span><span class=line><span class=cl>POSIX所规定，目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。
</span></span><span class=line><span class=cl>缺点：
</span></span><span class=line><span class=cl>单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义FD_SETSIZE，再重新编译内核实现，但是这样也会造成效率的降低
</span></span><span class=line><span class=cl>单个进程可监视的fd数量被限制，默认是1024，修改此值需要重新编译内核
</span></span><span class=line><span class=cl>对socket是线性扫描，即采用轮询的方法，效率较低
</span></span><span class=line><span class=cl>select 采取了内存拷贝方法来实现内核将 FD 消息通知给用户空间，这样一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>poll：
</span></span><span class=line><span class=cl>本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态
</span></span><span class=line><span class=cl>其没有最大连接数的限制，原因是它是基于链表来存储的
</span></span><span class=line><span class=cl>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义
</span></span><span class=line><span class=cl>poll特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd 
</span></span><span class=line><span class=cl>select是边缘触发即只通知一次
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>epoll： 在Linux 2.6内核中提出的select和poll的增强版本
</span></span><span class=line><span class=cl>支持水平触发LT和边缘触发ET，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次
</span></span><span class=line><span class=cl>使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知
</span></span><span class=line><span class=cl>优点:
</span></span><span class=line><span class=cl>没有最大并发连接的限制：能打开的FD的上限远大于1024(1G的内存能监听约10万个端口)，具体查看/proc/sys/fs/file-max，此值和系统内存大小相关
</span></span><span class=line><span class=cl>效率提升：非轮询的方式，不会随着FD数目的增加而效率下降;只有活跃可用的FD才会调用callback函数，即epoll最大的优点就在于它只管理“活跃”的连接，而跟连接总数无关
</span></span><span class=line><span class=cl>内存拷贝，利用mmap(Memory Mapping)加速与内核空间的消息传递;即epoll使用mmap减少复制开销
</span></span></code></pre></div><p><strong>总结</strong></p><pre tabindex=0><code>1、epoll只是一组API，比起select这种扫描全部的文件描述符，epoll只读取就绪的文件描述符，再加入基于事件的就绪通知机制，所以性能比较好
2、基于epoll的事件多路复用减少了进程间切换的次数，使得操作系统少做了相对于用户任务来说的无用功。
3、epoll比select等多路复用方式来说，减少了遍历循环及内存拷贝的工作量，因为活跃连接只占总并发连接的很小一部分。
</code></pre><p>范例：最大并发连接数和内存有直接关系</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#内存1G</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@centos8 ~<span class=o>]</span><span class=c1>#free -h</span>
</span></span><span class=line><span class=cl>             total       used       free     shared buff/cache   available
</span></span><span class=line><span class=cl>Mem:         952Mi       168Mi       605Mi       12Mi       178Mi       629Mi
</span></span><span class=line><span class=cl>Swap:         2.0Gi         0B       2.0Gi
</span></span><span class=line><span class=cl><span class=o>[</span>root@centos8 ~<span class=o>]</span><span class=c1>#cat /proc/sys/fs/file-max</span>
</span></span><span class=line><span class=cl><span class=m>92953</span>
</span></span><span class=line><span class=cl><span class=c1>#内存2G</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@centos8 ~<span class=o>]</span><span class=c1>#free -h</span>
</span></span><span class=line><span class=cl>             total       used       free     shared buff/cache   available
</span></span><span class=line><span class=cl>Mem:          1.9Gi       258Mi       1.3Gi       12Mi       341Mi       1.6Gi
</span></span><span class=line><span class=cl>Swap:         2.0Gi         0B       2.0Gi
</span></span><span class=line><span class=cl><span class=o>[</span>root@centos8 ~<span class=o>]</span><span class=c1>#cat /proc/sys/fs/file-max</span>
</span></span><span class=line><span class=cl><span class=m>195920</span>
</span></span></code></pre></div><p>范例：内核限制</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@centos8 ~<span class=o>]</span><span class=c1>#grep -R FD_SETSIZE linux-5.8/*</span>
</span></span><span class=line><span class=cl>linux-5.8/Documentation/userspace-api/media/v4l/func-select.rst:   
</span></span><span class=line><span class=cl><span class=sb>``</span>FD_SETSIZE<span class=sb>``</span>.
</span></span><span class=line><span class=cl>linux-5.8/include/uapi/linux/posix_types.h:#undef __FD_SETSIZE
</span></span><span class=line><span class=cl>linux-5.8/include/uapi/linux/posix_types.h:#define __FD_SETSIZE <span class=m>1024</span> <span class=c1>#单个进程能够</span>
</span></span><span class=line><span class=cl>监视的文件描述符的文件最大数量
</span></span><span class=line><span class=cl>linux-5.8/include/uapi/linux/posix_types.h: unsigned long fds_bits<span class=o>[</span>__FD_SETSIZE 
</span></span><span class=line><span class=cl>/ <span class=o>(</span><span class=m>8</span> * sizeof<span class=o>(</span>long<span class=o>))]</span><span class=p>;</span>
</span></span><span class=line><span class=cl>linux-5.8/tools/include/nolibc/nolibc.h:#define FD_SETSIZE <span class=m>256</span>
</span></span><span class=line><span class=cl>linux-5.8/tools/include/nolibc/nolibc.h:typedef struct <span class=o>{</span> uint32_t 
</span></span><span class=line><span class=cl>fd32<span class=o>[</span>FD_SETSIZE/32<span class=o>]</span><span class=p>;</span> <span class=o>}</span> fd_set<span class=p>;</span>
</span></span><span class=line><span class=cl>linux-5.8/tools/include/nolibc/nolibc.h: <span class=k>if</span> <span class=o>(</span>fd &lt; <span class=m>0</span> <span class=o>||</span> fd &gt;<span class=o>=</span> FD_SETSIZE<span class=o>)</span>
</span></span><span class=line><span class=cl>linux-5.8/tools/testing/selftests/net/nettest.c: <span class=nv>rc</span> <span class=o>=</span> <span class=k>select</span><span class=o>(</span>FD_SETSIZE, 
</span></span><span class=line><span class=cl>NULL, <span class=p>&amp;</span>wfd, NULL, tv<span class=o>)</span><span class=p>;</span>
</span></span></code></pre></div><p>范例：select 和 epoll 帮助</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@centos8 ~<span class=o>]</span><span class=c1>#whatis epoll</span>
</span></span><span class=line><span class=cl>epoll <span class=o>(</span>7<span class=o>)</span>            - I/O event notification facility
</span></span><span class=line><span class=cl><span class=o>[</span>root@centos8 ~<span class=o>]</span><span class=c1>#whatis select</span>
</span></span><span class=line><span class=cl><span class=k>select</span> <span class=o>(</span>2<span class=o>)</span>           - synchronous I/O multiplexing
</span></span><span class=line><span class=cl><span class=k>select</span> <span class=o>(</span>3<span class=o>)</span>           - synchronous I/O multiplexing
</span></span><span class=line><span class=cl><span class=k>select</span> <span class=o>(</span>3p<span class=o>)</span>          - synchronous I/O multiplexing
</span></span><span class=line><span class=cl><span class=o>[</span>root@centos8 ~<span class=o>]</span><span class=c1>#whatis poll</span>
</span></span><span class=line><span class=cl>poll <span class=o>(</span>2<span class=o>)</span>             - <span class=nb>wait</span> <span class=k>for</span> some event on a file descriptor
</span></span><span class=line><span class=cl>poll <span class=o>(</span>3p<span class=o>)</span>            - input/output multiplexing
</span></span><span class=line><span class=cl><span class=o>[</span>root@centos8 ~<span class=o>]</span><span class=c1>#man 2 select</span>
</span></span><span class=line><span class=cl>SELECT<span class=o>(</span>2<span class=o>)</span>                                               Linux Programmer<span class=s1>&#39;s 
</span></span></span><span class=line><span class=cl><span class=s1>Manual                                               SELECT(2)
</span></span></span><span class=line><span class=cl><span class=s1>NAME
</span></span></span><span class=line><span class=cl><span class=s1>       select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O 
</span></span></span><span class=line><span class=cl><span class=s1>multiplexing
</span></span></span><span class=line><span class=cl><span class=s1>[root@centos8 ~]#man 2 poll
</span></span></span><span class=line><span class=cl><span class=s1>POLL(2)                                                 Linux Programmer&#39;</span>s 
</span></span><span class=line><span class=cl>Manual                                                 POLL<span class=o>(</span>2<span class=o>)</span>
</span></span><span class=line><span class=cl>NAME
</span></span><span class=line><span class=cl>       poll, ppoll - <span class=nb>wait</span> <span class=k>for</span> some event on a file descriptor
</span></span></code></pre></div><h1 id=零拷贝>零拷贝</h1><h2 id=零拷贝介绍>零拷贝介绍</h2><h3 id=传统-linux-的io-问题>传统 Linux 的I/O 问题</h3><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/19.jpg data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/19.jpg, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/19.jpg 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/19.jpg 2x" data-sizes=auto alt=IO模型与零拷贝/19.jpg title=IO></p><p>传统的 Linux 系统的标准 I/O 接口（read、write）是基于数据拷贝的，也就是数据都是 copy_to_user 或者 copy_from_user，这样做的好处是，通过中间缓存的机制，减少磁盘 I/O 的操作，但是坏处也很明显，大量数据的拷贝，用户态和内核态的频繁切换，会消耗大量的 CPU 资源，严重影响数据传输的性能，统计表明，在Linux协议栈中，数据包在内核态和用户态之间的拷贝所用的时间甚至占到了数据包整个处理流程时间的57.1%</p><p>以上图为例，一次完整的网络请求涉及IO数据流向为：网络协议栈 &ndash;> 内核空间 &ndash;> 用户空间 &ndash;> 内核空间 &ndash; > 磁盘&ndash; > 内核空间&ndash; > 用户空间&ndash; > 内核空间&ndash; > 网络协议栈。可观察到一次IO过程，数据被拷贝了多次。</p><h3 id=什么是零拷贝>什么是零拷贝</h3><p>零拷贝就是上述问题的一个解决方案，通过尽量避免拷贝操作来缓解 CPU 的压力。零拷贝并没有真正做</p><p>到“0”拷贝，它更多是一种思想，很多的零拷贝技术都是基于这个思想去做的优化</p><h2 id=零拷贝相关技术>零拷贝相关技术</h2><h3 id=mmap--memory-mapping-><strong>MMAP ( Memory Mapping )</strong></h3><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/20.jpg data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/20.jpg, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/20.jpg 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/20.jpg 2x" data-sizes=auto alt=IO模型与零拷贝/20.jpg title=MMAP></p><p>mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问。</p><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。</p><p>实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p><p>内存映射减少数据在用户空间和内核空间之间的拷贝操作,适合大量数据传输。</p><p>以上图为例，网络请求到达内核空间（Socket缓存）后不再需要copy到用户空间，内存映射使得用户空间进程直接操作内核空间的数据，在处理完请求后，返回数据时也直接从内核空间（Kernerl缓存）拷贝到Socket缓存，再一次减少了内核空间与用户空间数据交换的过程。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/21.jpg data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/21.jpg, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/21.jpg 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/21.jpg 2x" data-sizes=auto alt=IO模型与零拷贝/21.jpg title=内存映射示意></p><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/22.png data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/22.png, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/22.png 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/22.png 2x" data-sizes=auto alt=IO模型与零拷贝/22.png title=传统读写与内存映射的比较></p><p>上面左图为传统读写,右图为MMAP.两者相比mmap要比普通的read系统调用少了一次copy的过程。因为read调用，进程是无法直接访问kernel space的，所以在read系统调用返回前，内核需要将数据从内核复制到进程指定的buffer。但mmap之后，进程可以直接访问mmap的数据(page cache)。</p><h3 id=sendfirl>SENDFIRL</h3><p>实现效果与MMAP类似，减少了用户空间和内存空间的上下文切换（数据拷贝）</p><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/23.jpg data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/23.jpg, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/23.jpg 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/23.jpg 2x" data-sizes=auto alt=IO模型与零拷贝/23.jpg title=sendfile></p><h3 id=dma-辅助的-sendfile>DMA 辅助的 SENDFILE</h3><p><img class=lazyload src=/svg/loading.min.svg data-src=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/24.jpg data-srcset="IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/24.jpg, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/24.jpg 1.5x, IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/24.jpg 2x" data-sizes=auto alt=IO模型与零拷贝/24.jpg title=硬件辅助的SENDFILE></p><p>Kernel 到 Sockert 只需要传输文件描述符，而数据直接通过DMA拷贝到网络协议栈。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-07-18</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://senmer.github.io/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/ data-title=IO模型与零拷贝 data-hashtags=I/O><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://senmer.github.io/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/ data-hashtag=I/O><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://senmer.github.io/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/ data-title=IO模型与零拷贝><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://senmer.github.io/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/ data-title=IO模型与零拷贝><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://senmer.github.io/posts/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/ data-title=IO模型与零拷贝><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/i/o/>I/O</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/data_sync/windows%E5%90%91linux%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE/ class=prev rel=prev title=windows向linux同步数据><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>windows向linux同步数据</a>
<a href=/posts/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/ class=next rel=next title=Nginx架构简介>Nginx架构简介<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=valine class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://valine.js.org/>Valine</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.105.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/valine/valine.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/valine@1.5.0/dist/Valine.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{valine:{appId:"5sitvRUskZFsUqZPlR7gPPkX-MdYXbMMI",appKey:"eOOoG9FJyETUTpDnzwzjb8z1",avatar:"mp",el:"#valine",emojiCDN:"https://cdn.jsdelivr.net/npm/emoji-datasource-google@14.0.0/img/google/64/",emojiMaps:{100:"1f4af.png",alien:"1f47d.png",anger:"1f4a2.png",angry:"1f620.png",anguished:"1f627.png",astonished:"1f632.png",black_heart:"1f5a4.png",blue_heart:"1f499.png",blush:"1f60a.png",bomb:"1f4a3.png",boom:"1f4a5.png",broken_heart:"1f494.png",brown_heart:"1f90e.png",clown_face:"1f921.png",cold_face:"1f976.png",cold_sweat:"1f630.png",confounded:"1f616.png",confused:"1f615.png",cry:"1f622.png",crying_cat_face:"1f63f.png",cupid:"1f498.png",dash:"1f4a8.png",disappointed:"1f61e.png",disappointed_relieved:"1f625.png",dizzy:"1f4ab.png",dizzy_face:"1f635.png",drooling_face:"1f924.png",exploding_head:"1f92f.png",expressionless:"1f611.png",face_vomiting:"1f92e.png",face_with_cowboy_hat:"1f920.png",face_with_hand_over_mouth:"1f92d.png",face_with_head_bandage:"1f915.png",face_with_monocle:"1f9d0.png",face_with_raised_eyebrow:"1f928.png",face_with_rolling_eyes:"1f644.png",face_with_symbols_on_mouth:"1f92c.png",face_with_thermometer:"1f912.png",fearful:"1f628.png",flushed:"1f633.png",frowning:"1f626.png",ghost:"1f47b.png",gift_heart:"1f49d.png",green_heart:"1f49a.png",grimacing:"1f62c.png",grin:"1f601.png",grinning:"1f600.png",hankey:"1f4a9.png",hear_no_evil:"1f649.png",heart:"2764-fe0f.png",heart_decoration:"1f49f.png",heart_eyes:"1f60d.png",heart_eyes_cat:"1f63b.png",heartbeat:"1f493.png",heartpulse:"1f497.png",heavy_heart_exclamation_mark_ornament:"2763-fe0f.png",hole:"1f573-fe0f.png",hot_face:"1f975.png",hugging_face:"1f917.png",hushed:"1f62f.png",imp:"1f47f.png",innocent:"1f607.png",japanese_goblin:"1f47a.png",japanese_ogre:"1f479.png",joy:"1f602.png",joy_cat:"1f639.png",kiss:"1f48b.png",kissing:"1f617.png",kissing_cat:"1f63d.png",kissing_closed_eyes:"1f61a.png",kissing_heart:"1f618.png",kissing_smiling_eyes:"1f619.png",laughing:"1f606.png",left_speech_bubble:"1f5e8-fe0f.png",love_letter:"1f48c.png",lying_face:"1f925.png",mask:"1f637.png",money_mouth_face:"1f911.png",nauseated_face:"1f922.png",nerd_face:"1f913.png",neutral_face:"1f610.png",no_mouth:"1f636.png",open_mouth:"1f62e.png",orange_heart:"1f9e1.png",partying_face:"1f973.png",pensive:"1f614.png",persevere:"1f623.png",pleading_face:"1f97a.png",pouting_cat:"1f63e.png",purple_heart:"1f49c.png",rage:"1f621.png",relaxed:"263a-fe0f.png",relieved:"1f60c.png",revolving_hearts:"1f49e.png",right_anger_bubble:"1f5ef-fe0f.png",robot_face:"1f916.png",rolling_on_the_floor_laughing:"1f923.png",scream:"1f631.png",scream_cat:"1f640.png",see_no_evil:"1f648.png",shushing_face:"1f92b.png",skull:"1f480.png",skull_and_crossbones:"2620-fe0f.png",sleeping:"1f634.png",sleepy:"1f62a.png",slightly_frowning_face:"1f641.png",slightly_smiling_face:"1f642.png",smile:"1f604.png",smile_cat:"1f638.png",smiley:"1f603.png",smiley_cat:"1f63a.png",smiling_face_with_3_hearts:"1f970.png",smiling_imp:"1f608.png",smirk:"1f60f.png",smirk_cat:"1f63c.png",sneezing_face:"1f927.png",sob:"1f62d.png",space_invader:"1f47e.png",sparkling_heart:"1f496.png",speak_no_evil:"1f64a.png",speech_balloon:"1f4ac.png","star-struck":"1f929.png",stuck_out_tongue:"1f61b.png",stuck_out_tongue_closed_eyes:"1f61d.png",stuck_out_tongue_winking_eye:"1f61c.png",sunglasses:"1f60e.png",sweat:"1f613.png",sweat_drops:"1f4a6.png",sweat_smile:"1f605.png",thinking_face:"1f914.png",thought_balloon:"1f4ad.png",tired_face:"1f62b.png",triumph:"1f624.png",two_hearts:"1f495.png",unamused:"1f612.png",upside_down_face:"1f643.png",weary:"1f629.png",white_frowning_face:"2639-fe0f.png",white_heart:"1f90d.png",wink:"1f609.png",woozy_face:"1f974.png",worried:"1f61f.png",yawning_face:"1f971.png",yellow_heart:"1f49b.png",yum:"1f60b.png",zany_face:"1f92a.png",zipper_mouth_face:"1f910.png",zzz:"1f4a4.png"},enableQQ:!1,highlight:!0,lang:"zh-CN",pageSize:10,placeholder:"comment",recordIP:!0,serverURLs:"https://5sitvrus.api.lncldglobal.com",visitor:!0}},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:30,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>