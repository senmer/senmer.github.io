<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>IO模型与零拷贝 | WZ's Blog</title>
<meta name=keywords content="I/O"><meta name=description content="本节内容主要用于理解Linux的I/O模型，以便更好地理解Nginx架构。"><meta name=author content="wz"><link rel=canonical href=https://senmer.github.io/zh/posts/tech/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/><link crossorigin=anonymous href=/assets/css/stylesheet.5a2b6d77cc78ad18bcb4914c5c639c7ce5ab55e956c461d4310747892b3f50c2.css integrity="sha256-Wittd8x4rRi8tJFMXGOcfOWrVelWxGHUMQdHiSs/UMI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://senmer.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://senmer.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://senmer.github.io/img/Q.gif><link rel=apple-touch-icon href=https://senmer.github.io/img/Q.gif><link rel=mask-icon href=https://senmer.github.io/img/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4d7c4710a089d70b71310f0e1ec7681b",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="IO模型与零拷贝"><meta property="og:description" content="本节内容主要用于理解Linux的I/O模型，以便更好地理解Nginx架构。"><meta property="og:type" content="article"><meta property="og:url" content="https://senmer.github.io/zh/posts/tech/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-18T09:32:22+00:00"><meta property="article:modified_time" content="2022-07-18T09:32:22+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="IO模型与零拷贝"><meta name=twitter:description content="本节内容主要用于理解Linux的I/O模型，以便更好地理解Nginx架构。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚文章","item":"https://senmer.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻 技术","item":"https://senmer.github.io/zh/posts/tech/"},{"@type":"ListItem","position":3,"name":"IO模型与零拷贝","item":"https://senmer.github.io/zh/posts/tech/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"IO模型与零拷贝","name":"IO模型与零拷贝","description":"本节内容主要用于理解Linux的I/O模型，以便更好地理解Nginx架构。\n","keywords":["I/O"],"articleBody":"本节内容主要用于理解Linux的I/O模型，以便更好地理解Nginx架构。\nI/O的定义 I/O在计算机中指Input/Output， IOPS (Input/Output Per Second)即每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一。IOPS是指单位时间内系统能处理的I/O请求数量，一般以每秒处理的I/O请求数量为单位，I/O请求通常为读或写数据操作请求。\n一次完整的I/O是用户空间的进程数据与内核空间的内核数据的报文的完整交换，但是由于内核空间与用户空间是严格隔离的，所以其数据交换过程中不能由用户空间的进程直接调用内核空间的内存数据，而是需要经历一次从内核空间中的内存数据copy到用户空间的进程内存当中，所以简单说I/O就是把数据从内核空间中的内存数据复制到用户空间中进程的内存当中。\nLinux 的 I/O 磁盘I/O 网络I/O : 一切皆文件,本质为对socket文件的读写 磁盘 I/O 磁盘I/O是进程向内核发起系统调用，请求磁盘上的某个资源比如是html 文件或者图片，然后内核通过相应的驱动程序将目标文件加载到内核的内存空间，加载完成之后把数据从内核内存（内核空间）再复制给进程内存（用户空间），如果是比较大的数据也需要等待一定时间。\n机械磁盘的寻道时间、旋转延迟和数据传输时间： 寻道时间：是指磁头移动到正确的磁道上所花费的时间，寻道时间越短则I/O处理就越快，目前磁盘的寻道时间一般在3-15毫秒左 右。 旋转延迟：是指将磁盘片旋转到数据所在的扇区到磁头下面所花费的时间，旋转延迟取决于磁盘的转速，通常使用磁盘旋转一周所 需要时间的1/2之一表示，比如7200转的磁盘平均训传延迟大约为60*1000/7200/2=4.17毫秒，公式的意思为 （每分钟60秒*1000毫秒每秒/7200转每分/2），如果是15000转的则为60*1000/15000/2=2毫秒。 数据传输时间：指的是读取到数据后传输数据的时间，主要取决于传输速率，这个值等于数据大小除以传输速率，目前的磁盘接口 每秒的传输速度可以达到600MB，因此可以忽略不计。 常见的机械磁盘平均寻道时间值： 7200转/分的磁盘平均物理寻道时间：9毫秒 10000转/分的磁盘平均物理寻道时间：6毫秒 15000转/分的磁盘平均物理寻道时间：4毫秒 常见磁盘的平均延迟时间： 7200转的机械盘平均延迟：60*1000/7200/2 = 4.17ms 10000转的机械盘平均延迟：60*1000/10000/2 = 3ms 15000转的机械盘平均延迟：60*1000/15000/2 = 2ms 每秒最大IOPS的计算方法： 7200转的磁盘IOPS计算方式：1000毫秒/(9毫秒的寻道时间+4.17毫秒的平均旋转延迟时间)=1000/13.13=75.9 IOPS 10000转的磁盘的IOPS计算方式：1000毫秒/(6毫秒的寻道时间+3毫秒的平均旋转延迟时间)=1000/9=111IOPS 15000转的磁盘的IOPS计算方式：15000毫秒/(4毫秒的寻道时间+2毫秒的平均旋转延迟时间)=1000/6=166.6 IOPS 网络 I/O 网络协议栈到用户空间进程的IO就是网络IO\n网络I/O处理过程\n获取请求数据，客户端与服务器建立连接发出请求，服务器接受请求（1-3） 构建响应，当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4） 返回数据，服务器将已构建好的响应再通过内核空间的网络 I/O 返回给客户端（5-7） 每次I/O都要经历的两个阶段\n第一步：将数据从文件先加载至内核内存空间（缓冲区），等待数据准备完成，时间较长（网络数据拷贝） 第二步：将数据从内核缓冲区复制到用户空间的进程的内存中，时间较短（内存数据拷贝） I/O 模型 I/O模型相关概念 同步/异步：关注的是消息通信机制，即调用者在等待一件事情的处理结果时，被调用者是否提供完成状态的通知。\n同步：synchronous，被调用者并不提供事件的处理结果相关的通知消息，需要调用者主动询问事情是否处理完成 异步：asynchronous，被调用者通过状态、通知或回调机制主动通知调用者被调用者的运行状态 阻塞/非阻塞：关注调用者在等待结果返回之前所处的状态\n阻塞：blocking，指IO操作需要彻底完成后才返回到用户空间，调用结果返回之前，调用者被挂起，干不了别的事情。 非阻塞：nonblocking，指IO操作被调用后立即返回给用户一个状态值，而无需等到IO操作彻底完成，在最终的调用结果返回之前，调用者不会被挂起，可以去做别的事情。 网络 I/O 模型 阻塞型、非阻塞型、复用型、信号驱动型、异步\n阻塞型 I/O 模型（blocking IO） 阻塞IO模型是最简单的I/O模型，用户线程在内核进行IO操作时被阻塞。\n用户线程通过系统调用read发起I/O读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。\n用户需要等待read将数据读取到buffer后，才继续处理接收的数据。整个I/O请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。\n优点：程序简单，在阻塞等待数据期间进程/线程挂起，基本不会占用 CPU 资源。\n缺点：每个连接需要独立的进程/线程单独处理，当并发请求量大时为了维护程序，内存、线程切换开销较大。\n同步阻塞：程序向内核发送I/O请求后一直等待内核响应，如果内核处理请求的IO操作不能立即返回, 则进程将一直等待并不再接受新的请求，并由进程轮询查看I/O是否完成，完成后进程将I/O结果返回给Client，在IO没有返回期间进程不能接受其他客户的请求，而且是由进程自己去查看I/O是否完成，这种方式简单，但是比较慢，用的比较少。 非阻塞 I/O 模型（nonblocking IO） 用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。即 “轮询”机制存在两个问题：如果有大量文件描述符都要等，那么就得一个一个read。这会带来大量的Context Switch（read是系统调用，每调用一次就得在用户态和核心态切换一次）。轮询的时间不好把握。这里需要估计数据需要多久之后才能准备好。等待时间设的太长，程序响应延迟就过大; 设的太短，就会造成过于频繁的重试，干耗CPU而已，是比较浪费CPU的方式，一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。\n非阻塞：程序向内核发送请I/O求后一直等待内核响应，如果内核处理请求的IO操作不能立即返回IO结果，进程将不再等待，而是继续处理其他请求，但是仍然需要进程隔一段时间就要查看内核I/O是否完成。 由上图可知，在设置连接为非阻塞时，当应用进程系统调用 recvfrom 没有数据返回时，内核会立即返回一个 EWOULDBLOCK 错误，而不会一直阻塞到数据准备好。如上图在第四次调用时有一个数据报准备好了，所以这时数据会被复制到应用进程缓冲区 ，于是 recvfrom 成功返回数据。\n当一个应用进程这样循环调用 recvfrom 时，称之为轮询 polling 。这么做往往会耗费大量CPU时间，这种模型实际很少被使用。\n多路复用 I/O 模 型（ I/O multiplexing ） 上面的模型中, 每一个文件描述符对应的IO均由一个线程监控和处理（有多少文件描述符就要生成多少个线程）\n多路复用IO指一个线程可以同时（实际是交替实现，即并发完成）监控和处理多个文件描述符对应各自的IO，即复用同一个线程\n一个线程之所以能实现同时处理多个IO, 是因为这个线程调用了内核中的SELECT, POLL或EPOLL等系统调用，从而实现多路复用IO\nI/O multiplexing 主要包括:select，poll，epoll三种系统调用，select/poll/epoll的好处就在于单个process（进程）就可以同时处理多个网络连接的IO。\n它的基本原理就是select/poll/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。\n当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。\nIO多路复用（IO Multiplexing) ：是一种机制，程序注册一组socket文件描述符给操作系统，表示“我要监视这些fd是否有IO事件发生，有了就告诉程序处理”； IO多路复用一般和NIO（nonblocking IO）一起使用的。NIO和IO多路复用是相对独立的。NIO仅仅是指IO API总是能立刻返回，不会被Blocking; 而IO多路复用仅仅是操作系统提供的一种便利的通知机制。操作系统并不会强制这俩必须得一起用，可以只用IO多路复用 + BIO（blocking IO），这时还是当前线程被卡住。IO多路复用和NIO是要配合一起使用才有实际意义； IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备就绪，就通知该进程； 多个连接共用一个等待机制，本模型会阻塞进程，但是进程是阻塞在select或者poll这两个系统调用上，而不是阻塞在真正的IO操作上； 用户首先将需要进行IO操作添加到select中，同时等待select系统调用返回。当数据到达时，IO被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行； 从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视IO，以及调用select函数的额外操作，效率更差。并且阻塞了两次，但是第一次阻塞在select上时，select可以监控多个IO上是否已有IO操作准备就绪，即可达到在同一个线程内同时处理多个IO请求的目的。而不像阻塞IO那种，一次只能监控一个IO； 虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只是注册自己需要的IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率； IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO模型，而非真正的异步IO； 优缺点\n优点：可以基于一个阻塞对象，同时在多个描述符上等待就绪，而不是使用多个线程(每个文件描述符一个线程)，这样可以大大节省系统资源 缺点：当连接数较少时效率相比多线程+阻塞 I/O 模型效率较低，可能延迟更大，因为单个连接处理需要 2 次系统调用（select和recvfrom），占用时间会有增加 IO多路复用适用如下场合：\n当客户端处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用 当一个客户端同时处理多个套接字时，此情况可能的但很少出现 当一个服务器既要处理监听套接字，又要处理已连接套接字，一般也要用到I/O复用 当一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用 当一个服务器要处理多个服务或多个协议，一般要使用I/O复用 信号驱动式 I/O 模型（signal-driven IO） 信号驱动I/O的意思就是进程现在不用傻等着，也不用去轮询。而是让内核在数据就绪时，发送信号通知进程。\n调用的步骤是，通过系统调用 sigaction ，并注册一个信号处理的回调函数，该调用会立即返回，然后主程序可以继续向下执行，当有I/O操作准备就绪,即内核数据就绪时，内核会为该进程产生一个 SIGIO信号，并回调注册的信号回调函数，这样就可以在信号回调函数中系统调用 recvfrom 获取数据,将用户进程所需要的数据从内核空间拷贝到用户空间。此模型的优势在于等待数据报到达期间进程不被阻塞。用户主程序可以继续执行，只要等待来自信号处理函数的通知。\n在信号驱动式 I/O 模型中，应用程序使用套接口进行信号驱动 I/O，并注册一个信号处理函数，进程继续运行并不阻塞，当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。\n优点：线程并没有在等待数据时被阻塞，内核直接返回调用接收信号，不影响进程继续处理其他请求因此可以提高资源的利用率。\n缺点：信号 I/O 在大量 IO 操作时可能会因为信号队列溢出导致没法通知。\n异步阻塞：程序进程向内核发送IO调用后，不用等待内核响应，可以继续接受其他请求，内核收到进程请求后进行的IO如果不能立即返回，就由内核等待结果，直到IO完成后内核再通知进程。 异步 I/O 模型（ asynchronous IO ） 异步I/O 与 信号驱动I/O最大区别在于，信号驱动是内核通知用户进程何时开始一个I/O操作，而异步I/O是由内核通知用户进程I/O操作何时完成，两者有本质区别在于异步IO相当于不用去饭店场吃饭，直接点个外卖，把等待上菜的时间也给省了。\n相对于同步I/O，异步I/O不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。\n信号驱动IO当内核通知触发信号处理程序时，信号处理程序还需要阻塞在从内核空间缓冲区拷贝数据到用户空间缓冲区这个阶段，而异步IO直接是在第二个阶段完成后，内核直接通知用户线程可以进行后续操作了\n优点：异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠\n缺点：要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O，在 Linux 系统下，Linux 2.6才引入，目前 AIO 并不完善，因此在 Linux 下实现高并发网络编程时以 IO 复用模型模式+多线程任务的架构基本可以满足需求\nLinux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。\n异步非阻塞：程序进程向内核发送IO调用后，不用等待内核响应，可以继续接受其他请求，内核调用的IO如果不能立即返回，内核会继续处理其他事物，直到IO完成后将结果通知给内核，内核在将IO完成的结果返回给进程，期间进程可以接受新的请求，内核也可以处理新的事物，因此相互不影响，可以实现较大的同时并实现较高的IO复用，因此异步非阻塞是使用最多的一种通信方式。 五种 IO 对比 这五种 I/O 模型中，越往后，阻塞越少，理论上效率也是最优前四种属于同步 I/O，因为其中真正的 I/O 操作(recvfrom)将阻塞进程/线程，只有异步 I/O 模型才与 POSIX 定义的异步 I/O 相匹配。\nI/O 的具体实现方式 I/O 常见实现 Nginx支持在多种不同的操作系统实现不同的事件驱动模型，但是其在不同的操作系统甚至是不同的系统版本上面的实现方式不尽相同，主要有以下实现方式：\n1、select： select库是在linux和windows平台都基本支持的 事件驱动模型库，并且在接口的定义也基本相同，只是部分参数的含义略有差异，最大并发限制1024，是最早期的事件驱动模型。 2、poll： 在Linux 的基本驱动模型，windows不支持此驱动模型，是select的升级版，取消了最大的并发限制，在编译nginx的时候可以使用--with-poll_module和--without-poll_module这两个指定是否编译select库。 3、epoll： epoll是库是Nginx服务器支持的最高性能的事件驱动库之一，是公认的非常优秀的事件驱动模型，它和select和poll有很大的区别，epoll是poll的升级版，但是与poll有很大的区别. epoll的处理方式是创建一个待处理的事件列表，然后把这个列表发给内核，返回的时候在去轮训检查这个表，以判断事件是否发生，epoll支持一个进程打开的最大事件描述符的上限是系统可以打开的文件的最大数，同时epoll库的I/O效率不随描述符数目增加而线性下降，因为它只会对内核上报的“活跃”的描述符进行操作。 4、kqueue： 用于支持BSD系列平台的高校事件驱动模型，主要用在FreeBSD 4.1及以上版本、OpenBSD 2.0级以上版本，NetBSD级以上版本及Mac OS X 平台上，该模型也是poll库的变种，因此和epoll没有本质上的区别，都是通过避免轮训操作提供效率。 5、Iocp： Windows系统上的实现方式，对应第5种（异步I/O）模型。 6、rtsig： 不是一个常用事件驱动，最大队列1024，不是很常用 7、/dev/poll: 用于支持unix衍生平台的高效事件驱动模型，主要在Solaris 平台、HP/UX，该模型是sun公司在开发Solaris系列平台的时候提出的用于完成事件驱动机制的方案，它使用了虚拟的/dev/poll设备，开发人员将要见识的文件描述符加入这个设备，然后通过ioctl()调用来获取事件通知，因此运行在以上系列平台的时候请使用/dev/poll事件驱动机制。 8、eventport： 该方案也是sun公司在开发Solaris的时候提出的事件驱动库，只是Solaris 10以上的版本，该驱动库看防止内核崩溃等情况的发生。 常用 I/O 模型比较 Select： POSIX所规定，目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。 缺点： 单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义FD_SETSIZE，再重新编译内核实现，但是这样也会造成效率的降低 单个进程可监视的fd数量被限制，默认是1024，修改此值需要重新编译内核 对socket是线性扫描，即采用轮询的方法，效率较低 select 采取了内存拷贝方法来实现内核将 FD 消息通知给用户空间，这样一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大 poll： 本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态 其没有最大连接数的限制，原因是它是基于链表来存储的 大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义 poll特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd select是边缘触发即只通知一次 epoll： 在Linux 2.6内核中提出的select和poll的增强版本 支持水平触发LT和边缘触发ET，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次 使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知 优点: 没有最大并发连接的限制：能打开的FD的上限远大于1024(1G的内存能监听约10万个端口)，具体查看/proc/sys/fs/file-max，此值和系统内存大小相关 效率提升：非轮询的方式，不会随着FD数目的增加而效率下降;只有活跃可用的FD才会调用callback函数，即epoll最大的优点就在于它只管理“活跃”的连接，而跟连接总数无关 内存拷贝，利用mmap(Memory Mapping)加速与内核空间的消息传递;即epoll使用mmap减少复制开销 总结\n1、epoll只是一组API，比起select这种扫描全部的文件描述符，epoll只读取就绪的文件描述符，再加入基于事件的就绪通知机制，所以性能比较好 2、基于epoll的事件多路复用减少了进程间切换的次数，使得操作系统少做了相对于用户任务来说的无用功。 3、epoll比select等多路复用方式来说，减少了遍历循环及内存拷贝的工作量，因为活跃连接只占总并发连接的很小一部分。 范例：最大并发连接数和内存有直接关系\n#内存1G [root@centos8 ~]#free -h total used free shared buff/cache available Mem: 952Mi 168Mi 605Mi 12Mi 178Mi 629Mi Swap: 2.0Gi 0B 2.0Gi [root@centos8 ~]#cat /proc/sys/fs/file-max 92953 #内存2G [root@centos8 ~]#free -h total used free shared buff/cache available Mem: 1.9Gi 258Mi 1.3Gi 12Mi 341Mi 1.6Gi Swap: 2.0Gi 0B 2.0Gi [root@centos8 ~]#cat /proc/sys/fs/file-max 195920 范例：内核限制\n[root@centos8 ~]#grep -R FD_SETSIZE linux-5.8/* linux-5.8/Documentation/userspace-api/media/v4l/func-select.rst: ``FD_SETSIZE``. linux-5.8/include/uapi/linux/posix_types.h:#undef __FD_SETSIZE linux-5.8/include/uapi/linux/posix_types.h:#define __FD_SETSIZE 1024 #单个进程能够 监视的文件描述符的文件最大数量 linux-5.8/include/uapi/linux/posix_types.h: unsigned long fds_bits[__FD_SETSIZE / (8 * sizeof(long))]; linux-5.8/tools/include/nolibc/nolibc.h:#define FD_SETSIZE 256 linux-5.8/tools/include/nolibc/nolibc.h:typedef struct { uint32_t fd32[FD_SETSIZE/32]; } fd_set; linux-5.8/tools/include/nolibc/nolibc.h: if (fd \u003c 0 || fd \u003e= FD_SETSIZE) linux-5.8/tools/testing/selftests/net/nettest.c: rc = select(FD_SETSIZE, NULL, \u0026wfd, NULL, tv); 范例：select 和 epoll 帮助\n[root@centos8 ~]#whatis epoll epoll (7) - I/O event notification facility [root@centos8 ~]#whatis select select (2) - synchronous I/O multiplexing select (3) - synchronous I/O multiplexing select (3p) - synchronous I/O multiplexing [root@centos8 ~]#whatis poll poll (2) - wait for some event on a file descriptor poll (3p) - input/output multiplexing [root@centos8 ~]#man 2 select SELECT(2) Linux Programmer's Manual SELECT(2) NAME select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O multiplexing [root@centos8 ~]#man 2 poll POLL(2) Linux Programmer's Manual POLL(2) NAME poll, ppoll - wait for some event on a file descriptor 零拷贝 零拷贝介绍 传统 Linux 的I/O 问题 传统的 Linux 系统的标准 I/O 接口（read、write）是基于数据拷贝的，也就是数据都是 copy_to_user 或者 copy_from_user，这样做的好处是，通过中间缓存的机制，减少磁盘 I/O 的操作，但是坏处也很明显，大量数据的拷贝，用户态和内核态的频繁切换，会消耗大量的 CPU 资源，严重影响数据传输的性能，统计表明，在Linux协议栈中，数据包在内核态和用户态之间的拷贝所用的时间甚至占到了数据包整个处理流程时间的57.1%\n以上图为例，一次完整的网络请求涉及IO数据流向为：网络协议栈 –\u003e 内核空间 –\u003e 用户空间 –\u003e 内核空间 – \u003e 磁盘– \u003e 内核空间– \u003e 用户空间– \u003e 内核空间– \u003e 网络协议栈。可观察到一次IO过程，数据被拷贝了多次。\n什么是零拷贝 零拷贝就是上述问题的一个解决方案，通过尽量避免拷贝操作来缓解 CPU 的压力。零拷贝并没有真正做\n到“0”拷贝，它更多是一种思想，很多的零拷贝技术都是基于这个思想去做的优化\n零拷贝相关技术 MMAP ( Memory Mapping ) mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问。\nmmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。\n实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。\n内存映射减少数据在用户空间和内核空间之间的拷贝操作,适合大量数据传输。\n以上图为例，网络请求到达内核空间（Socket缓存）后不再需要copy到用户空间，内存映射使得用户空间进程直接操作内核空间的数据，在处理完请求后，返回数据时也直接从内核空间（Kernerl缓存）拷贝到Socket缓存，再一次减少了内核空间与用户空间数据交换的过程。\n上面左图为传统读写,右图为MMAP.两者相比mmap要比普通的read系统调用少了一次copy的过程。因为read调用，进程是无法直接访问kernel space的，所以在read系统调用返回前，内核需要将数据从内核复制到进程指定的buffer。但mmap之后，进程可以直接访问mmap的数据(page cache)。\nSENDFIRL 实现效果与MMAP类似，减少了用户空间和内存空间的上下文切换（数据拷贝）\nDMA 辅助的 SENDFILE Kernel 到 Sockert 只需要传输文件描述符，而数据直接通过DMA拷贝到网络协议栈。\n","wordCount":"9368","inLanguage":"zh","datePublished":"2022-07-18T09:32:22Z","dateModified":"2022-07-18T09:32:22Z","author":{"@type":"Person","name":"wz"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://senmer.github.io/zh/posts/tech/linux/io%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},"publisher":{"@type":"Organization","name":"WZ's Blog","logo":{"@type":"ImageObject","url":"https://senmer.github.io/img/Q.gif"}}}</script></head><body id=top><script>(function(){let e,t=new RegExp("(^| )change-themes=([^;]*)(;|$)");(e=document.cookie.match(t))||((new Date).getHours()>=19||(new Date).getHours()<6?(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark")):(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")))})(),localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://senmer.github.io/zh/ accesskey=h title="WZ's Blog (Alt + H)"><img src=https://senmer.github.io/img/Q.gif alt=logo aria-label=logo height=35>WZ's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://senmer.github.io/zh/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://senmer.github.io/zh/ title="🏠 主页"><span>🏠 主页</span></a></li><li><a href=https://senmer.github.io/zh/posts/tech title="📚 文章"><span>📚 文章</span></a></li><li><a href=https://senmer.github.io/zh/categories/ title="🧩 分类"><span>🧩 分类</span></a></li><li><a href=https://senmer.github.io/zh/archives/ title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://senmer.github.io/zh/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li><li><a href=https://senmer.github.io/zh/links title="🤝 友链"><span>🤝 友链</span></a></li></ul></nav></header><main class="main page"><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}</style><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://senmer.github.io/zh/>🏠 主页</a>&nbsp;»&nbsp;<a href=https://senmer.github.io/zh/posts/>📚文章</a>&nbsp;»&nbsp;<a href=https://senmer.github.io/zh/posts/tech/>👨🏻‍💻 技术</a></div><h1 class=post-title>IO模型与零拷贝</h1><div class=post-meta><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}.parent-post-meta{display:flex;flex-wrap:wrap;opacity:.8}</style><span class=parent-post-meta><span id=post_meta_style_1><span class="fa fa-calendar-check-o"></span>
<span>2022-07-18
&nbsp;&nbsp;
</span></span><span id=post_meta_style_3><span class="fa fa-file-word-o"></span>
<span>9368字
&nbsp;&nbsp;
</span></span><span id=post_meta_style_4><span class="fa fa-clock-o"></span>
<span>19分钟
&nbsp;&nbsp;
</span></span><span id=post_meta_style_5><span class="fa fa-user-o"></span>
<span>wz
&nbsp;&nbsp;
</span></span><span id=post_meta_style_6><span class="fa fa-tags" style=opacity:.8></span>
<span><span class=post-tags-meta><a href=https://senmer.github.io/zh/tags/i/o/ style=color:var(--secondary)!important>I/O</a>
</span></span></span></span><span style=opacity:.8><span id=post_meta_style_7>&nbsp;&nbsp;
<span class="fa fa-eye"></span>
<span><span id=busuanzi_container_page_pv><span id=busuanzi_value_page_pv></span></span>
&nbsp;&nbsp;
</span></span><span id=post_meta_style_8><span class="fa fa-commenting-o"></span>
<span><script src=https://cdn.staticfile.org/twikoo/1.6.16/twikoo.all.min.js></script><script>let url=document.documentURI,dnsUrl="https://senmer.github.io/",urlSplit=url.split(dnsUrl),finalUrl=urlSplit[1];finalUrl[0]!=="/"&&(finalUrl="/"+finalUrl),twikoo.getCommentsCount({envId:"https://hugo-api-khaki.vercel.app/# 填写自己的twikoo id",region:null,urls:[finalUrl],includeReply:!1}).then(function(e){let t=e[0].count;const n=document.getElementById("comment_count");n.innerText=t}).catch(function(e){console.error(e)})</script><span id=comment_count></span></span></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#io%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label=I/O的定义>I/O的定义</a></li><li><a href=#linux-%e7%9a%84-io aria-label="Linux 的 I/O">Linux 的 I/O</a><ul><li><a href=#%e7%a3%81%e7%9b%98-io aria-label="磁盘 I/O">磁盘 I/O</a></li><li><a href=#%e7%bd%91%e7%bb%9c-io aria-label="网络 I/O">网络 I/O</a></li></ul></li><li><a href=#io-%e6%a8%a1%e5%9e%8b aria-label="I/O 模型">I/O 模型</a><ul><li><a href=#io%e6%a8%a1%e5%9e%8b%e7%9b%b8%e5%85%b3%e6%a6%82%e5%bf%b5 aria-label=I/O模型相关概念>I/O模型相关概念</a></li><li><a href=#%e7%bd%91%e7%bb%9c-io-%e6%a8%a1%e5%9e%8b aria-label="网络 I/O 模型">网络 I/O 模型</a><ul><li><a href=#%e9%98%bb%e5%a1%9e%e5%9e%8b--io-%e6%a8%a1%e5%9e%8bblocking-io aria-label="阻塞型 I/O 模型（blocking IO）"><strong>阻塞型</strong> I/O 模型（blocking IO）</a></li><li><a href=#%e9%9d%9e%e9%98%bb%e5%a1%9e-io-%e6%a8%a1%e5%9e%8bnonblocking-io aria-label="非阻塞 I/O 模型（nonblocking IO）">非阻塞 I/O 模型（nonblocking IO）</a></li><li><a href=#%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8-io-%e6%a8%a1-%e5%9e%8b-io-multiplexing- aria-label="多路复用 I/O 模 型（ I/O multiplexing ）">多路复用 I/O 模 型（ I/O multiplexing ）</a></li><li><a href=#%e4%bf%a1%e5%8f%b7%e9%a9%b1%e5%8a%a8%e5%bc%8f-io-%e6%a8%a1%e5%9e%8bsignal-driven-io aria-label="信号驱动式 I/O 模型（signal-driven IO）">信号驱动式 I/O 模型（signal-driven IO）</a></li><li><a href=#%e5%bc%82%e6%ad%a5-io-%e6%a8%a1%e5%9e%8b-asynchronous-io- aria-label="异步 I/O 模型（ asynchronous IO ）">异步 I/O 模型（ asynchronous IO ）</a></li><li><a href=#%e4%ba%94%e7%a7%8d-io-%e5%af%b9%e6%af%94 aria-label="五种 IO 对比">五种 IO 对比</a></li><li><a href=#io-%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f aria-label="I/O 的具体实现方式">I/O 的具体实现方式</a><ul><li><a href=#io-%e5%b8%b8%e8%a7%81%e5%ae%9e%e7%8e%b0 aria-label="I/O 常见实现">I/O 常见实现</a></li><li><a href=#%e5%b8%b8%e7%94%a8-io-%e6%a8%a1%e5%9e%8b%e6%af%94%e8%be%83 aria-label="常用 I/O 模型比较">常用 I/O 模型比较</a></li></ul></li></ul></li></ul></li><li><a href=#%e9%9b%b6%e6%8b%b7%e8%b4%9d aria-label=零拷贝>零拷贝</a><ul><li><a href=#%e9%9b%b6%e6%8b%b7%e8%b4%9d%e4%bb%8b%e7%bb%8d aria-label=零拷贝介绍>零拷贝介绍</a><ul><li><a href=#%e4%bc%a0%e7%bb%9f-linux-%e7%9a%84io-%e9%97%ae%e9%a2%98 aria-label="传统 Linux 的I/O 问题">传统 Linux 的I/O 问题</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e9%9b%b6%e6%8b%b7%e8%b4%9d aria-label=什么是零拷贝>什么是零拷贝</a></li></ul></li><li><a href=#%e9%9b%b6%e6%8b%b7%e8%b4%9d%e7%9b%b8%e5%85%b3%e6%8a%80%e6%9c%af aria-label=零拷贝相关技术>零拷贝相关技术</a><ul><li><a href=#mmap--memory-mapping- aria-label="MMAP ( Memory Mapping )"><strong>MMAP ( Memory Mapping )</strong></a></li><li><a href=#sendfirl aria-label=SENDFIRL>SENDFIRL</a></li><li><a href=#dma-%e8%be%85%e5%8a%a9%e7%9a%84-sendfile aria-label="DMA 辅助的 SENDFILE">DMA 辅助的 SENDFILE</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>本节内容主要用于理解Linux的I/O模型，以便更好地理解Nginx架构。</p><h1 id=io的定义>I/O的定义<a hidden class=anchor aria-hidden=true href=#io的定义>#</a></h1><p>I/O在计算机中指Input/Output， IOPS (Input/Output Per Second)即每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一。IOPS是指单位时间内系统能处理的I/O请求数量，一般以每秒处理的I/O请求数量为单位，I/O请求通常为读或写数据操作请求。</p><p>一次完整的I/O是用户空间的进程数据与内核空间的内核数据的报文的完整交换，但是由于内核空间与用户空间是严格隔离的，所以其数据交换过程中不能由用户空间的进程直接调用内核空间的内存数据，而是需要经历一次从内核空间中的内存数据copy到用户空间的进程内存当中，所以简单说I/O就是把数据从内核空间中的内存数据复制到用户空间中进程的内存当中。</p><h1 id=linux-的-io>Linux 的 I/O<a hidden class=anchor aria-hidden=true href=#linux-的-io>#</a></h1><ul><li>磁盘I/O</li><li>网络I/O : 一切皆文件,本质为对socket文件的读写</li></ul><h2 id=磁盘-io>磁盘 I/O<a hidden class=anchor aria-hidden=true href=#磁盘-io>#</a></h2><p>磁盘I/O是进程向内核发起系统调用，请求磁盘上的某个资源比如是html 文件或者图片，然后内核通过相应的驱动程序将目标文件加载到内核的内存空间，加载完成之后把数据从内核内存（内核空间）再复制给进程内存（用户空间），如果是比较大的数据也需要等待一定时间。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>机械磁盘的寻道时间、旋转延迟和数据传输时间：
</span></span><span style=display:flex><span>寻道时间：是指磁头移动到正确的磁道上所花费的时间，寻道时间越短则I/O处理就越快，目前磁盘的寻道时间一般在3-15毫秒左
</span></span><span style=display:flex><span>右。
</span></span><span style=display:flex><span>旋转延迟：是指将磁盘片旋转到数据所在的扇区到磁头下面所花费的时间，旋转延迟取决于磁盘的转速，通常使用磁盘旋转一周所
</span></span><span style=display:flex><span>需要时间的1/2之一表示，比如7200转的磁盘平均训传延迟大约为60*1000/7200/2=4.17毫秒，公式的意思为 （每分钟60秒*1000毫秒每秒/7200转每分/2），如果是15000转的则为60*1000/15000/2=2毫秒。
</span></span><span style=display:flex><span>数据传输时间：指的是读取到数据后传输数据的时间，主要取决于传输速率，这个值等于数据大小除以传输速率，目前的磁盘接口
</span></span><span style=display:flex><span>每秒的传输速度可以达到600MB，因此可以忽略不计。
</span></span><span style=display:flex><span>常见的机械磁盘平均寻道时间值：
</span></span><span style=display:flex><span>7200转/分的磁盘平均物理寻道时间：9毫秒
</span></span><span style=display:flex><span>10000转/分的磁盘平均物理寻道时间：6毫秒
</span></span><span style=display:flex><span>15000转/分的磁盘平均物理寻道时间：4毫秒
</span></span><span style=display:flex><span>常见磁盘的平均延迟时间：
</span></span><span style=display:flex><span>7200转的机械盘平均延迟：60*1000/7200/2 = 4.17ms
</span></span><span style=display:flex><span>10000转的机械盘平均延迟：60*1000/10000/2 = 3ms
</span></span><span style=display:flex><span>15000转的机械盘平均延迟：60*1000/15000/2 = 2ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>每秒最大IOPS的计算方法：
</span></span><span style=display:flex><span>7200转的磁盘IOPS计算方式：1000毫秒/(9毫秒的寻道时间+4.17毫秒的平均旋转延迟时间)=1000/13.13=75.9 IOPS
</span></span><span style=display:flex><span>10000转的磁盘的IOPS计算方式：1000毫秒/(6毫秒的寻道时间+3毫秒的平均旋转延迟时间)=1000/9=111IOPS
</span></span><span style=display:flex><span>15000转的磁盘的IOPS计算方式：15000毫秒/(4毫秒的寻道时间+2毫秒的平均旋转延迟时间)=1000/6=166.6 IOPS
</span></span></code></pre></div><h2 id=网络-io>网络 I/O<a hidden class=anchor aria-hidden=true href=#网络-io>#</a></h2><p>网络协议栈到用户空间进程的IO就是网络IO</p><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/8.png alt=image-20220718113856909></p><p><strong>网络I/O处理过程</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>获取请求数据，客户端与服务器建立连接发出请求，服务器接受请求（1-3）
</span></span><span style=display:flex><span>构建响应，当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）
</span></span><span style=display:flex><span>返回数据，服务器将已构建好的响应再通过内核空间的网络 I/O 返回给客户端（5-7）
</span></span></code></pre></div><p><strong>每次I/O都要经历的两个阶段</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>第一步：将数据从文件先加载至内核内存空间（缓冲区），等待数据准备完成，时间较长（网络数据拷贝）
</span></span><span style=display:flex><span>第二步：将数据从内核缓冲区复制到用户空间的进程的内存中，时间较短（内存数据拷贝）
</span></span></code></pre></div><h1 id=io-模型>I/O 模型<a hidden class=anchor aria-hidden=true href=#io-模型>#</a></h1><h2 id=io模型相关概念>I/O模型相关概念<a hidden class=anchor aria-hidden=true href=#io模型相关概念>#</a></h2><p>同步/异步：关注的是消息通信机制，即调用者在等待一件事情的处理结果时，被调用者是否提供完成状态的通知。</p><ul><li>同步：synchronous，被调用者并不提供事件的处理结果相关的通知消息，需要调用者主动询问事情是否处理完成</li><li>异步：asynchronous，被调用者通过状态、通知或回调机制主动通知调用者被调用者的运行状态</li></ul><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/9.png alt=image-20220718113656437></p><p>阻塞/非阻塞：关注调用者在等待结果返回之前所处的状态</p><ul><li>阻塞：blocking，指IO操作需要彻底完成后才返回到用户空间，调用结果返回之前，调用者被挂起，干不了别的事情。</li><li>非阻塞：nonblocking，指IO操作被调用后立即返回给用户一个状态值，而无需等到IO操作彻底完成，在最终的调用结果返回之前，调用者不会被挂起，可以去做别的事情。</li></ul><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/10.png alt=image-20220718113856911></p><h2 id=网络-io-模型>网络 I/O 模型<a hidden class=anchor aria-hidden=true href=#网络-io-模型>#</a></h2><p>阻塞型、非阻塞型、复用型、信号驱动型、异步</p><h3 id=阻塞型--io-模型blocking-io><strong>阻塞型</strong> I/O 模型（blocking IO）<a hidden class=anchor aria-hidden=true href=#阻塞型--io-模型blocking-io>#</a></h3><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/11-16581165732495.png alt=image-20220718113856912></p><p>阻塞IO模型是最简单的I/O模型，用户线程在内核进行IO操作时被阻塞。</p><p>用户线程通过系统调用read发起I/O读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。</p><p>用户需要等待read将数据读取到buffer后，才继续处理接收的数据。整个I/O请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</p><p>优点：程序简单，在阻塞等待数据期间进程/线程挂起，基本不会占用 CPU 资源。</p><p>缺点：每个连接需要独立的进程/线程单独处理，当并发请求量大时为了维护程序，内存、线程切换开销较大。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>同步阻塞：程序向内核发送I/O请求后一直等待内核响应，如果内核处理请求的IO操作不能立即返回, 则进程将一直等待并不再接受新的请求，并由进程轮询查看I/O是否完成，完成后进程将I/O结果返回给Client，在IO没有返回期间进程不能接受其他客户的请求，而且是由进程自己去查看I/O是否完成，这种方式简单，但是比较慢，用的比较少。
</span></span></code></pre></div><h3 id=非阻塞-io-模型nonblocking-io>非阻塞 I/O 模型（nonblocking IO）<a hidden class=anchor aria-hidden=true href=#非阻塞-io-模型nonblocking-io>#</a></h3><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/12-165811710367510.png alt=非阻塞IO模型></p><p>用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。即 “轮询”机制存在两个问题：如果有大量文件描述符都要等，那么就得一个一个read。这会带来大量的Context Switch（read是系统调用，每调用一次就得在用户态和核心态切换一次）。轮询的时间不好把握。这里需要估计数据需要多久之后才能准备好。等待时间设的太长，程序响应延迟就过大; 设的太短，就会造成过于频繁的重试，干耗CPU而已，是比较浪费CPU的方式，一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>非阻塞：程序向内核发送请I/O求后一直等待内核响应，如果内核处理请求的IO操作不能立即返回IO结果，进程将不再等待，而是继续处理其他请求，但是仍然需要进程隔一段时间就要查看内核I/O是否完成。
</span></span></code></pre></div><p>由上图可知，在设置连接为非阻塞时，当应用进程系统调用 recvfrom 没有数据返回时，内核会立即返回一个 EWOULDBLOCK 错误，而不会一直阻塞到数据准备好。如上图在第四次调用时有一个数据报准备好了，所以这时数据会被复制到应用进程缓冲区 ，于是 recvfrom 成功返回数据。</p><p>当一个应用进程这样循环调用 recvfrom 时，称之为轮询 polling 。这么做往往会耗费大量CPU时间，这种模型实际很少被使用。</p><h3 id=多路复用-io-模-型-io-multiplexing->多路复用 I/O 模 型（ I/O multiplexing ）<a hidden class=anchor aria-hidden=true href=#多路复用-io-模-型-io-multiplexing->#</a></h3><p>上面的模型中, 每一个文件描述符对应的IO均由一个线程监控和处理（有多少文件描述符就要生成多少个线程）</p><p>多路复用IO指一个线程可以同时（实际是交替实现，即并发完成）监控和处理多个文件描述符对应各自的IO，即复用同一个线程</p><p>一个线程之所以能实现同时处理多个IO, 是因为这个线程调用了内核中的SELECT, POLL或EPOLL等系统调用，从而实现多路复用IO</p><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/13.png alt=多路复用></p><p>I/O multiplexing 主要包括:select，poll，epoll三种系统调用，select/poll/epoll的好处就在于单个process（进程）就可以同时处理多个网络连接的IO。</p><p>它的基本原理就是select/poll/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>IO多路复用（IO Multiplexing) ：是一种机制，程序注册一组socket文件描述符给操作系统，表示“我要监视这些fd是否有IO事件发生，有了就告诉程序处理”；
</span></span><span style=display:flex><span>IO多路复用一般和NIO（nonblocking IO）一起使用的。NIO和IO多路复用是相对独立的。NIO仅仅是指IO API总是能立刻返回，不会被Blocking; 而IO多路复用仅仅是操作系统提供的一种便利的通知机制。操作系统并不会强制这俩必须得一起用，可以只用IO多路复用 + BIO（blocking IO），这时还是当前线程被卡住。IO多路复用和NIO是要配合一起使用才有实际意义；
</span></span><span style=display:flex><span>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备就绪，就通知该进程；
</span></span><span style=display:flex><span>多个连接共用一个等待机制，本模型会阻塞进程，但是进程是阻塞在select或者poll这两个系统调用上，而不是阻塞在真正的IO操作上；
</span></span><span style=display:flex><span>用户首先将需要进行IO操作添加到select中，同时等待select系统调用返回。当数据到达时，IO被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行；
</span></span><span style=display:flex><span>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视IO，以及调用select函数的额外操作，效率更差。并且阻塞了两次，但是第一次阻塞在select上时，select可以监控多个IO上是否已有IO操作准备就绪，即可达到在同一个线程内同时处理多个IO请求的目的。而不像阻塞IO那种，一次只能监控一个IO；
</span></span><span style=display:flex><span>虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只是注册自己需要的IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率；
</span></span><span style=display:flex><span>IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO模型，而非真正的异步IO；
</span></span></code></pre></div><p><strong>优缺点</strong></p><ul><li>优点：可以基于一个阻塞对象，同时在多个描述符上等待就绪，而不是使用多个线程(每个文件描述符一个线程)，这样可以大大节省系统资源</li><li>缺点：当连接数较少时效率相比多线程+阻塞 I/O 模型效率较低，可能延迟更大，因为单个连接处理需要 2 次系统调用（select和recvfrom），占用时间会有增加</li></ul><p><strong>IO多路复用适用如下场合：</strong></p><ul><li>当客户端处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用</li><li>当一个客户端同时处理多个套接字时，此情况可能的但很少出现</li><li>当一个服务器既要处理监听套接字，又要处理已连接套接字，一般也要用到I/O复用</li><li>当一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用</li><li>当一个服务器要处理多个服务或多个协议，一般要使用I/O复用</li></ul><h3 id=信号驱动式-io-模型signal-driven-io>信号驱动式 I/O 模型（signal-driven IO）<a hidden class=anchor aria-hidden=true href=#信号驱动式-io-模型signal-driven-io>#</a></h3><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/14.png alt=信号驱动IO></p><p>信号驱动I/O的意思就是进程现在不用傻等着，也不用去轮询。而是让内核在数据就绪时，发送信号通知进程。</p><p>调用的步骤是，通过系统调用 sigaction ，并注册一个信号处理的回调函数，该调用会立即返回，然后主程序可以继续向下执行，当有I/O操作准备就绪,即内核数据就绪时，内核会为该进程产生一个 SIGIO信号，并回调注册的信号回调函数，这样就可以在信号回调函数中系统调用 recvfrom 获取数据,将用户进程所需要的数据从内核空间拷贝到用户空间。此模型的优势在于等待数据报到达期间进程不被阻塞。用户主程序可以继续执行，只要等待来自信号处理函数的通知。</p><p>在信号驱动式 I/O 模型中，应用程序使用套接口进行信号驱动 I/O，并注册一个信号处理函数，进程继续运行并不阻塞，当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。</p><p>优点：线程并没有在等待数据时被阻塞，内核直接返回调用接收信号，不影响进程继续处理其他请求因此可以提高资源的利用率。</p><p>缺点：信号 I/O 在大量 IO 操作时可能会因为信号队列溢出导致没法通知。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>异步阻塞：程序进程向内核发送IO调用后，不用等待内核响应，可以继续接受其他请求，内核收到进程请求后进行的IO如果不能立即返回，就由内核等待结果，直到IO完成后内核再通知进程。
</span></span></code></pre></div><h3 id=异步-io-模型-asynchronous-io->异步 I/O 模型（ asynchronous IO ）<a hidden class=anchor aria-hidden=true href=#异步-io-模型-asynchronous-io->#</a></h3><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/15.png alt=异步IO模型></p><p>异步I/O 与 信号驱动I/O最大区别在于，信号驱动是内核通知用户进程何时开始一个I/O操作，而异步I/O是由内核通知用户进程I/O操作何时完成，两者有本质区别在于异步IO相当于不用去饭店场吃饭，直接点个外卖，把等待上菜的时间也给省了。</p><p>相对于同步I/O，异步I/O不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。</p><p>信号驱动IO当内核通知触发信号处理程序时，信号处理程序还需要阻塞在从内核空间缓冲区拷贝数据到用户空间缓冲区这个阶段，而异步IO直接是在第二个阶段完成后，内核直接通知用户线程可以进行后续操作了</p><p>优点：异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠</p><p>缺点：要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O，在 Linux 系统下，Linux 2.6才引入，目前 AIO 并不完善，因此在 Linux 下实现高并发网络编程时以 IO 复用模型模式+多线程任务的架构基本可以满足需求</p><p>Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>异步非阻塞：程序进程向内核发送IO调用后，不用等待内核响应，可以继续接受其他请求，内核调用的IO如果不能立即返回，内核会继续处理其他事物，直到IO完成后将结果通知给内核，内核在将IO完成的结果返回给进程，期间进程可以接受新的请求，内核也可以处理新的事物，因此相互不影响，可以实现较大的同时并实现较高的IO复用，因此异步非阻塞是使用最多的一种通信方式。
</span></span></code></pre></div><h3 id=五种-io-对比>五种 IO 对比<a hidden class=anchor aria-hidden=true href=#五种-io-对比>#</a></h3><p>这五种 I/O 模型中，越往后，阻塞越少，理论上效率也是最优前四种属于同步 I/O，因为其中真正的 I/O 操作(recvfrom)将阻塞进程/线程，只有异步 I/O 模型才与 POSIX 定义的异步 I/O 相匹配。</p><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/16.png alt=IO对比></p><h3 id=io-的具体实现方式>I/O 的具体实现方式<a hidden class=anchor aria-hidden=true href=#io-的具体实现方式>#</a></h3><h4 id=io-常见实现>I/O 常见实现<a hidden class=anchor aria-hidden=true href=#io-常见实现>#</a></h4><p>Nginx支持在多种不同的操作系统实现不同的事件驱动模型，但是其在不同的操作系统甚至是不同的系统版本上面的实现方式不尽相同，主要有以下实现方式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>1、select：
</span></span><span style=display:flex><span>select库是在linux和windows平台都基本支持的 事件驱动模型库，并且在接口的定义也基本相同，只是部分参数的含义略有差异，最大并发限制1024，是最早期的事件驱动模型。
</span></span><span style=display:flex><span>2、poll： 在Linux 的基本驱动模型，windows不支持此驱动模型，是select的升级版，取消了最大的并发限制，在编译nginx的时候可以使用--with-poll_module和--without-poll_module这两个指定是否编译select库。
</span></span><span style=display:flex><span>3、epoll：
</span></span><span style=display:flex><span>epoll是库是Nginx服务器支持的最高性能的事件驱动库之一，是公认的非常优秀的事件驱动模型，它和select和poll有很大的区别，epoll是poll的升级版，但是与poll有很大的区别.
</span></span><span style=display:flex><span>epoll的处理方式是创建一个待处理的事件列表，然后把这个列表发给内核，返回的时候在去轮训检查这个表，以判断事件是否发生，epoll支持一个进程打开的最大事件描述符的上限是系统可以打开的文件的最大数，同时epoll库的I/O效率不随描述符数目增加而线性下降，因为它只会对内核上报的“活跃”的描述符进行操作。
</span></span><span style=display:flex><span>4、kqueue：
</span></span><span style=display:flex><span>用于支持BSD系列平台的高校事件驱动模型，主要用在FreeBSD 4.1及以上版本、OpenBSD 2.0级以上版本，NetBSD级以上版本及Mac OS X 平台上，该模型也是poll库的变种，因此和epoll没有本质上的区别，都是通过避免轮训操作提供效率。
</span></span><span style=display:flex><span>5、Iocp：
</span></span><span style=display:flex><span> Windows系统上的实现方式，对应第5种（异步I/O）模型。
</span></span><span style=display:flex><span>6、rtsig：
</span></span><span style=display:flex><span>不是一个常用事件驱动，最大队列1024，不是很常用
</span></span><span style=display:flex><span>7、/dev/poll:
</span></span><span style=display:flex><span>用于支持unix衍生平台的高效事件驱动模型，主要在Solaris 平台、HP/UX，该模型是sun公司在开发Solaris系列平台的时候提出的用于完成事件驱动机制的方案，它使用了虚拟的/dev/poll设备，开发人员将要见识的文件描述符加入这个设备，然后通过ioctl()调用来获取事件通知，因此运行在以上系列平台的时候请使用/dev/poll事件驱动机制。
</span></span><span style=display:flex><span>8、eventport：
</span></span><span style=display:flex><span>该方案也是sun公司在开发Solaris的时候提出的事件驱动库，只是Solaris 10以上的版本，该驱动库看防止内核崩溃等情况的发生。
</span></span></code></pre></div><h4 id=常用-io-模型比较>常用 I/O 模型比较<a hidden class=anchor aria-hidden=true href=#常用-io-模型比较>#</a></h4><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/17.png alt=IO模型比较></p><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/18.png alt=image-10></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Select：
</span></span><span style=display:flex><span>POSIX所规定，目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。
</span></span><span style=display:flex><span>缺点：
</span></span><span style=display:flex><span>单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义FD_SETSIZE，再重新编译内核实现，但是这样也会造成效率的降低
</span></span><span style=display:flex><span>单个进程可监视的fd数量被限制，默认是1024，修改此值需要重新编译内核
</span></span><span style=display:flex><span>对socket是线性扫描，即采用轮询的方法，效率较低
</span></span><span style=display:flex><span>select 采取了内存拷贝方法来实现内核将 FD 消息通知给用户空间，这样一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>poll：
</span></span><span style=display:flex><span>本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态
</span></span><span style=display:flex><span>其没有最大连接数的限制，原因是它是基于链表来存储的
</span></span><span style=display:flex><span>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义
</span></span><span style=display:flex><span>poll特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd 
</span></span><span style=display:flex><span>select是边缘触发即只通知一次
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>epoll： 在Linux 2.6内核中提出的select和poll的增强版本
</span></span><span style=display:flex><span>支持水平触发LT和边缘触发ET，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次
</span></span><span style=display:flex><span>使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知
</span></span><span style=display:flex><span>优点:
</span></span><span style=display:flex><span>没有最大并发连接的限制：能打开的FD的上限远大于1024(1G的内存能监听约10万个端口)，具体查看/proc/sys/fs/file-max，此值和系统内存大小相关
</span></span><span style=display:flex><span>效率提升：非轮询的方式，不会随着FD数目的增加而效率下降;只有活跃可用的FD才会调用callback函数，即epoll最大的优点就在于它只管理“活跃”的连接，而跟连接总数无关
</span></span><span style=display:flex><span>内存拷贝，利用mmap(Memory Mapping)加速与内核空间的消息传递;即epoll使用mmap减少复制开销
</span></span></code></pre></div><p><strong>总结</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>1、epoll只是一组API，比起select这种扫描全部的文件描述符，epoll只读取就绪的文件描述符，再加入基于事件的就绪通知机制，所以性能比较好
</span></span><span style=display:flex><span>2、基于epoll的事件多路复用减少了进程间切换的次数，使得操作系统少做了相对于用户任务来说的无用功。
</span></span><span style=display:flex><span>3、epoll比select等多路复用方式来说，减少了遍历循环及内存拷贝的工作量，因为活跃连接只占总并发连接的很小一部分。
</span></span></code></pre></div><p>范例：最大并发连接数和内存有直接关系</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#内存1G</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@centos8 ~<span style=color:#f92672>]</span><span style=color:#75715e>#free -h</span>
</span></span><span style=display:flex><span>             total       used       free     shared buff/cache   available
</span></span><span style=display:flex><span>Mem:         952Mi       168Mi       605Mi       12Mi       178Mi       629Mi
</span></span><span style=display:flex><span>Swap:         2.0Gi         0B       2.0Gi
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@centos8 ~<span style=color:#f92672>]</span><span style=color:#75715e>#cat /proc/sys/fs/file-max</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>92953</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#内存2G</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@centos8 ~<span style=color:#f92672>]</span><span style=color:#75715e>#free -h</span>
</span></span><span style=display:flex><span>             total       used       free     shared buff/cache   available
</span></span><span style=display:flex><span>Mem:          1.9Gi       258Mi       1.3Gi       12Mi       341Mi       1.6Gi
</span></span><span style=display:flex><span>Swap:         2.0Gi         0B       2.0Gi
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@centos8 ~<span style=color:#f92672>]</span><span style=color:#75715e>#cat /proc/sys/fs/file-max</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>195920</span>
</span></span></code></pre></div><p>范例：内核限制</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>root@centos8 ~<span style=color:#f92672>]</span><span style=color:#75715e>#grep -R FD_SETSIZE linux-5.8/*</span>
</span></span><span style=display:flex><span>linux-5.8/Documentation/userspace-api/media/v4l/func-select.rst:   
</span></span><span style=display:flex><span><span style=color:#e6db74>``</span>FD_SETSIZE<span style=color:#e6db74>``</span>.
</span></span><span style=display:flex><span>linux-5.8/include/uapi/linux/posix_types.h:#undef __FD_SETSIZE
</span></span><span style=display:flex><span>linux-5.8/include/uapi/linux/posix_types.h:#define __FD_SETSIZE <span style=color:#ae81ff>1024</span> <span style=color:#75715e>#单个进程能够</span>
</span></span><span style=display:flex><span>监视的文件描述符的文件最大数量
</span></span><span style=display:flex><span>linux-5.8/include/uapi/linux/posix_types.h: unsigned long fds_bits<span style=color:#f92672>[</span>__FD_SETSIZE 
</span></span><span style=display:flex><span>/ <span style=color:#f92672>(</span><span style=color:#ae81ff>8</span> * sizeof<span style=color:#f92672>(</span>long<span style=color:#f92672>))]</span>;
</span></span><span style=display:flex><span>linux-5.8/tools/include/nolibc/nolibc.h:#define FD_SETSIZE <span style=color:#ae81ff>256</span>
</span></span><span style=display:flex><span>linux-5.8/tools/include/nolibc/nolibc.h:typedef struct <span style=color:#f92672>{</span> uint32_t 
</span></span><span style=display:flex><span>fd32<span style=color:#f92672>[</span>FD_SETSIZE/32<span style=color:#f92672>]</span>; <span style=color:#f92672>}</span> fd_set;
</span></span><span style=display:flex><span>linux-5.8/tools/include/nolibc/nolibc.h: <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>fd &lt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> fd &gt;<span style=color:#f92672>=</span> FD_SETSIZE<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>linux-5.8/tools/testing/selftests/net/nettest.c: rc <span style=color:#f92672>=</span> <span style=color:#66d9ef>select</span><span style=color:#f92672>(</span>FD_SETSIZE, 
</span></span><span style=display:flex><span>NULL, &amp;wfd, NULL, tv<span style=color:#f92672>)</span>;
</span></span></code></pre></div><p>范例：select 和 epoll 帮助</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>root@centos8 ~<span style=color:#f92672>]</span><span style=color:#75715e>#whatis epoll</span>
</span></span><span style=display:flex><span>epoll <span style=color:#f92672>(</span>7<span style=color:#f92672>)</span>            - I/O event notification facility
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@centos8 ~<span style=color:#f92672>]</span><span style=color:#75715e>#whatis select</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>           - synchronous I/O multiplexing
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>           - synchronous I/O multiplexing
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>(</span>3p<span style=color:#f92672>)</span>          - synchronous I/O multiplexing
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@centos8 ~<span style=color:#f92672>]</span><span style=color:#75715e>#whatis poll</span>
</span></span><span style=display:flex><span>poll <span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>             - wait <span style=color:#66d9ef>for</span> some event on a file descriptor
</span></span><span style=display:flex><span>poll <span style=color:#f92672>(</span>3p<span style=color:#f92672>)</span>            - input/output multiplexing
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@centos8 ~<span style=color:#f92672>]</span><span style=color:#75715e>#man 2 select</span>
</span></span><span style=display:flex><span>SELECT<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>                                               Linux Programmer<span style=color:#e6db74>&#39;s 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Manual                                               SELECT(2)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>NAME
</span></span></span><span style=display:flex><span><span style=color:#e6db74>       select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>multiplexing
</span></span></span><span style=display:flex><span><span style=color:#e6db74>[root@centos8 ~]#man 2 poll
</span></span></span><span style=display:flex><span><span style=color:#e6db74>POLL(2)                                                 Linux Programmer&#39;</span>s 
</span></span><span style=display:flex><span>Manual                                                 POLL<span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>NAME
</span></span><span style=display:flex><span>       poll, ppoll - wait <span style=color:#66d9ef>for</span> some event on a file descriptor
</span></span></code></pre></div><h1 id=零拷贝>零拷贝<a hidden class=anchor aria-hidden=true href=#零拷贝>#</a></h1><h2 id=零拷贝介绍>零拷贝介绍<a hidden class=anchor aria-hidden=true href=#零拷贝介绍>#</a></h2><h3 id=传统-linux-的io-问题>传统 Linux 的I/O 问题<a hidden class=anchor aria-hidden=true href=#传统-linux-的io-问题>#</a></h3><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/19.jpg alt=IO></p><p>传统的 Linux 系统的标准 I/O 接口（read、write）是基于数据拷贝的，也就是数据都是 copy_to_user 或者 copy_from_user，这样做的好处是，通过中间缓存的机制，减少磁盘 I/O 的操作，但是坏处也很明显，大量数据的拷贝，用户态和内核态的频繁切换，会消耗大量的 CPU 资源，严重影响数据传输的性能，统计表明，在Linux协议栈中，数据包在内核态和用户态之间的拷贝所用的时间甚至占到了数据包整个处理流程时间的57.1%</p><p>以上图为例，一次完整的网络请求涉及IO数据流向为：网络协议栈 &ndash;> 内核空间 &ndash;> 用户空间 &ndash;> 内核空间 &ndash; > 磁盘&ndash; > 内核空间&ndash; > 用户空间&ndash; > 内核空间&ndash; > 网络协议栈。可观察到一次IO过程，数据被拷贝了多次。</p><h3 id=什么是零拷贝>什么是零拷贝<a hidden class=anchor aria-hidden=true href=#什么是零拷贝>#</a></h3><p>零拷贝就是上述问题的一个解决方案，通过尽量避免拷贝操作来缓解 CPU 的压力。零拷贝并没有真正做</p><p>到“0”拷贝，它更多是一种思想，很多的零拷贝技术都是基于这个思想去做的优化</p><h2 id=零拷贝相关技术>零拷贝相关技术<a hidden class=anchor aria-hidden=true href=#零拷贝相关技术>#</a></h2><h3 id=mmap--memory-mapping-><strong>MMAP ( Memory Mapping )</strong><a hidden class=anchor aria-hidden=true href=#mmap--memory-mapping->#</a></h3><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/20.jpg alt=MMAP></p><p>mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问。</p><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。</p><p>实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p><p>内存映射减少数据在用户空间和内核空间之间的拷贝操作,适合大量数据传输。</p><p>以上图为例，网络请求到达内核空间（Socket缓存）后不再需要copy到用户空间，内存映射使得用户空间进程直接操作内核空间的数据，在处理完请求后，返回数据时也直接从内核空间（Kernerl缓存）拷贝到Socket缓存，再一次减少了内核空间与用户空间数据交换的过程。</p><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/21.jpg alt=内存映射示意></p><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/22.png alt=传统读写与内存映射的比较></p><p>上面左图为传统读写,右图为MMAP.两者相比mmap要比普通的read系统调用少了一次copy的过程。因为read调用，进程是无法直接访问kernel space的，所以在read系统调用返回前，内核需要将数据从内核复制到进程指定的buffer。但mmap之后，进程可以直接访问mmap的数据(page cache)。</p><h3 id=sendfirl>SENDFIRL<a hidden class=anchor aria-hidden=true href=#sendfirl>#</a></h3><p>实现效果与MMAP类似，减少了用户空间和内存空间的上下文切换（数据拷贝）</p><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/23.jpg alt=sendfile></p><h3 id=dma-辅助的-sendfile>DMA 辅助的 SENDFILE<a hidden class=anchor aria-hidden=true href=#dma-辅助的-sendfile>#</a></h3><p><img loading=lazy src=/images/IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d/24.jpg alt=硬件辅助的SENDFILE></p><p>Kernel 到 Sockert 只需要传输文件描述符，而数据直接通过DMA拷贝到网络协议栈。</p></div><div class=post-reward><div style=padding:0;margin:0;width:100%;font-size:16px;text-align:center><div id=QR style=opacity:0><div id=wechat style=display:inline-block><a class=fancybox rel=group><img id=wechat_qr src=https://senmer.github.io/img/wechat_pay.png alt=wechat_pay></a><p>微信</p></div><div id=alipay style=display:inline-block><a class=fancybox rel=group><img id=alipay_qr src=https://senmer.github.io/img/alipay.png alt=alipay></a><p>支付宝</p></div></div><button id=rewardButton onclick='var qr=document.getElementById("QR");qr.style.opacity==="0"?qr.style.opacity="1":qr.style.opacity="0"'>
<span>🧧 鼓励</span></button></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://senmer.github.io/zh/posts/tech/nginx/nginx%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/><span class=title>« 上一页</span><br><span>Nginx架构简介</span>
</a><a class=next href=https://senmer.github.io/zh/posts/tech/data_sync/windows%E5%90%91linux%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE/><span class=title>下一页 »</span><br><span>windows向linux同步数据</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share IO模型与零拷贝 on twitter" href="https://twitter.com/intent/tweet/?text=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d&amp;url=https%3a%2f%2fsenmer.github.io%2fzh%2fposts%2ftech%2flinux%2fio%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258E%25E9%259B%25B6%25E6%258B%25B7%25E8%25B4%259D%2f&amp;hashtags=I%2fO"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share IO模型与零拷贝 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsenmer.github.io%2fzh%2fposts%2ftech%2flinux%2fio%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258E%25E9%259B%25B6%25E6%258B%25B7%25E8%25B4%259D%2f&amp;title=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d&amp;summary=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d&amp;source=https%3a%2f%2fsenmer.github.io%2fzh%2fposts%2ftech%2flinux%2fio%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258E%25E9%259B%25B6%25E6%258B%25B7%25E8%25B4%259D%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share IO模型与零拷贝 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsenmer.github.io%2fzh%2fposts%2ftech%2flinux%2fio%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258E%25E9%259B%25B6%25E6%258B%25B7%25E8%25B4%259D%2f&title=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share IO模型与零拷贝 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsenmer.github.io%2fzh%2fposts%2ftech%2flinux%2fio%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258E%25E9%259B%25B6%25E6%258B%25B7%25E8%25B4%259D%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share IO模型与零拷贝 on whatsapp" href="https://api.whatsapp.com/send?text=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d%20-%20https%3a%2f%2fsenmer.github.io%2fzh%2fposts%2ftech%2flinux%2fio%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258E%25E9%259B%25B6%25E6%258B%25B7%25E8%25B4%259D%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share IO模型与零拷贝 on telegram" href="https://telegram.me/share/url?text=IO%e6%a8%a1%e5%9e%8b%e4%b8%8e%e9%9b%b6%e6%8b%b7%e8%b4%9d&amp;url=https%3a%2f%2fsenmer.github.io%2fzh%2fposts%2ftech%2flinux%2fio%25E6%25A8%25A1%25E5%259E%258B%25E4%25B8%258E%25E9%259B%25B6%25E6%258B%25B7%25E8%25B4%259D%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></div><style>.comments_details summary::marker{font-size:20px;content:'👉展开评论';color:var(--content)}.comments_details[open] summary::marker{font-size:20px;content:'👇关闭评论';color:var(--content)}</style><div><details class=comments_details open><summary style=display:none></summary><div id=tcomment></div></details><script src=https://cdn.staticfile.org/twikoo/1.6.16/twikoo.all.min.js></script><script>twikoo.init({envId:"https://hugo-api-khaki.vercel.app/# 填写自己的twikoo id",el:"#tcomment",lang:"zh-CN",region:null,path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><span>Copyright
&copy;
2020-2023
<a href=https://senmer.github.io/zh/ style=color:#939393>WZ's Blog</a>
All Rights Reserved
</span><a href=https://beian.miit.gov.cn/ target=_blank style=color:#939393></a>&nbsp;
<span><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null" style=display:inline-block;text-decoration:none;height:20px;color:#939393><img src style="float:left;margin:0 5px 0 0">
</a></span><span id=busuanzi_container><span class="fa fa-user"></span> <span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye"></span> <span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg><span id=read_progress></span>
</span></a><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>200||document.documentElement.scrollTop>200?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{(function(){document.cookie="change-themes="+escape("false")})(),document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.body.addEventListener("copy",function(e){if(window.getSelection().toString()&&window.getSelection().toString().length>50){let t=e.clipboardData||window.clipboardData;if(t){e.preventDefault();let n=window.getSelection().toString(),s=window.getSelection().toString();t.setData("text/html",n),t.setData("text/plain",s)}}})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="复制";function i(){t.innerText="已复制！",setTimeout(()=>{t.innerText="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){let t=e.textContent;navigator.clipboard.writeText(t),i();return}const n=document.createRange();n.selectNodeContents(e);const s=window.getSelection();s.removeAllRanges(),s.addRange(n);try{document.execCommand("copy"),i()}catch{}s.removeRange(n)});let l=e.className.replaceAll("language-",""),n=document.createElement("div"),a=document.createElement("div"),r=document.createElement("div"),c=document.createElement("div"),o=document.createElement("div");o.innerText=l,n.setAttribute("class","mac-tool"),a.setAttribute("class","mac bb1"),r.setAttribute("class","mac bb2"),c.setAttribute("class","mac bb3"),o.setAttribute("class","language-type"),n.appendChild(a),n.appendChild(r),n.appendChild(c),n.appendChild(o),s.classList.contains("highlight")?(s.appendChild(t),s.appendChild(n)):s.parentNode.firstChild==s||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?(e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t),s.appendChild(n)):(e.parentNode.appendChild(t),s.appendChild(n)))})</script></body></html>